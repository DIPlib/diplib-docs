<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Geometric transformations module | DIPlib | a library for quantitative image analysis</title>
  <link rel="stylesheet" href="m-dip+documentation.compiled.css" />
  <link rel="icon" href="DIPlib_logo_32.png" type="image/png" />
  <link rel="search" type="application/opensearchdescription+xml" href="opensearch.xml" title="Search DIPlib documentation" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#ffffff" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://diplib.org"><img src="DIPlib_logo.svg" alt="" />DIPlib</a><span class="m-breadcrumb">┃</span><a href="index.html" class="m-thin">a library for quantitative image analysis</a><span class="m-breadcrumb">┃</span><a href="https://github.com/DIPlib/diplib/releases/tag/3.5.2" class="m-thin">version 3.5.2</a>      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="classes.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Geometric transformations <span class="m-thin">module</span>          <div class="m-doc-include m-code m-thin m-text-right">#include <a href="file--diplib--geometry-h.html">"diplib/geometry.h"</a></div>
        </h1>
        <p>Geometric image transformations.</p>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#interpolation_methods">Interpolation methods</a></li>
            <li>
              Reference
              <ul>
                <li><a href="#alias-members">Aliases</a></li>
                <li><a href="#function-members">Functions</a></li>
              </ul>
            </li>
          </ul>
        </div>
          <h2 id="interpolation_methods">Interpolation methods</h2>
<p>Many of the functions in this group resample the image using an interpolation method. They all perform
interpolation separately (i.e. along one dimension at the time). These functions have an input argument
called <code>interpolationMethod</code>, which determines how image data are interpolated. It can be set to one of
the following strings:</p>
<ul>
<li>
<p><code>"3-cubic"</code> (or <code>""</code>): Third-order cubic spline interpolation (Keys, 1981), using 4 input samples to
  compute each output sample. This is the default method for most functions.</p>
</li>
<li>
<p><code>"4-cubic"</code>: Fourth-order cubic spline interpolation (Keys, 1981), using 6 input samples to compute
  each output sample.</p>
</li>
<li>
<p><code>"linear"</code>: Linear interpolation, using 2 input samples to compute each output sample.</p>
</li>
<li>
<p><code>"nearest"</code> (or <code>"nn"</code>): Nearest neighbor interpolation, samples are simply shifted and replicated.</p>
</li>
<li>
<p><code>"inverse nearest"</code> (or <code>"nn2"</code>): Nearest neighbor interpolation, but resolves the rounding of x.5 in
  the opposite direction that <code>"nearest"</code> does. This is useful when applying the inverse of an earlier
  transform, to be able to obtain the original geometry back.</p>
</li>
<li>
<p><code>"bspline"</code>: A third-order cardinal B-spline is computed for all samples on an image line, which is
  sampled anew to obtain the interpolated sample values. All input samples are used to compute all
  output samples, but only about 10 input samples significantly influence each output value.</p>
</li>
<li>
<p><code>"lanczos8"</code>: Lanczos interpolation with <em>a</em> = 8, using 16 input samples to compute each output sample.
  The Lanczos kernel is a sinc function windowed by a larger sinc function, where <em>a</em> is the width of
  the larger sinc function. The kernel is normalized.</p>
</li>
<li>
<p><code>"lanczos6"</code>: Lanczos interpolation with <em>a</em> = 6, using 12 input samples to compute each output sample.</p>
</li>
<li>
<p><code>"lanczos4"</code>: Lanczos interpolation with <em>a</em> = 4, using 8 input samples to compute each output sample.</p>
</li>
<li>
<p><code>"lanczos3"</code>: Lanczos interpolation with <em>a</em> = 3, using 6 input samples to compute each output sample.</p>
</li>
<li>
<p><code>"lanczos2"</code>: Lanczos interpolation with <em>a</em> = 2, using 4 input samples to compute each output sample.</p>
</li>
<li>
<p><code>"ft"</code>: Interpolation through padding and cropping, and/or modifying the phase component of the
  Fourier transform of the image line. Padding with zeros increases the sampling density, cropping
  reduces the sampling density, and multiplying the phase component by <span class="m-math"><svg style="width: 2.608em; height: 1.012em; vertical-align: -0.246em;  vertical-align: -0.247em;" viewBox=".74 -7.66 26.08 10.12">
<title>
\(-j s \omega\)
</title>
<defs>
<path id='eq1-g4-57' d='M1.69-.33L2.93-5.23L2.89-5.25C1.89-5.07 1.25-4.98 .87-4.95V-4.76L1.19-4.78H1.27C1.61-4.78 1.75-4.66 1.75-4.39C1.75-4.28 1.7-4.03 1.56-3.44L.7 .04C.3 1.68 .02 2.19-.45 2.19C-.6 2.19-.67 2.14-.67 2.06C-.67 2.01-.66 1.99-.61 1.93C-.54 1.83-.51 1.77-.51 1.68C-.51 1.43-.73 1.24-1 1.24S-1.48 1.45-1.48 1.74C-1.48 2.17-1.08 2.47-.54 2.47C.5 2.47 1.21 1.57 1.69-.33ZM3.59-7C3.59-7.35 3.31-7.66 2.99-7.66S2.37-7.4 2.37-7.03C2.37-6.65 2.66-6.4 3-6.4C3.31-6.4 3.59-6.67 3.59-7Z'/>
<path id='eq1-g4-66' d='M3.62-1.42C3.62-1.88 3.37-2.39 2.81-3.08C2.36-3.64 2.17-4.01 2.17-4.34C2.17-4.74 2.42-4.98 2.83-4.98C3.45-4.98 3.81-4.54 3.93-3.61H4.12L4.36-5.26H4.19C4.1-5.1 4.01-5.05 3.84-5.05C3.74-5.05 3.63-5.07 3.41-5.13C3.11-5.23 2.94-5.25 2.74-5.25C1.86-5.25 1.3-4.74 1.3-3.94C1.3-3.56 1.55-3.05 2.05-2.41C2.51-1.8 2.72-1.38 2.72-1.04C2.72-.49 2.36-.12 1.83-.12C1.17-.12 .81-.61 .62-1.74H.43L.19 .15H.38C.49-.05 .54-.1 .67-.1S1.01-.05 1.25 .01C1.52 .1 1.7 .13 1.91 .13C2.91 .13 3.62-.51 3.62-1.42Z'/>
<path id='eq1-g4-108' d='M7.94-3.01C7.94-4.25 7.15-5.15 7.04-5.25H6.65C6.73-5.11 7.02-4.54 7.02-3.69C7.02-2.3 6.11-.36 4.93-.36C4.49-.36 4.18-.61 4.18-1.04C4.18-2.23 4.82-3.35 4.82-3.62C4.82-3.67 4.8-3.69 4.75-3.69H4.18C3.81-3.69 4.1-.36 2.25-.36C1.41-.36 1.36-1.19 1.36-1.51C1.36-3.41 2.75-5 2.99-5.25H2.6C2.58-5.25 .27-3.69 .27-1.55C.27-.81 .67 .13 1.91 .13C3.37 .13 3.8-1.08 3.8-1.1H3.81C3.81-1.08 3.79-.99 3.79-.83C3.79-.46 3.94 .13 4.99 .13C6.5 .13 7.94-1.49 7.94-3.01Z'/>
<path id='eq1-g1-0' d='M6.84-2.73V-3.39H.74V-2.73H6.84Z'/>
</defs>
<g id='eq1-page1'>
<use x='0' y='0' xlink:href='#eq1-g1-0'/>
<use x='9.17' y='0' xlink:href='#eq1-g4-57'/>
<use x='13.93' y='0' xlink:href='#eq1-g4-66'/>
<use x='18.88' y='0' xlink:href='#eq1-g4-108'/>
</g>
</svg></span> shifts
  the image. Equivalent to interpolation with a sinc kernel. All input samples are used to compute
  all output samples. The boundary condition is ignored, as the Fourier transform imposes a periodic
  boundary condition.</p>
</li>
</ul>
<p>Not all methods are available for all functions. If so, this is described in the function&rsquo;s documentation.
For operations on binary images, the interpolation method is ignored, and <code>"nearest"</code> is always used.</p>
<p>Interpolation methods require a boundary extension of half the number of input samples used to compute
each output sample. For B-spline interpolation, a boundary extension of 5 is used. For the nearest neighbor
and Fourier interpolation methods, no boundary extension is needed.</p>
<aside class="m-note m-default">
<h4>Literature</h4>
<ul>
<li>R.G. Keys, &ldquo;Cubic Convolution Interpolation for Digital Image Processing&rdquo;, IEEE Transactions on
  Acoustics, Speech, and Signal Processing 29(6):1153-1160, 1981.</li>
</ul>
</aside>
        <section id="alias-members">
            <h2>Aliases</h2>
            <dl class="m-doc">
                              <dt id="dip-InterpolationFunctionPointer">
              using <a href="#dip-InterpolationFunctionPointer" class="m-doc-self">dip::<wbr />InterpolationFunctionPointer</a> = void(*)(Image, Image::Pixel, FloatArray)

            </dt>
            <dd>Pointer to an interpolation function. Only use pointers returned by <a href="geometry.html#dip-PrepareResampleAtUnchecked-Image-CL-String-CL"><code>dip::PrepareResampleAtUnchecked</code></a>.</dd>
            </dl>
        </section>
        <section id="function-members">
          <h2>Functions</h2>
          <dl class="m-doc">
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Wrap-Image-CL-Image-L-IntegerArray-" class="m-doc">dip::<wbr />Wrap</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> wrap)</span>
            </dt>
            <dd>Shifts the input image by an integer number of pixels, wrapping the pixels around. <a href="#dip-Wrap-Image-CL-Image-L-IntegerArray-">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Subsampling-Image-CL-Image-L-UnsignedArray-CL" class="m-doc">dip::<wbr />Subsampling</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sample)</span>
            </dt>
            <dd>Subsamples the input image. <a href="#dip-Subsampling-Image-CL-Image-L-UnsignedArray-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Resampling-Image-CL-Image-L-FloatArray--FloatArray--String-CL-StringArray-CL" class="m-doc">dip::<wbr />Resampling</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> zoom,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> shift = {0.0},
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",
              <a href="supporttypes.html#dip-StringArray" class="m-doc">dip::StringArray</a> const&amp; boundaryCondition = {})</span>
            </dt>
            <dd>Resamples an image with the given zoom factor and sub-pixel shift. <a href="#dip-Resampling-Image-CL-Image-L-FloatArray--FloatArray--String-CL-StringArray-CL">more...</a></dd>
                          <dt id="dip-Shift-Image-CL-Image-L-FloatArray-CL-String-CL-StringArray-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Shift-Image-CL-Image-L-FloatArray-CL-String-CL-StringArray-CL" class="m-doc-self">dip::<wbr />Shift</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; shift,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::FOURIER,
              <a href="supporttypes.html#dip-StringArray" class="m-doc">dip::StringArray</a> const&amp; boundaryCondition = {})</span>
            </dt>
            <dd>Shift an image. Calls <a href="#dip-Resampling-Image-CL-Image-L-FloatArray--FloatArray--String-CL-BoundaryConditionArray-CL"><code>dip::Resampling</code></a> with <code>zoom</code> set to 1, and uses the &ldquo;ft&rdquo; method by default.</dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-ShiftFT-Image-CL-Image-L-FloatArray-" class="m-doc">dip::<wbr />ShiftFT</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> shift = {0.0})</span>
            </dt>
            <dd>Modulates the input Fourier spectrum to introduce a shift in the spatial domain <a href="#dip-ShiftFT-Image-CL-Image-L-FloatArray-">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-ResampleAt-Image-CL-Image-L-FloatCoordinateArray-CL-String-CL-Image-Pixel-CL" class="m-doc">dip::<wbr />ResampleAt</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatCoordinateArray" class="m-doc">dip::FloatCoordinateArray</a> const&amp; coordinates,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR,
              <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; fill = {0})</span>
            </dt>
            <dd>Finds the values of the image at sub-pixel locations <code>coordinates</code> by interpolation. <a href="#dip-ResampleAt-Image-CL-Image-L-FloatCoordinateArray-CL-String-CL-Image-Pixel-CL">more...</a></dd>
                          <dt id="dip-ResampleAt-Image-CL-FloatArray-CL-String-CL-Image-Pixel-CL">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-ResampleAt-Image-CL-FloatArray-CL-String-CL-Image-Pixel-CL" class="m-doc-self">dip::<wbr />ResampleAt</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; coordinates,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR,
              <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; fill = {0}) -&gt; <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a></span>
            </dt>
            <dd>Identical to the previous function with the same name, but for a single point.</dd>
                          <dt id="dip-PrepareResampleAtUnchecked-Image-CL-String-CL">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-PrepareResampleAtUnchecked-Image-CL-String-CL" class="m-doc-self">dip::<wbr />PrepareResampleAtUnchecked</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod) -&gt; <a href="geometry.html#dip-InterpolationFunctionPointer" class="m-doc">dip::InterpolationFunctionPointer</a></span>
            </dt>
            <dd>Prepare for repeated calls to <a href="geometry.html#dip-ResampleAtUnchecked-Image-CL-FloatArray-CL-InterpolationFunctionPointer-"><code>dip::ResampleAtUnchecked</code></a>. See <a href="geometry.html#dip-ResampleAt-Image-CL-Image-L-FloatCoordinateArray-CL-String-CL-Image-Pixel-CL"><code>dip::ResampleAt</code></a>.</dd>
                          <dt id="dip-ResampleAtUnchecked-Image-CL-FloatArray-CL-InterpolationFunctionPointer-">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-ResampleAtUnchecked-Image-CL-FloatArray-CL-InterpolationFunctionPointer-" class="m-doc-self">dip::<wbr />ResampleAtUnchecked</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; coordinates,
              <a href="geometry.html#dip-InterpolationFunctionPointer" class="m-doc">dip::InterpolationFunctionPointer</a> function) -&gt; <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a></span>
            </dt>
            <dd>Similar to <a href="geometry.html#dip-ResampleAt-Image-CL-Image-L-FloatCoordinateArray-CL-String-CL-Image-Pixel-CL"><code>dip::ResampleAt</code></a>, but optimized for repeated calls using the same parameters.
<code>function</code> comes from <code>PrepareResampleAtUnchecked</code>. <code>fill</code> is always 0.</dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-ResampleAt-Image-CL-Image-CL-Image-L-String-CL-Image-Pixel-CL" class="m-doc">dip::<wbr />ResampleAt</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; map,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR,
              <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; fill = {0})</span>
            </dt>
            <dd>Resamples an image with sub-pixel locations specified by a coordinate map. <a href="#dip-ResampleAt-Image-CL-Image-CL-Image-L-String-CL-Image-Pixel-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Skew-Image-CL-Image-L-FloatArray-CL-dip-uint--String-CL-StringArray-CL" class="m-doc">dip::<wbr />Skew</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; shearArray,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",
              <a href="supporttypes.html#dip-StringArray" class="m-doc">dip::StringArray</a> const&amp; boundaryCondition = {})</span>
            </dt>
            <dd>Skews (shears) an image <a href="#dip-Skew-Image-CL-Image-L-FloatArray-CL-dip-uint--String-CL-StringArray-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Skew-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL" class="m-doc">dip::<wbr />Skew</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> shear,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> skew,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = {})</span>
            </dt>
            <dd>Skews (shears) an image <a href="#dip-Skew-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Rotation-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL" class="m-doc">dip::<wbr />Rotation</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension1,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension2,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS)</span>
            </dt>
            <dd>Rotates an image in one orthogonal plane, over the center of the image. <a href="#dip-Rotation-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Rotation2D-Image-CL-Image-L-dfloat--String-CL-String-CL" class="m-doc">dip::<wbr />Rotation2D</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS)</span>
            </dt>
            <dd>Rotates a 2D image <a href="#dip-Rotation2D-Image-CL-Image-L-dfloat--String-CL-String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Rotation3D-Image-CL-Image-L-dfloat--dip-uint--String-CL-String-CL" class="m-doc">dip::<wbr />Rotation3D</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis = 2,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS)</span>
            </dt>
            <dd>Rotates a 3D image in one orthogonal plane <a href="#dip-Rotation3D-Image-CL-Image-L-dfloat--dip-uint--String-CL-String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Rotation3D-Image-CL-Image-L-dfloat--dfloat--dfloat--String-CL-String-CL" class="m-doc">dip::<wbr />Rotation3D</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> alpha,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> beta,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> gamma,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS)</span>
            </dt>
            <dd>Applies an arbitrary 3D rotation to a 3D image <a href="#dip-Rotation3D-Image-CL-Image-L-dfloat--dfloat--dfloat--String-CL-String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-RotationMatrix2D-Image-L-dfloat-" class="m-doc">dip::<wbr />RotationMatrix2D</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle)</span>
            </dt>
            <dd>Creates a 0D (one pixel) 2x2 matrix image containing a 2D rotation matrix. <a href="#dip-RotationMatrix2D-Image-L-dfloat-">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-RotationMatrix3D-Image-L-dfloat--dfloat--dfloat-" class="m-doc">dip::<wbr />RotationMatrix3D</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> alpha,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> beta,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> gamma)</span>
            </dt>
            <dd>Creates a 0D (one pixel) 3x3 matrix image containing a 3D rotation matrix. <a href="#dip-RotationMatrix3D-Image-L-dfloat--dfloat--dfloat-">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-RotationMatrix3D-Image-L-FloatArray-CL-dfloat-" class="m-doc">dip::<wbr />RotationMatrix3D</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; vector,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle)</span>
            </dt>
            <dd>Creates a 0D (one pixel) 3x3 matrix image containing a 3D rotation matrix. <a href="#dip-RotationMatrix3D-Image-L-FloatArray-CL-dfloat-">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-AffineTransform-Image-CL-Image-L-FloatArray-CL-String-CL" class="m-doc">dip::<wbr />AffineTransform</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; matrix,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR)</span>
            </dt>
            <dd>Applies an arbitrary affine transformation to the 2D or 3D image. <a href="#dip-AffineTransform-Image-CL-Image-L-FloatArray-CL-String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-WarpControlPoints-Image-CL-Image-L-FloatCoordinateArray-CL-FloatCoordinateArray-CL-dfloat--String-CL" class="m-doc">dip::<wbr />WarpControlPoints</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-FloatCoordinateArray" class="m-doc">dip::FloatCoordinateArray</a> const&amp; inCoordinates,
              <a href="supporttypes.html#dip-FloatCoordinateArray" class="m-doc">dip::FloatCoordinateArray</a> const&amp; outCoordinates,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> lambda = 0,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR)</span>
            </dt>
            <dd>Warps an image based on a set of control points using thin plate spline interpolation <a href="#dip-WarpControlPoints-Image-CL-Image-L-FloatCoordinateArray-CL-FloatCoordinateArray-CL-dfloat--String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-LogPolarTransform2D-Image-CL-Image-L-String-CL" class="m-doc">dip::<wbr />LogPolarTransform2D</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR)</span>
            </dt>
            <dd>Computes the log-polar transform of the 2D image. <a href="#dip-LogPolarTransform2D-Image-CL-Image-L-String-CL">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Tile-ImageConstRefArray-CL-Image-L-UnsignedArray-" class="m-doc">dip::<wbr />Tile</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> tiling = {})</span>
            </dt>
            <dd>Tiles a set of images to form a single image. <a href="#dip-Tile-ImageConstRefArray-CL-Image-L-UnsignedArray-">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-TileTensorElements-Image-CL-Image-L" class="m-doc">dip::<wbr />TileTensorElements</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Tiles the tensor elements of <code>in</code> to produce a scalar image <a href="#dip-TileTensorElements-Image-CL-Image-L">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Concatenate-ImageConstRefArray-CL-Image-L-dip-uint-" class="m-doc">dip::<wbr />Concatenate</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension = 0)</span>
            </dt>
            <dd>Concatenates a set of images along one dimension. <a href="#dip-Concatenate-ImageConstRefArray-CL-Image-L-dip-uint-">more...</a></dd>
                          <dt id="dip-Concatenate-Image-CL-Image-CL-Image-L-dip-uint-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Concatenate-Image-CL-Image-CL-Image-L-dip-uint-" class="m-doc-self">dip::<wbr />Concatenate</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in1,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in2,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension = 0)</span>
            </dt>
            <dd>Concatenates two images.</dd>
                          <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-JoinChannels-ImageConstRefArray-CL-Image-L" class="m-doc">dip::<wbr />JoinChannels</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Concatenates a set of scalar images along the tensor dimension. <a href="#dip-JoinChannels-ImageConstRefArray-CL-Image-L">more...</a></dd>
                          <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-SplitChannels-Image-CL" class="m-doc">dip::<wbr />SplitChannels</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in) -&gt; <a href="dip-Image.html#dip-ImageArray" class="m-doc">dip::ImageArray</a></span>
            </dt>
            <dd>Splits the tensor elements of a tensor image into individual images. <a href="#dip-SplitChannels-Image-CL">more...</a></dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
                        <section class="m-doc-details" id="dip-Wrap-Image-CL-Image-L-IntegerArray-"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Wrap-Image-CL-Image-L-IntegerArray-" class="m-doc-self">dip::<wbr />Wrap</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> wrap</span>)            </h3>
            <p>Shifts the input image by an integer number of pixels, wrapping the pixels around.</p>
<p><code>dip::Wrap</code> is equivalent to <a href="geometry.html#dip-Shift-Image-CL-Image-L-FloatArray-CL-String-CL-StringArray-CL"><code>dip::Shift</code></a> with nearest neighbor interpolation and periodic
boundary condition, but faster.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-Subsampling-Image-CL-Image-L-UnsignedArray-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Subsampling-Image-CL-Image-L-UnsignedArray-CL" class="m-doc-self">dip::<wbr />Subsampling</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sample</span>)            </h3>
            <p>Subsamples the input image.</p>
<p>The input image is subsampled by <code>sample[ ii ]</code> along dimension <code>ii</code>. The output image shares
the data segment of the input image, meaning that no data are copied. If a data copy is required,
calling <a href="dip-Image.html#dip-Image-ForceContiguousData"><code>dip::Image::ForceContiguousData</code></a> after subsampling should trigger a data copy.</p>
<p>If <code>out</code> has an external interface different from that of <code>in</code>, the data will be copied.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-Resampling-Image-CL-Image-L-FloatArray--FloatArray--String-CL-StringArray-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Resampling-Image-CL-Image-L-FloatArray--FloatArray--String-CL-StringArray-CL" class="m-doc-self">dip::<wbr />Resampling</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> zoom,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> shift = {0.0},</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",</span><span class="m-doc-arg"><a href="supporttypes.html#dip-StringArray" class="m-doc">dip::StringArray</a> const&amp; boundaryCondition = {}</span>)            </h3>
            <p>Resamples an image with the given zoom factor and sub-pixel shift.</p>
<p>The shift is applied first, and causes part of the image to shift out of the field of view.
Thus, <code>shift</code> is in input pixels. <code>boundaryCondition</code> determines how the new areas are filled in.
See <a href="boundary.html#dip-BoundaryCondition"><code>dip::BoundaryCondition</code></a>. Note that the shift can be in fractional pixels. There is no largest
possible shift, but applying very large shifts is not optimized for, and will use more computation
and temporary memory than necessary. This is true even for the periodic boundary condition; use
<a href="geometry.html#dip-Wrap-Image-CL-Image-L-IntegerArray-"><code>dip::Wrap</code></a> to apply the integer shift with periodic boundary condition, then use <code>Resampling</code> for
the remaining sub-pixel shift. The exception is the <code>"ft"</code> interpolation method, which uses the same
memory and time for large as for small shifts.</p>
<p>The scaling is applied next. If <code>zoom</code> is larger than 1, the output image will be larger than
the input, if it is smaller than 1, it will be smaller. The output image has size
<code>std::floor( in.Sizes( ii ) * zoom[ ii ] )</code> along dimension <code>ii</code>. For the <code>"ft"</code> method, the zoom
factor is back-computed from this output image size, whereas for the other methods the <code>zoom</code> is used
as given. This stems from the very different approach to interpolation.</p>
<p>The pixel at coordinates <code>pos</code> in the output image is interpolated from the position
<code>pos[ ii ] / zoom[ ii ] - shift[ ii ]</code> along dimension <code>ii</code>. Thus, with <code>zoom</code> smaller
than 1, no low-pass filtering is applied first. Again, the <code>"ft"</code> interpolation method is different:
the output image is generated by inverse Fourier transform from the manipulated frequency spectrum
of the input image. The <code>"ft"</code> method thus has low-pass filtering built-in when zooming out.</p>
<p>The output image has the same data type as the input image.</p>
<p>See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for information on the <code>interpolationMethod</code> parameter.</p>
<aside class="m-note m-danger">
<h4>Bug</h4>
<p>The current implementation doesn&rsquo;t handle the <code>"asym"</code> boundary conditions properly.
For unsigned types, resulting samples outside the original image domain are clamped to 0, instead
of properly using the saturated inversion.</p>
</aside>
          </div></section>
                        <section class="m-doc-details" id="dip-ShiftFT-Image-CL-Image-L-FloatArray-"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-ShiftFT-Image-CL-Image-L-FloatArray-" class="m-doc-self">dip::<wbr />ShiftFT</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> shift = {0.0}</span>)            </h3>
            <p>Modulates the input Fourier spectrum to introduce a shift in the spatial domain</p>
<p><code>in</code> is the Fourier transform of an image <code>img</code>. It will be multiplied with a complex quantity
to change its phase in such a way that the image <code>img</code> will be shifted. For example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">ImageReadICS</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;trui&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">ft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">FourierTransform</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">ShiftFT</span><span class="p">(</span><span class="w"> </span><span class="n">ft</span><span class="p">,</span><span class="w"> </span><span class="n">ft</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">10.3</span><span class="p">,</span><span class="w"> </span><span class="mf">-5.2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">shifted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">FourierTransform</span><span class="p">(</span><span class="w"> </span><span class="n">ft</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;inverse&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;real&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Produces the same output as:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">ImageReadICS</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;trui&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">shifted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Shift</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">10.3</span><span class="p">,</span><span class="w"> </span><span class="mf">-5.2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="s">&quot;fourier&quot;</span><span class="w"> </span><span class="p">);</span>
</pre></div>
          </div></section>
                        <section class="m-doc-details" id="dip-ResampleAt-Image-CL-Image-L-FloatCoordinateArray-CL-String-CL-Image-Pixel-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-ResampleAt-Image-CL-Image-L-FloatCoordinateArray-CL-String-CL-Image-Pixel-CL" class="m-doc-self">dip::<wbr />ResampleAt</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatCoordinateArray" class="m-doc">dip::FloatCoordinateArray</a> const&amp; coordinates,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR,</span><span class="m-doc-arg"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; fill = {0}</span>)            </h3>
            <p>Finds the values of the image at sub-pixel locations <code>coordinates</code> by interpolation.</p>
<p>The array <code>coordinates</code> must have all elements be arrays of the same length as the image dimensionality.
For any coordinates outside of the image domain, the pixel value <code>fill</code> will be returned.
That is, no extrapolation is performed.
Coordinates match image indexing: the first pixel on a line has coordinate 0.</p>
<p><code>interpolationMethod</code> has a restricted set of options: <code>"linear"</code>, <code>"3-cubic"</code>, or <code>"nearest"</code>.
See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for their definition. If <code>in</code> is binary, <code>interpolationMethod</code> will be
ignored, nearest neighbor interpolation will be used.</p>
<p><code>out</code> will be a 1D image with the same size as the <code>coordinates</code> array, and the same data type and tensor
shape as <code>in</code>. To obtain results in a floating-point type, set the data type of <code>out</code> and protect it,
see <a href="dip-Image.html#protect">The &ldquo;protect&rdquo; flag</a>.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-ResampleAt-Image-CL-Image-CL-Image-L-String-CL-Image-Pixel-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-ResampleAt-Image-CL-Image-CL-Image-L-String-CL-Image-Pixel-CL" class="m-doc-self">dip::<wbr />ResampleAt</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; map,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR,</span><span class="m-doc-arg"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; fill = {0}</span>)            </h3>
            <p>Resamples an image with sub-pixel locations specified by a coordinate map.</p>
<p>Returns an image of the same size as <code>map</code> with pixels taken from <code>in</code> at the subpixel coordinates
specified by <code>map</code>. Each tensor element of <code>map</code> specifies the location for an input dimension.
As such, it must have a number of tensor elements equal to <code>in</code>&rsquo;s dimensionality, and real-valued samples.
For any coordinates outside of the image domain, the pixel value <code>fill</code> will be returned.
That is, no extrapolation is performed.
Coordinates match image indexing: the first pixel on a line has coordinate 0.</p>
<p><code>interpolationMethod</code> has a restricted set of options: <code>"linear"</code>, <code>"3-cubic"</code>, or <code>"nearest"</code>.
See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for their definition. If <code>in</code> is binary, <code>interpolationMethod</code> will be
ignored, nearest neighbor interpolation will be used.</p>
<p><code>out</code> will have the same size as <code>map</code>, and the same data type and tensor shape as <code>in</code>. If <code>out</code> is protected,
its data type will not change, but the computations will still be performed in the data type of <code>in</code>.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-Skew-Image-CL-Image-L-FloatArray-CL-dip-uint--String-CL-StringArray-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Skew-Image-CL-Image-L-FloatArray-CL-dip-uint--String-CL-StringArray-CL" class="m-doc-self">dip::<wbr />Skew</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; shearArray,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",</span><span class="m-doc-arg"><a href="supporttypes.html#dip-StringArray" class="m-doc">dip::StringArray</a> const&amp; boundaryCondition = {}</span>)            </h3>
            <p>Skews (shears) an image</p>
<p>The image is skewed such that a straight line along dimension <code>axis</code> is tilted by an angle of
<code>atan( shearArray[ ii ] )</code> radian in the direction of dimension <code>ii</code>. <code>shearArray[ ii ]</code> thus represents
the sub-pixel shift of a line in the direction <code>ii</code> with respect to the previous line along <code>axis</code>.
Each image sub-volume perpendicular
to <code>axis</code> is shifted by a different amount. The output image has the same dimension as <code>in</code> in the <code>axis</code>
direction, and larger dimensions in all other dimensions, such that no data are lost. The value of <code>shearArray[ axis ]</code>
is ignored. The origin of the skew is the central pixel (see <a href="concepts.html#coordinates_origin">Coordinate system origin</a>).</p>
<p>The output image has the same data type as the input image.</p>
<p>See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for information on the <code>interpolationMethod</code> parameter.</p>
<p><code>boundaryCondition</code> determines how data outside of the input image domain are filled in. See
<a href="boundary.html#dip-BoundaryCondition"><code>dip::BoundaryCondition</code></a>. If it is <code>"periodic"</code>, a periodic skew is applied. This means that
image lines are shifted using a periodic boundary condition, and wrap around. The
output image does not grow along dimension <code>skew</code>.</p>
<aside class="m-note m-danger">
<h4>Bug</h4>
<p>The current implementation doesn&rsquo;t handle the <code>"asym"</code> boundary conditions properly.
For unsigned types, resulting samples outside the original image domain are clamped to 0,
instead of properly using the saturated inversion.</p>
</aside>
<aside class="m-note m-warning">
<h4>Warning</h4>
<p>The <code>"ft"</code> interpolation method is not (yet?) supported.</p>
</aside>
          </div></section>
                        <section class="m-doc-details" id="dip-Skew-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Skew-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL" class="m-doc-self">dip::<wbr />Skew</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> shear,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> skew,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = {}</span>)            </h3>
            <p>Skews (shears) an image</p>
<p>The image is skewed such that a straight line along dimension <code>axis</code> is tilted by an
angle of <code>shear</code> radian in the direction of dimension <code>skew</code>. Each image line along dimension
<code>skew</code> is shifted by a different amount. The output image has the same dimensions as
<code>in</code>, except for dimension <code>skew</code>, which will be larger, such that no data are lost.
The origin of the skew is the central pixel (see <a href="concepts.html#coordinates_origin">Coordinate system origin</a>).</p>
<p>The output image has the same data type as the input image.</p>
<p><code>shear</code> must have a magnitude smaller than &pi;/2. Note that the definition of <code>shear</code> is different
from that of <code>shearArray</code> in the other version of <a href="#dip-Skew-Image-CL-Image-L-FloatArray-CL-dip-uint--dip-uint--String-CL-BoundaryConditionArray-"><code>dip::Skew</code></a>, documented above.</p>
<p>See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for information on the <code>interpolationMethod</code> parameter.</p>
<p><code>boundaryCondition</code> determines how data outside of the input image domain are filled in. See
<a href="boundary.html#dip-BoundaryCondition"><code>dip::BoundaryCondition</code></a>. If it is <code>"periodic"</code>, a periodic skew is applied. This means that
image lines are shifted using a periodic boundary condition, and wrap around. The
output image does not grow along dimension <code>skew</code>.</p>
<aside class="m-note m-danger">
<h4>Bug</h4>
<p>The current implementation doesn&rsquo;t handle the <code>"asym"</code> boundary conditions properly.
For unsigned types, resulting samples outside the original image domain are clamped to 0,
instead of properly using the saturated inversion.</p>
</aside>
<aside class="m-note m-warning">
<h4>Warning</h4>
<p>The <code>"ft"</code> interpolation method is not (yet?) supported.</p>
</aside>
          </div></section>
                        <section class="m-doc-details" id="dip-Rotation-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Rotation-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL" class="m-doc-self">dip::<wbr />Rotation</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension1,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension2,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS</span>)            </h3>
            <p>Rotates an image in one orthogonal plane, over the center of the image.</p>
<p>Rotates an image in the plane defined by <code>dimension1</code> and <code>dimension2</code>, over an angle <code>angle</code>, in radian.
The origin of the rotation is the central pixel (see <a href="concepts.html#coordinates_origin">Coordinate system origin</a>).</p>
<aside class="m-note m-info">
<h4>Attention</h4>
<p>The function implements the rotation in the mathematical sense, but the y-axis is positive downwards.
Therefore, positive angles are clock-wise.</p>
</aside>
<p>The output image has the same data type as the input image.</p>
<p>The rotation is computed by three consecutive calls to <a href="#dip-Skew-Image-CL-Image-L-FloatArray-CL-dip-uint--dip-uint--String-CL-BoundaryConditionArray-"><code>dip::Skew</code></a>. See that function for the meaning of
<code>interpolationMethod</code> and <code>boundaryCondition</code>.</p>
<aside class="m-note m-primary">
<h4>Note</h4>
<p>The <code>"periodic"</code> boundary condition currently produces an output image of the same size as
the input, where the corners of the image that rotate out of the field of view are cut off and fill the
sections that were outside of the input field of view. This is due to the way that <a href="#dip-Skew-Image-CL-Image-L-FloatArray-CL-dip-uint--dip-uint--String-CL-BoundaryConditionArray-"><code>dip::Skew</code></a> handles
the <code>"periodic"</code> boundary condition.</p>
</aside>
<aside class="m-note m-warning">
<h4>Warning</h4>
<p>The <code>"ft"</code> interpolation method is not (yet?) supported.</p>
</aside>
          </div></section>
                        <section class="m-doc-details" id="dip-Rotation2D-Image-CL-Image-L-dfloat--String-CL-String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Rotation2D-Image-CL-Image-L-dfloat--String-CL-String-CL" class="m-doc-self">dip::<wbr />Rotation2D</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS</span>)            </h3>
            <p>Rotates a 2D image</p>
<p>Calls <a href="geometry.html#dip-Rotation-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL"><code>dip::Rotation</code></a>, setting the dimension parameters to 0 and 1. Provides a simplified
interface for 2D images.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-Rotation3D-Image-CL-Image-L-dfloat--dip-uint--String-CL-String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Rotation3D-Image-CL-Image-L-dfloat--dip-uint--String-CL-String-CL" class="m-doc-self">dip::<wbr />Rotation3D</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis = 2,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS</span>)            </h3>
            <p>Rotates a 3D image in one orthogonal plane</p>
<p>Calls <a href="geometry.html#dip-Rotation-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL"><code>dip::Rotation</code></a>, setting the dimension parameters according to <code>axis</code>. Provides a simplified
interface for 3D images.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-Rotation3D-Image-CL-Image-L-dfloat--dfloat--dfloat--String-CL-String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Rotation3D-Image-CL-Image-L-dfloat--dfloat--dfloat--String-CL-String-CL" class="m-doc-self">dip::<wbr />Rotation3D</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> alpha,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> beta,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> gamma,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = "",</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; boundaryCondition = S::ADD_ZEROS</span>)            </h3>
            <p>Applies an arbitrary 3D rotation to a 3D image</p>
<p>Rotates a 3D image over the Euler angles <code>alpha</code>, <code>beta</code> and <code>gamma</code>, by calling <a href="geometry.html#dip-Rotation-Image-CL-Image-L-dfloat--dip-uint--dip-uint--String-CL-String-CL"><code>dip::Rotation</code></a>
three times (i.e. using nine skews).
The first rotation is over <code>alpha</code> radian around the initial z-axis. The second rotation is over <code>beta</code> radian
around the intermediate y-axis. The last rotation is over <code>gamma</code> radian around the final z-axis.</p>
<aside class="m-note m-info">
<h4>Attention</h4>
<p>The function implements the rotation in the mathematical sense, but the y-axis is positive downwards.
Therefore, positive angles are clock-wise.</p>
</aside>
<p>The rotation is over the center of the image, see <a href="concepts.html#coordinates_origin">Coordinate system origin</a>.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-RotationMatrix2D-Image-L-dfloat-"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-RotationMatrix2D-Image-L-dfloat-" class="m-doc-self">dip::<wbr />RotationMatrix2D</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle</span>)            </h3>
            <p>Creates a 0D (one pixel) 2x2 matrix image containing a 2D rotation matrix.</p>
<p>Multiplying the output of <a href="generation_coordinates.html#dip-CreateCoordinates-Image-L-UnsignedArray-CL-StringSet-CL-String-CL"><code>dip::CreateCoordinates</code></a> by this rotation matrix will produce
an image with a rotated coordinate system. The rotation matrix must be on the left-hand-side
of the multiplication operator.</p>
<p>The rotation is over <code>angle</code> radian. Note that when transforming a coordinate system
(a passive transformation), then the transpose of the matrix must be used.</p>
<p><code>out</code> is of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a> by default.</p>
<p>Example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">CreateCoordinates</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;frequency&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">rotatedCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">RotationMatrix2D</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">coords</span><span class="p">;</span>
</pre></div>
          </div></section>
                        <section class="m-doc-details" id="dip-RotationMatrix3D-Image-L-dfloat--dfloat--dfloat-"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-RotationMatrix3D-Image-L-dfloat--dfloat--dfloat-" class="m-doc-self">dip::<wbr />RotationMatrix3D</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> alpha,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> beta,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> gamma</span>)            </h3>
            <p>Creates a 0D (one pixel) 3x3 matrix image containing a 3D rotation matrix.</p>
<p>Multiplying the output of <a href="generation_coordinates.html#dip-CreateCoordinates-Image-L-UnsignedArray-CL-StringSet-CL-String-CL"><code>dip::CreateCoordinates</code></a> by this rotation matrix will produce
an image with a rotated coordinate system. The rotation matrix must be on the left-hand-side
of the multiplication operator.</p>
<p>The rotation is over the Euler angles <code>alpha</code>, <code>beta</code> and <code>gamma</code>: the first rotation is over <code>alpha</code>
radian around the initial z-axis. The second rotation is over <code>beta</code> radian around the intermediate
y-axis. The last rotation is over <code>gamma</code> radian around the final z-axis. Note that when transforming
a coordinate system (a passive transformation), then the transpose of the matrix must be used.</p>
<p><code>out</code> is of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a> by default.</p>
<p>Example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">CreateCoordinates</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">rotatedCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">RotationMatrix3D</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">pi</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">coords</span><span class="p">;</span>
</pre></div>
          </div></section>
                        <section class="m-doc-details" id="dip-RotationMatrix3D-Image-L-FloatArray-CL-dfloat-"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-RotationMatrix3D-Image-L-FloatArray-CL-dfloat-" class="m-doc-self">dip::<wbr />RotationMatrix3D</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; vector,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> angle</span>)            </h3>
            <p>Creates a 0D (one pixel) 3x3 matrix image containing a 3D rotation matrix.</p>
<p>Multiplying the output of <a href="generation_coordinates.html#dip-CreateCoordinates-Image-L-UnsignedArray-CL-StringSet-CL-String-CL"><code>dip::CreateCoordinates</code></a> by this rotation matrix will produce
an image with a rotated coordinate system. The rotation matrix must be on the left-hand-side
of the multiplication operator.</p>
<p>The rotation is over <code>angle</code> radian about the axis defined by <code>vector</code>. That is, <code>vector</code> will
not be affected by the rotation. Note that when transforming a coordinate system (a passive
transformation), then the transpose of the matrix must be used.</p>
<p><code>out</code> is of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a> by default.</p>
<p>Example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">CreateCoordinates</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">rotatedCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">RotationMatrix3D</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">coords</span><span class="p">;</span>
</pre></div>
          </div></section>
                        <section class="m-doc-details" id="dip-AffineTransform-Image-CL-Image-L-FloatArray-CL-String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-AffineTransform-Image-CL-Image-L-FloatArray-CL-String-CL" class="m-doc-self">dip::<wbr />AffineTransform</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; matrix,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR</span>)            </h3>
            <p>Applies an arbitrary affine transformation to the 2D or 3D image.</p>
<p><code>matrix</code> contains 4 values (<code>in</code> is 2D) or 9 values (<code>in</code> is 3D) representing a linear
transformation matrix. Optionally, a translation can be represented by 2 (2D) or 3 (3D)
values added to the end of <code>matrix</code>. In this case, the matrix is an affine transform
matrix using homogeneous coordinates, but with the bottom row removed (which is expected
to be <code>{0,0,1}</code> in 2D or <code>{0,0,0,1}</code> in 3D). The values are stored in column-major order:</p>
<div class="m-code"><pre><span></span>       ⎡ matrix[0]  matrix[2]  matrix[4] ⎤
T_2D = ⎢ matrix[1]  matrix[3]  matrix[5] ⎥
       ⎣    0          0          1      ⎦

       ⎡ matrix[0]  matrix[3]  matrix[6]  matrix[ 9] ⎤
T_3D = ⎢ matrix[1]  matrix[4]  matrix[7]  matrix[10] ⎥
       ⎢ matrix[2]  matrix[5]  matrix[8]  matrix[11] ⎥
       ⎣    0          0          0          1       ⎦
</pre></div>

<p>The coordinates of each pixel in <code>in</code> (the origin of the coordinate system is the central pixel,
see <a href="concepts.html#coordinates_origin">Coordinate system origin</a>) is mapped through the transformation matrix to obtain its location
in <code>out</code>. Although the algorithm actually uses the inverse of the matrix to transform
each coordinate in <code>out</code> to obtain the location where to interpolate a value from. <code>out</code> is given
the same size as <code>in</code>.</p>
<p><code>interpolationMethod</code> has a restricted set of options: <code>"linear"</code>, <code>"3-cubic"</code>, or <code>"nearest"</code>.
See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for their definition. If <code>in</code> is binary, <code>interpolationMethod</code> will be
ignored, nearest neighbor interpolation will be used.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-WarpControlPoints-Image-CL-Image-L-FloatCoordinateArray-CL-FloatCoordinateArray-CL-dfloat--String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-WarpControlPoints-Image-CL-Image-L-FloatCoordinateArray-CL-FloatCoordinateArray-CL-dfloat--String-CL" class="m-doc-self">dip::<wbr />WarpControlPoints</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatCoordinateArray" class="m-doc">dip::FloatCoordinateArray</a> const&amp; inCoordinates,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-FloatCoordinateArray" class="m-doc">dip::FloatCoordinateArray</a> const&amp; outCoordinates,</span><span class="m-doc-arg"><a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> lambda = 0,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR</span>)            </h3>
            <p>Warps an image based on a set of control points using thin plate spline interpolation</p>
<p><code>inCoordinates</code> and <code>outCoordinates</code> are two sets of points (they must be of equal size). The
point <code>inCoordinates[ ii ]</code> will be moved to <code>outCoordinates[ ii ]</code>, warping the image <code>in</code>
accordingly.</p>
<p><code>lambda</code> is the regularization parameter. By default it is zero, meaning that the control points
will be matched exactly in the input and output images. Increasing <code>lambda</code> allows some error in
the location of the control points, and will result in a smoother interpolation.</p>
<p><code>interpolationMethod</code> has a restricted set of options: <code>"linear"</code>, <code>"3-cubic"</code>, or <code>"nearest"</code>.
See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for their definition. If <code>in</code> is binary, <code>interpolationMethod</code> will be
ignored, nearest neighbor interpolation will be used.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-LogPolarTransform2D-Image-CL-Image-L-String-CL"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-LogPolarTransform2D-Image-CL-Image-L-String-CL" class="m-doc-self">dip::<wbr />LogPolarTransform2D</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; interpolationMethod = S::LINEAR</span>)            </h3>
            <p>Computes the log-polar transform of the 2D image.</p>
<p>By default, <code>out</code> will be a square image with side equal to the smaller of the two sides of <code>in</code>. However,
if <code>out</code> is protected (see <a href="dip-Image.html#dip-Image-Protect-bool-"><code>dip::Image::Protect</code></a>), its sizes will be preserved, even if not forged.</p>
<p>The x-axis (horizontal) of <code>out</code> is the logarithm of the radius, and the y-axis is the angle.</p>
<p><code>interpolationMethod</code> has a restricted set of options: <code>"linear"</code>, <code>"3-cubic"</code>, or <code>"nearest"</code>.
See <a href="geometry.html#interpolation_methods">Interpolation methods</a> for their definition. If <code>in</code> is binary, <code>interpolationMethod</code> will be
ignored, nearest neighbor interpolation will be used.</p>
<p>This function is an integral part of the Fourier-Mellin transform, see <a href="analysis.html#dip-FourierMellinMatch2D-Image-CL-Image-CL-Image-L-String-CL-String-CL"><code>dip::FourierMellinMatch2D</code></a>.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-Tile-ImageConstRefArray-CL-Image-L-UnsignedArray-"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Tile-ImageConstRefArray-CL-Image-L-UnsignedArray-" class="m-doc-self">dip::<wbr />Tile</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> tiling = {}</span>)            </h3>
            <p>Tiles a set of images to form a single image.</p>
<p>Input images are arranged according to <code>tiling</code>. For example, <code>tiling = { 3, 2 }</code> will generate an
output where three images are placed horizontally, and two vertically. In this case, up to 6 input images
can be given in <code>in</code>. If <code>in</code> has fewer images, the corresponding locations in <code>out</code> will be zero. If <code>in</code>
has 6 images, they will be placed as follows:</p>
<div class="m-code"><pre><span></span>| in[0], in[1], in[2] |
| in[3], in[4], in[5] |
</pre></div>

<p>That is, images are tiled row-wise, from left to right and then top to bottom. <code>tiling</code> can have any number
of elements, it is for example possible to tile 2D images along the 4<sup>th</sup> dimension.</p>
<p>If <code>tiling</code> is an empty array (the default), then <code>ceil(sqrt(in.size()))</code> images will be placed horizontally,
in however many rows are necessary to fit all images.</p>
<p>The input images must all have the same sizes, with the exception for the case where all images are tiled
along a single dimension, in which case their sizes can differ along that dimension (see <a href="geometry.html#dip-Concatenate-ImageConstRefArray-CL-Image-L-dip-uint-"><code>dip::Concatenate</code></a>)</p>
<p>The input images must all have the same number of tensor elements. If their tensor representations do not
match, the output image will be a default column vector. If images are differing data types, the output will
be of a type that best can represent the input (see <a href="dip-DataType.html#dip-DataType-SuggestDyadicOperation-DataType--DataType-"><code>dip::DataType::SuggestDyadicOperation</code></a>).</p>
          </div></section>
                        <section class="m-doc-details" id="dip-TileTensorElements-Image-CL-Image-L"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-TileTensorElements-Image-CL-Image-L" class="m-doc-self">dip::<wbr />TileTensorElements</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out</span>)            </h3>
            <p>Tiles the tensor elements of <code>in</code> to produce a scalar image</p>
<p>The tensor elements of <code>in</code> are arranged according to its tensor representation, along the first two
spatial dimensions. This produces a scalar image of size <code>in.Size(0) * in.TensorColumns()</code> along the
horizontal dimension, and size <code>in.Size(1) * in.TensorRows()</code> along the vertical dimension. The output
image has the same dimensions as <code>in</code> along the third and further dimensions.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-Concatenate-ImageConstRefArray-CL-Image-L-dip-uint-"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-Concatenate-ImageConstRefArray-CL-Image-L-dip-uint-" class="m-doc-self">dip::<wbr />Concatenate</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,</span><span class="m-doc-arg"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension = 0</span>)            </h3>
            <p>Concatenates a set of images along one dimension.</p>
<p>Input images are concatenated along dimension <code>dimension</code>. They must all have the same sizes along all
dimensions except <code>dimension</code>, where they can differ.</p>
<p>The input images must all have the same number of tensor elements. If their tensor representations do not
match, the output image will be a default column vector. If images are differing data types, the output will
be of a type that best can represent the input (see <a href="dip-DataType.html#dip-DataType-SuggestDyadicOperation-DataType--DataType-"><code>dip::DataType::SuggestDyadicOperation</code></a>).</p>
          </div></section>
                        <section class="m-doc-details" id="dip-JoinChannels-ImageConstRefArray-CL-Image-L"><div>
            <h3>
              <span class="m-doc-return">void</span>
              <span class="m-doc-name"><a href="#dip-JoinChannels-ImageConstRefArray-CL-Image-L" class="m-doc-self">dip::<wbr />JoinChannels</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; in,</span><span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out</span>)            </h3>
            <p>Concatenates a set of scalar images along the tensor dimension.</p>
<p>Input images are individual tensor components in the output vector image. They must all have the same sizes
and be scalar.</p>
<p>If images are differing data types, the output will be of a type that best can represent the input
(see <a href="dip-DataType.html#dip-DataType-SuggestDyadicOperation-DataType--DataType-"><code>dip::DataType::SuggestDyadicOperation</code></a>). <code>out</code> will be a vector image with <code>in.size()</code> samples per pixel.</p>
          </div></section>
                        <section class="m-doc-details" id="dip-SplitChannels-Image-CL"><div>
            <h3>
              <span class="m-doc-return"><a href="dip-Image.html#dip-ImageArray" class="m-doc">dip::ImageArray</a></span>
              <span class="m-doc-name"><a href="#dip-SplitChannels-Image-CL" class="m-doc-self">dip::<wbr />SplitChannels</a></span>(
<span class="m-doc-arg"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in</span>)            </h3>
            <p>Splits the tensor elements of a tensor image into individual images.</p>
<p>The output array contains images that each point to the data in <code>in</code>.</p>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form action="https://diplib.org/diplib-docs/#search">
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:diplib.org+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or modules.
              You can omit any prefix from the symbol or file path; adding a <code>:</code> or
              <code>/</code> suffix lists all members of given symbol or directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span> / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
              <span class="m-label m-dim">Enter</span> to go.
              <span class="m-label m-dim">Tab</span> autocompletes common prefix.
              You can copy a link to the result using <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">L</span>,
              or <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">M</span> to copy a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:diplib.org+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>DIPlib, a library for quantitative image analysis. Documentation compiled with <a href="https://crisluengo.github.io/doxpp/">dox++</a> and styled with <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>