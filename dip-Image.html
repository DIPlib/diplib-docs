<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>dip::Image class | DIPlib | a library for quantitative image analysis</title>
  <link rel="stylesheet" href="m-dip+documentation.compiled.css" />
  <link rel="icon" href="DIPlib_logo_32.png" type="image/png" />
  <link rel="search" type="application/opensearchdescription+xml" href="opensearch.xml" title="Search DIPlib documentation" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#ffffff" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://diplib.org"><img src="DIPlib_logo.svg" alt="" />DIPlib</a><span class="m-breadcrumb">┃</span><a href="index.html" class="m-thin">a library for quantitative image analysis</a><span class="m-breadcrumb">┃</span><a href="https://github.com/DIPlib/diplib/releases/tag/3.5.0" class="m-thin">version 3.5.0</a>      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="classes.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <div class="m-doc-include m-right-m m-text-right">
<span class="m-thin"><a href="imagetype.html" class="m-doc">Image</a> module</span><br/><span class="m-code m-inverted"><span class="cp">#include</span> <a class="cpf" href="file--diplib-h.html">"diplib.h"</a></span>          </div>

          <span class="m-breadcrumb"><a href="dip.html">dip</a>::<wbr/></span>Image <span class="m-thin">class</span>        </h1>
        <p>Represents an image with all associated information.</p>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#image_representation">Image representation</a></li>
            <li><a href="#strides">Strides</a></li>
            <li><a href="#tensors">Tensor images</a></li>
            <li><a href="#pointers">On pixel coordinates, indices, offsets and data pointers</a></li>
            <li><a href="#assignment">Creation, assignment and copy</a></li>
            <li>
              <a href="#indexing">Indexing</a>
              <ul>
                <li><a href="#tensor_indexing">Tensor dimensions</a></li>
                <li><a href="#pixel_indexing">Single-pixel indexing</a></li>
                <li><a href="#regular_indexing">Regular indexing (windows, ROI processing, subsampling)</a></li>
                <li><a href="#irregular_indexing">Irregular indexing (mask image, arbitrary set of pixels)</a></li>
              </ul>
            </li>
            <li><a href="#reshaping">Reshaping</a></li>
            <li><a href="#protect">The &ldquo;protect&rdquo; flag</a></li>
            <li><a href="#const_correctness">Const correctness</a></li>
            <li><a href="#arithmetic">Arithmetic and comparison operators</a></li>
            <li><a href="#color">Color images</a></li>
            <li><a href="#pixel_size">Pixel size</a></li>
            <li>
              <a href="#external_data_segment">Controlling data segment allocation</a>
              <ul>
                <li><a href="#use_external_data">Create an image around existing data</a></li>
                <li><a href="#external_interface">Define an image&rsquo;s allocator</a></li>
              </ul>
            </li>
            <li><a href="#singleton_expansion">Singleton expansion</a></li>
            <li>
              Reference
              <ul>
                <li><a href="#group--Constructors%20and%20assignment%20operators">Constructors and assignment operators</a></li>
                <li><a href="#group--Sizes">Sizes</a></li>
                <li><a href="#group--Strides">Strides</a></li>
                <li><a href="#group--Tensor">Tensor</a></li>
                <li><a href="#group--Data%20type">Data type</a></li>
                <li><a href="#group--Color%20space">Color space</a></li>
                <li><a href="#group--Pixel%20size">Pixel size</a></li>
                <li><a href="#group--Utility%20functions">Utility functions</a></li>
                <li><a href="#group--Data">Data</a></li>
                <li><a href="#group--Pointers%2C%20offsets%2C%20indices">Pointers, offsets, indices</a></li>
                <li><a href="#group--Reshaping%20forged%20image">Reshaping forged image</a></li>
                <li><a href="#group--Indexing%20without%20data%20copy">Indexing without data copy</a></li>
                <li><a href="#group--Setting%20pixel%20values%2C%20copying">Setting pixel values, copying</a></li>
                <li><a href="#nested-classes">Classes</a></li>
                <li><a href="#function-members">Functions</a></li>
                <li><a href="#related">Related</a></li>
              </ul>
            </li>
          </ul>
        </div>
<p>A <code>dip::Image</code> object is the core of the <em>DIPlib</em> library, as all functionality
revolves around images. Some image manipulation is provided as class
methods, but most image processing and analysis functionality is provided
in functions defined in the <a href="dip.html"><code>dip</code></a> namespace.</p>
<h2 id="image_representation">Image representation</h2>
<p>An <code>dip::Image</code> object can have any number of dimensions (limited by the integer
representation used), though 2D and 3D are the most often used dimensionalities.
Most functions in the library accept images with any number of
dimensions, for the functions that are limited in this respect there is
a note in the documentation. A 0D image is an image with a single pixel.</p>
<p>We use the term <strong>pixel</strong> to refer to the collection of samples taken at the
same spatial location, irrespective of the number of dimensions that the
image has (that is, we don&rsquo;t use the term voxel for pixels in 3D images).
A pixel is represented by a <strong>tensor</strong>. We have limited the tensors, in the
current implementation, to have no more than two dimensions (a matrix),
as there doesn&rsquo;t seem to be much use for higher-dimensional tensors in
image analysis. However, there is no limit to the number of <strong>tensor elements</strong>
(other than available memory and the integer representation used).</p>
<p>Each element of the tensor at a pixel is referred to as a <strong>sample</strong>. A tensor
element is synonymous with sample, and we use the one or the other term
in the documentation and code depending on context. We say that an image
with 1 million pixels and 3 samples per pixel has a total of 3 million samples.</p>
<p>If the tensor is 0D (a single sample), the image is a standard grey-value image
(which we refer to as scalar image). A 1D tensor (a vector) can be used to represent
color images (e.g. an RGB image has three samples per pixel), but also for example
the image gradient (see <a href="linear.html#dip-Gradient-Image-CL-Image-L-FloatArray--String-CL-StringArray-CL-BooleanArray--dfloat-"><code>dip::Gradient</code></a>). With a 2D tensor (a matrix) it is possible
to represent concepts such as the Hessian and the structure tensor (see <a href="why_tensors.html">Why tensors?</a>).
For example, the Hessian of a 3D image has 9 samples per pixel. For more details
on how tensor elements are stored, see the section on <a href="dip-Image.html#tensors">Tensor images</a>.</p>
<p>A <code>dip::Image</code> object can contain samples of a wide variety of numeric types,
including binary, unsigned and signed integers, floating point, and
complex. For a complete list see <a href="pixeltypes.html">Pixel data types</a>.
All the image&rsquo;s samples must have the same type.</p>
<p>All of these image properties are dynamic. That is, they can be
determined and changed at runtime, they are not fixed at compile time.
An <code>Image</code> object has two states: <strong>raw</strong> and <strong>forged</strong>. When an image is
<strong>raw</strong>, it has no associated data segment. In the raw state, all image
properties can be changed. The <a href="dip-Image.html#dip-Image-Forge"><code>dip::Image::Forge</code></a> method allocates the data
segment (the memory block that holds the pixel values). Once the image
is <strong>forged</strong>, its properties are fixed. It is possible to call the
<a href="dip-Image.html#dip-Image-Strip"><code>dip::Image::Strip</code></a> method to revert to the raw state. The reason behind this
dynamic image structure is that it allows flexibility: one can read the
data in a file without knowing what the file&rsquo;s data type is going to
be; the file reading function can adjust the <code>Image</code> object&rsquo;s data type
(and dimensionality) at run time to accommodate any data that the file
might contain. Another advantage is that the programmer does not need
to think about, for example, what data type is appropriate as output of
a specific function. However, when desired, it is possible to control
the data types of images.</p>
<h2 id="strides">Strides</h2>
<p>For maximum flexibility in the relationship between image coordinates
and how the samples are stored in memory, a <code>dip::Image</code> object specifies a
<strong>stride</strong> array (<a href="dip-Image.html#dip-Image-Strides-C"><code>dip::Image::Strides</code></a>). This array indicates, for each
dimension, how many samples to skip to get to the neighboring pixel in the
given dimension.
For example, to go from a pixel at coordinates (<code>x</code>,<code>y</code>) to the neighbor
at coordinates (<code>x+1</code>,<code>y</code>), you would need to increment the data pointer
with <code>strides[0]</code>. In a 2D image, the pixel at coordinates (<code>x</code>,<code>y</code>) can be
reached by (assuming <a href="pixeltypes.html#dip-DT_UINT8"><code>dip::DT_UINT8</code></a> data type):</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">uint8</span><span class="o">*</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Origin</span><span class="p">();</span>
<span class="n">dip</span><span class="o">::</span><span class="n">IntegerArray</span><span class="w"> </span><span class="n">strides</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Strides</span><span class="p">();</span>
<span class="n">dip</span><span class="o">::</span><span class="n">uint8</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>This concept naturally scales with image dimensionality. Strides can be
negative, and need not be ordered in any particular way. This allows a
<code>dip::Image</code> object to contain a regular subset of the pixels of another
image, but still point to the same physical memory block. Here are some
examples:</p>
<ul>
<li>
<p>An <code>Image</code> object can contain a region of interest (ROI), a smaller
  region within a larger image. In this case, the strides are identical
  to those of the larger image, but the origin and the image size
  differs.</p>
</li>
<li>
<p>An <code>Image</code> object can contain a subsampled image, where the strides
  are a multiple of the strides of the original image.</p>
</li>
<li>
<p>An <code>Image</code> object can contain a single slice of a 3D image, where the
  strides are identical to the 3D image&rsquo;s strides, but the origin and
  the image size and dimensionality are different.</p>
</li>
<li>
<p>An <code>Image</code> object can contain a mirrored image, where the stride in
  the mirrored dimension is negative, and the origin is different.</p>
</li>
<li>
<p>An <code>Image</code> object can contain a rotated image. For example, rotating
  over 90 degrees involves swapping the two dimensions (i.e. swapping the
  sizes and strides associated to these dimensions), and inverting one
  of the dimensions (as in the case of the mirrored image).</p>
</li>
</ul>
<p>Arbitrary strides also allow data segments from other software to be
encapsulated by an <code>Image</code> object. For example, <em>MATLAB</em> stores images
with columns contiguous in memory, requiring <code>strides[1] == 1</code>.</p>
<p>All routines in the library support images with arbitrary strides.</p>
<p>The various elements of a tensor are also accessed through a stride,
which can be obtained through <a href="dip-Image.html#dip-Image-TensorStride-C"><code>dip::Image::TensorStride</code></a>. Even for a 2D
tensor, all tensor elements can be visited using a single stride value.
See the section <a href="dip-Image.html#tensors">Tensor images</a> for more information on accessing tensor
elements. And see the section <a href="dip-Image.html#pointers">On pixel coordinates, indices, offsets and data pointers</a> for more information about
accessing samples. See the section <a href="concepts.html#normal_strides">Normal strides</a> for information
on the default strides.</p>
<h2 id="tensors">Tensor images</h2>
<p>A tensor image (generalization of the vector and matrix image) has a tensor
for each pixel. A tensor collects all samples corresponding to the same spatial
location into a specific shape. <a href="dip-Image.html#dip-Image-TensorElements-C"><code>dip::Image::TensorElements</code></a> indicates how
many samples per pixel the image has.</p>
<p>A tensor image is stored into a single memory block. In the same way that
strides indicate how to skip from one pixel to another (as described in the
section <a href="dip-Image.html#strides">Strides</a>), the <a href="dip-Image.html#dip-Image-TensorStride-C"><code>dip::Image::TensorStride</code></a> indicates how to skip
from one tensor element to another. This allows e.g. a multi-channel image to
be stored as either interleaved per pixel, per line or per plane, and as long
as an algorithm uses the strides, it does not need to know how the channels
are interleaved.</p>
<p>All tensor elements are stored as if they composed a single spatial dimension.
Therefore, it is possible to change the image such that the tensor elements
form a new spatial dimension (<a href="dip-Image.html#dip-Image-TensorToSpatial-dip-uint-"><code>dip::Image::TensorToSpatial</code></a>), or such that one
spatial dimension is converted to a tensor (<a href="dip-Image.html#dip-Image-SpatialToTensor-dip-uint--dip-uint--dip-uint-"><code>dip::Image::SpatialToTensor</code></a>),
without moving the samples. It is also possible to change the shape of the
tensor without moving data (<a href="dip-Image.html#dip-Image-ReshapeTensorAsVector"><code>dip::Image::ReshapeTensorAsVector</code></a>,
<a href="dip-Image.html#dip-Image-Transpose"><code>dip::Image::Transpose</code></a>).</p>
<p>The shape of the tensor is represented by the enumerator <a href="dip-Tensor.html#dip-Tensor-Shape"><code>dip::Tensor::Shape</code></a>
(obtained through <a href="dip-Image.html#dip-Image-TensorShape-C"><code>dip::Image::TensorShape</code></a>).
The chosen way of storing tensor elements allows us, for example, to store
a symmetric 2D tensor such as the Hessian matrix without repeating the
repeating the duplicated values. We also have a specific shape for diagonal
matrices and triangular matrices.</p>
<h2 id="pointers">On pixel coordinates, indices, offsets and data pointers</h2>
<p>Given</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Then <a href="dip-Image.html#dip-Image-Origin-C"><code>img.Origin()</code></a> is a <code>void*</code> pointer to
the first pixel (or rather the first sample of in the image).
This pointer needs to be cast to the type given by
<a href="dip-Image.html#dip-Image-DataType-C">img.DataType()</a> to be used, as in:</p>
<div class="m-code"><pre><span></span><span class="p">(</span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="o">*</span><span class="p">)</span><span class="n">img</span><span class="p">.</span><span class="n">Origin</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>

<p>A pixel&rsquo;s <strong>offset</strong> is the number of samples to move away from the origin
to access that pixel:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="o">*</span><span class="p">)</span><span class="n">img</span><span class="p">.</span><span class="n">Origin</span><span class="p">();</span>
<span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>

<p>Alternatively, it is possible to compute the pixel&rsquo;s pointer without casting
to the right data type (this leads to a more generic algorithm) by using the
<a href="dip-DataType.html#dip-DataType-SizeOf-C"><code>dip::DataType::SizeOf</code></a> operator (we cast to <a href="pixeltypes.html#dip-uint8"><code>dip::uint8</code></a> pointer to do
pointer arithmetic in bytes):</p>
<div class="m-code"><pre><span></span><span class="p">(</span><span class="n">dip</span><span class="o">::</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">img</span><span class="p">.</span><span class="n">Origin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">DataType</span><span class="p">().</span><span class="n">SizeOf</span><span class="p">();</span>
</pre></div>

<p>This computation is performed by
<a href="dip-Image.html#dip-Image-Pointer-dip-sint--C"><code>img.Pointer( offset )</code></a>.</p>
<p>Note that the offset is a signed integer, and can be negative, because strides
can be negative also.
The offset is computed from coordinates using the image&rsquo;s strides:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="w"> </span><span class="n">coords</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="n">dip</span><span class="o">::</span><span class="n">sint</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Dimensionality</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">ii</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">coords</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Stride</span><span class="p">(</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>This computation is performed by
<a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>img.Offset( coords )</code></a>.
<a href="dip-Image.html#dip-Image-Pointer-dip-sint--C"><code>img.Pointer( coords )</code></a> simply chains this
operation with the previous one. The inverse operation is performed by
<a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>img.OffsetToCoordinates( offset )</code></a>.
Two images of the same size do not necessarily share offset values.
Both the dimensions and the strides must be identical for the offset to be
compatible between the images.</p>
<p>The coordinates to a pixel simply indicate the number of pixels to skip along
each dimension. The first dimension (dimension 0) is typically <code>x</code>, but this
is not evident anywhere in the library, so it is the application using the
library that would make this decision. Coordinates start at 0, and should be
smaller than the <code>img.Sizes()</code> value for that dimension. They are encoded
using a <a href="supporttypes.html#dip-UnsignedArray"><code>dip::UnsignedArray</code></a>. However, some functions take coordinates as
a <a href="supporttypes.html#dip-IntegerArray"><code>dip::IntegerArray</code></a>. These are the functions that do not expect the coordinates
to indicate a pixel inside the image domain.</p>
<p>The <strong>index</strong> to a pixel (a.k.a. &ldquo;linear index&rdquo;) is a value that increases
monotonically as one moves from one pixel to the next, first along dimension 0,
then along dimension 1, etc. The index computed from a pixel&rsquo;s coordinates is
as follows:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="w"> </span><span class="n">coords</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">dd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Dimensionality</span><span class="p">();</span>
<span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">dd</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">--</span><span class="n">dd</span><span class="p">;</span>
<span class="w">  </span><span class="n">index</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Size</span><span class="p">(</span><span class="w"> </span><span class="n">dd</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">coords</span><span class="p">[</span><span class="n">dd</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>

<p>This computation is performed by <a href="dip-Image.html#dip-Image-Index-UnsignedArray-CL-UnsignedArray-CL"><code>img.Index( coords )</code></a>.
It is the <em>n</em>D equivalent to <code>x + y * width</code>. An index, as opposed to an
offset, is always non-negative, and therefore stored in an unsigned integer. The
index is shared among any images with the same dimensions.</p>
<p>It is not efficient to use indices to access many pixels, as the relationship
between the index and the offset is non-trivial. One can determine the
coordinates corresponding to an index through
<a href="dip-Image.html#dip-Image-IndexToCoordinates-dip-uint--C"><code>img.IndexToCoordinates( index )</code></a>,
which then leads to an offset or a pointer.
The function <a href="dip-Image.html#dip-Image-At-UnsignedArray-CL-C"><code>dip::Image::At</code></a> with a scalar argument uses linear indices, and
consequently is not efficient for images with dimensionality of 2 or more.</p>
<p>Oftentimes it is possible to determine a <strong>simple stride</strong> that will allow you to
access every pixel in an image. When an image is a view into another image,
this is not necessarily possible, but any default image (i.e. with <a href="concepts.html#normal_strides">Normal strides</a>)
has this possibility. This simple stride allows one to view the image as a
1D image. The function <a href="dip-Image.html#dip-Image-Flatten"><code>dip::Image::Flatten</code></a> will create this 1D image (without
copying any data, if there exists such a simple stride). Walking along this
one dimension will, however, not necessarily access the pixels in the same order
as given by the linear index. This order is only consistent if the image has
normal strides. See <a href="dip-Image.html#dip-Image-HasNormalStrides-C"><code>dip::Image::HasNormalStrides</code></a>,
<a href="dip-Image.html#dip-Image-HasSimpleStride-C"><code>dip::Image::HasSimpleStride</code></a>, <a href="dip-Image.html#dip-Image-GetSimpleStrideAndOrigin-C"><code>dip::Image::GetSimpleStrideAndOrigin</code></a>.</p>
<p>To walk along all pixels in an arbitrary image (i.e. arbitrary dimensionality
and strides) in the order given by the linear index, use the <strong>image iterators</strong>
defined in <a href="file--diplib--iterators-h.html">diplib/iterators.h</a>
(see <a href="using_iterators.html">Using iterators to implement filters</a>):</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">ImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The functionality in the <a href="dip-Framework.html"><code>dip::Framework</code></a> namespace is the recommended way of
building generic functions that access all pixels in an image. These functions
allow you to loop over multiple images simultaneously, using multi-threading,
while taking care of different data types, checking input images, allocating
output images, etc. Different framework functions do pixel-based processing,
line-based processing (e.g. separable filters, projections) and
neighborhood-based processing (i.e. non-separable filters). There is currently
no plans for framework functionality to support priority queue algorithms,
if you figure out how to make such a function generic enough please contribute!</p>
<p>For images with more than one sample per pixel, the above discussion shows
only how to access the first sample in each pixel. Coordinates always indicate
a pixel, and therefore <a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a> always gives the offset to the
first sample of a pixel. The other samples can be accessed by adding
<code>n * img.TensorStride()</code> to the offset, where <code>n</code> is the tensor element. Tensor
elements are then accessed in a specific order, depending on the shape of the
tensor. See <a href="dip-Tensor.html#dip-Tensor-Shape"><code>dip::Tensor::Shape</code></a> for a description of the order of the tensor
elements in memory. For the iterators, use <code>it[n]</code> to access the <code>n</code>th tensor
element.</p>
<h2 id="assignment">Creation, assignment and copy</h2>
<p>To create a new image with specific properties, one can either set each of
the properties individually, or use one of the constructors. For example,
the two following images are the same:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img1</span><span class="p">;</span>
<span class="n">img1</span><span class="p">.</span><span class="n">SetSizes</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">img1</span><span class="p">.</span><span class="n">SetDataType</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT8</span><span class="w"> </span><span class="p">);</span>
<span class="n">img1</span><span class="p">.</span><span class="n">SetTensorSizes</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="n">img1</span><span class="p">.</span><span class="n">Forge</span><span class="p">();</span>

<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img2</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsingedArray</span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT8</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The first method is more flexible, as it allows to set all properties
before forging the image (such as strides).
Note that the created image has uninitialized pixel data. You can use the
<a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> method to set all pixels to a specific value.</p>
<p>To create a new image with same sizes and tensor shape as another one,
use the <a href="dip-Image.html#dip-Image-Similar-C"><code>dip::Image::Similar</code></a> method:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="p">.</span><span class="n">Similar</span><span class="p">();</span>
</pre></div>

<p>Again, the new image will have uninitialized pixel data. An optional second
argument can be used to specify the data type of the new image:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="p">.</span><span class="n">Similar</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SCOMPLEX</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Both methods copy all image properties, including the strides array and the
external interface; see <a href="dip-Image.html#dip-Image-CopyProperties-Image-CL"><code>dip::Image::CopyProperties</code></a>.</p>
<p>A similar method is <a href="dip-Image.html#dip-Image-ReForge-Image-CL-Option-AcceptDataTypeChange-"><code>dip::Image::ReForge</code></a>, which modifies the properties of
an image and creates a new data segment if the old one is of the wrong size
to support the new properties. In function, these three sets of statements
are equivalent:</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="p">.</span><span class="n">Similar</span><span class="p">();</span>

<span class="n">img2</span><span class="p">.</span><span class="n">Strip</span><span class="p">();</span>
<span class="n">img2</span><span class="p">.</span><span class="n">CopyProperties</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="p">);</span>
<span class="n">img2</span><span class="p">.</span><span class="n">Forge</span><span class="p">();</span>

<span class="n">img2</span><span class="p">.</span><span class="n">ReForge</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>However, <code>ReForge</code> might not strip and forge if it is not necessary
(also, it does not use the source image&rsquo;s strides), and so
is the recommended way of modifying an image to match another one.
<a href="dip-Image.html#dip-Image-ReForge-Image-CL-Option-AcceptDataTypeChange-"><code>dip::Image::ReForge</code></a> has two other forms that can be useful, see the
documentation.</p>
<p>Lastly, it is possible to create a 0D image (an image with a single pixel)
with the constructor that takes a scalar value (integer, float or complex),
or an initializer list containing scalar values of the same type. With the
initializer list, the image will be a vector image with as many samples
as elements in the initializer list:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img1</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img2</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The assignment operator creates a copy of the image, but does not actually
copy the data. Instead, the new copy will share the data segment with the
original image:</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="p">;</span>
</pre></div>

<p>Both <code>img1</code> and <code>img2</code> point at the same data, meaning that changing one
image&rsquo;s pixel values also affects the other image. The data segment will
exist as long as one image references it. That is, if <code>img1</code> goes out
of scope, <code>img2</code> will still point at a valid data segment, which will not
be freed until <code>img2</code> goes out of scope (or is stripped). This is useful
behavior, but can cause unexpected results at times. See <a href="concepts.html#aliasing">Handling input and output images that alias each other</a>
for how to write image filters that are robust against images with shared
data. However, if the image assigned into is protected or has an external
interface set, a data copy might be triggered, see <a href="dip-Image.html#protect">The &ldquo;protect&rdquo; flag</a> and
<a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a>.</p>
<p><a href="dip-Image.html#dip-Image-QuickCopy-C"><code>dip::Image::QuickCopy</code></a> can be used here if the image copy does not need any of
the image metadata (color space and pixel size). The overhead of copying
the metadata information is small, but we often use this function
internally when the input image to a function needs to be reshaped for
processing, but we do not want to modify the input image itself:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="p">.</span><span class="n">QuickCopy</span><span class="p">();</span>
<span class="n">tmp</span><span class="p">.</span><span class="n">Squeeze</span><span class="p">();</span>
<span class="p">...</span>
</pre></div>

<p>The copy constructor behaves the same way as the assignment operator, making
the new image share data with the input image. The following three statements
all invoke the copy constructor:</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img3</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="p">;</span>
</pre></div>

<p>To make a copy of an image with its own copy of the data segment, use the
<a href="dip-Image.html#dip-Image-Copy-Image-CL"><code>dip::Image::Copy</code></a> method:</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="p">.</span><span class="n">Copy</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>or equivalently the <a href="dip-Image.html#dip-Copy-Image-CL-Image-L"><code>dip::Copy</code></a> function:</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Copy</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>In both cases, <code>img2</code> will be identical to <code>img1</code>, with identical pixel values,
and with its own data segment.</p>
<p>When the <a href="dip-Image.html#dip-Image-Copy-Image-CL"><code>dip::Image::Copy</code></a> method is used on a forged image, it is expected to
be of the same size as the image to be copied. Pixel values will be copied to
the existing data segment, casting to the target image&rsquo;s data type with clamping
(see <a href="file--diplib--library--clamp_cast-h.html">diplib/library/clamp_cast.h</a>):</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="p">.</span><span class="n">Similar</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT8</span><span class="w"> </span><span class="p">);</span>
<span class="n">img2</span><span class="p">.</span><span class="n">Copy</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Or equivalently:</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Convert</span><span class="p">(</span><span class="w"> </span><span class="n">img1</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT8</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The <a href="dip-Image.html#dip-Image-Convert-dip-DataType-"><code>dip::Image::Convert</code></a> method, as opposed to the <a href="dip-Image.html#dip-Convert-Image-CL-Image-L-dip-DataType-"><code>dip::Convert</code></a> function, converts
the image itself to a new data type. This process creates a new data segment if
the data type is of different size, and works in place if the data type is of the
same size (e.g. <a href="pixeltypes.html#dip-DT_SINT32"><code>dip::DT_SINT32</code></a> and <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a> have the same size, as do
<a href="pixeltypes.html#dip-DT_DFLOAT"><code>dip::DT_DFLOAT</code></a> and <a href="pixeltypes.html#dip-DT_SCOMPLEX"><code>dip::DT_SCOMPLEX</code></a>). However, if the data segment is shared,
it will never work in place, as that could cause important problems.</p>
<p>Assigning a constant to an image is equivalent to calling the <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a>
method, writing that constant to each sample in the image. The constant is
cast to the image&rsquo;s data type with saturation (see <a href="pixeltypes.html#dip-clamp_cast-T-SourceType-"><code>dip::clamp_cast</code></a>). Note that
the image must be forged:</p>
<div class="m-code"><pre><span></span><span class="n">img1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="n">img2</span><span class="p">.</span><span class="n">Fill</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Additionally, one can assign an initializer list to an image. The list should
have one element for each tensor element. Each pixel in the image will then
be set to the tensor values in the initializer list:</p>
<div class="m-code"><pre><span></span><span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SFLOAT</span><span class="w"> </span><span class="p">);</span>
<span class="n">img2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>
</pre></div>

<p><code>img2</code> will have all pixels set to the same vector <code>[ 1, 2, 3, 4 ]</code>.</p>
<h2 id="indexing">Indexing</h2>
<p>There are three main modes of indexing pixels in a <code>dip::Image</code> object: single
pixel indexing, regular grid indexing, and irregular pixel indexing. All three
modes have similar, consistent syntax, but differ by the return type and properties.
Additionally, one can index into the tensor dimension. The next four sub-sections
describe these different indexing modes.</p>
<p>All indexing modes share in common that the returned object can be assigned to,
modifying the original image. When indexing a single pixel, the return type is
a <a href="dip-Image-Pixel.html"><code>dip::Image::Pixel</code></a>, which references a single pixel in the original image.
When indexing multiple pixels (either by indexing the tensor dimension or by
regular or irregular indexing), the return type is a <a href="dip-Image-View.html"><code>dip::Image::View</code></a>, which
references multiple pixels in the original image. Both these objects have
some overloaded methods and can be iterated over. Additionally, the <a href="dip-Image-View.html"><code>dip::Image::View</code></a>
object implicitly casts back to a <a href="dip-Image.html"><code>dip::Image</code></a>, so it can be used as arguments
to functions that take an <code>Image</code> as input. Here is where the difference between regular
and irregular indexing comes into play: the <code>Image</code> that results from regular
indexing (and from tensor indexing) shares the data with the original image, whereas
when the indexing was irregular, the data needs to be copied to create a new image
with only those pixels.</p>
<p>The following table summarizes the various indexing types discussed in detail in this
section.</p>
<div class="m-smaller-font m-spaced m-block m-flat">
<table class="m-table">
<thead>
<tr>
<th>&nbsp;</th>
<th>Single pixel</th>
<th>Tensor</th>
<th>Regular</th>
<th>Mask image</th>
<th>Set of pixels</th>
</tr>
</thead>
<tbody>
<tr>
<td>Syntax</td>
<td><code>.At(dip::uint, ...)</code><br><code>.At(dip::UnsignedArray)</code></td>
<td><code>[dip::uint]</code><br><code>[dip::UnsignedArray]</code><br><code>[dip::Range]</code><br><code>.Diagonal()</code><br><code>.TensorRow(dip::uint)</code><br><code>.TensorColumn(dip::uint)</code></td>
<td><code>.At(dip::Range, ...)</code><br><code>.At(dip::RangeArray)</code></td>
<td><code>.At(dip::Image)</code></td>
<td><code>.At(dip::CoordinateArray)</code><br><code>.AtIndices(dip::UnsignedArray)</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>dip::Image::Pixel</code></td>
<td><code>dip::Image::View</code></td>
<td><code>dip::Image::View</code></td>
<td><code>dip::Image::View</code></td>
<td><code>dip::Image::View</code></td>
</tr>
<tr>
<td>Implicitly casts to <code>dip::Image</code></td>
<td>No</td>
<td>Yes, with shared data</td>
<td>Yes, with shared data</td>
<td>Yes, with data copy</td>
<td>Yes, with data copy</td>
</tr>
</tbody>
</table>
</div>
<aside class="m-note m-info">
<h4>Attention</h4>
<p>The result of an indexing operation can be used as input image to functions, but
not as output image: output images are taken by reference, which cannot bind a temporary.
Thus, the following does not compile:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Gauss</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Does not compile.</span>
</pre></div>

<p>The output image must always be a <code>dip::Image</code> object with a name (i.e. a variable of type <code>dip::Image</code>):</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">];</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Gauss</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Writes to `out` (assuming `channel` has the expected properties).</span>
</pre></div>

<p>Do note that some indexing operations, when cast to a <code>dip::Image</code>, cause pixels to be copied, and
hence cannot be used to write into the original image:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">);</span><span class="w">      </span><span class="c1">// `mask` here is a binary image.</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Threshold</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Warning! `out` is not modified.</span>
</pre></div>

<p>Instead, copy the result of the operation directly into the result of the indexing operation:</p>
<div class="m-code"><pre><span></span><span class="n">out</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Threshold</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">));</span><span class="w"> </span><span class="c1">// This does incur an extra copy.</span>
</pre></div>

</aside>
<h3 id="tensor_indexing">Tensor dimensions</h3>
<p>To address one channel in a color image is a rather common operation, and therefore
we have delegated the C++ indexing operator (<code>[]</code>) to the task of extracting a
tensor component from an image (remember that a color channel is a tensor component).
For example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colorIm</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">];</span>
</pre></div>

<p>For a two-dimensional matrix it is possible to index using two values in an array:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tensorIm</span><span class="p">[</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="p">{</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">];</span>
</pre></div>

<p>The indexing operation, as explained above, returns a <a href="dip-Image-View.html"><code>dip::Image::View</code></a> object,
which can be assigned to to modify the referenced pixels:</p>
<div class="m-code"><pre><span></span><span class="n">colorIm</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colorIm</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">];</span>
</pre></div>

<p>When cast back to an image, the image created shares the pixels with the original image,
meaning that it is possible to write to a channel in this way:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">blueChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colorIm</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">];</span>
<span class="n">blueChannel</span><span class="p">.</span><span class="n">Protect</span><span class="p">();</span><span class="w">                         </span><span class="c1">// Prevent `dip::Gauss` from reforging this image.</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Gauss</span><span class="p">(</span><span class="w"> </span><span class="n">blueChannel</span><span class="p">,</span><span class="w"> </span><span class="n">blueChannel</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Modifies `colorIm`.</span>
</pre></div>

<p>Note that the single-index version of the tensor indexing uses linear indexing into
the tensor element list: if the tensor is, for example, a 2x2 symmetric matrix, only
three elements are actually stored, with indices 0 and 1 representing the two diagonal
elements, and index 2 representing the two identical off-diagonal elements. See
<a href="dip-Tensor.html"><code>dip::Tensor</code></a> for information on how the tensor is stored.</p>
<p>To extract multiple tensor elements one can use a <a href="dip-Range.html"><code>dip::Range</code></a> to index. Other useful
methods here are <a href="dip-Image.html#dip-Image-Diagonal-C"><code>dip::Image::Diagonal</code></a>, <a href="dip-Image.html#dip-Image-TensorRow-dip-uint--C"><code>dip::Image::TensorRow</code></a> and
<a href="dip-Image.html#dip-Image-TensorColumn-dip-uint--C"><code>dip::Image::TensorColumn</code></a>, which all yield a vector image.</p>
<p>The methods <a href="dip-Image.html#dip-Image-Real-C"><code>dip::Image::Real</code></a> and <a href="dip-Image.html#dip-Image-Imaginary-C"><code>dip::Image::Imaginary</code></a> are somewhat related to these
last three methods in that they return a view over a subset of the data, except that
they reference only the real or imaginary component of the complex sample values.</p>
<h3 id="pixel_indexing">Single-pixel indexing</h3>
<p>Some forms of the function <a href="dip-Image.html#dip-Image-At-UnsignedArray-CL-C"><code>dip::Image::At</code></a> extract a single pixel from the image. It has different
forms, accepting either a <a href="supporttypes.html#dip-UnsignedArray"><code>dip::UnsignedArray</code></a> representing the coordinates of the pixel,
one to three indices for 1D to 3D images, or a (linear) index to the pixel. The latter
form is less efficient because the linear index needs to be translated to coordinates,
as the linear index is not necessarily related to the order in which pixels are stored
in memory.</p>
<div class="m-code"><pre><span></span><span class="n">image1D</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">);</span><span class="w">                           </span><span class="c1">// Indexes pixel at coordinate 5</span>
<span class="n">image2D</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span><span class="w">                       </span><span class="c1">// Indexes the pixel at coordinates (0, 10)</span>
<span class="n">image2D</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Indexes the pixel at coordinates (0, 10)</span>
<span class="n">image2D</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">);</span><span class="w">                          </span><span class="c1">// Indexes the pixel with linear index 20</span>
</pre></div>

<p>These forms result in an object of type <a href="dip-Image-Pixel.html"><code>dip::Image::Pixel</code></a>. The object contains a
reference to the original image pixels, so writing to the reference changes the pixel
values in the image:</p>
<div class="m-code"><pre><span></span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>

<p>The single-pixel forms of <a href="dip-Image.html#dip-Image-At-UnsignedArray-CL-C"><code>dip::Image::At</code></a> have an alternative, templated form. In that
form, they return a <a href="dip-Image-CastPixel-T.html"><code>dip::Image::CastPixel</code></a> instead, which is identical to a
<a href="dip-Image-Pixel.html"><code>dip::Image::Pixel</code></a>, but implicitly casts to any chosen type. Thus:</p>
<div class="m-code"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span><span class="w">             </span><span class="c1">// Does not compile, no implicit conversion to `int`.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span><span class="w">      </span><span class="c1">// OK</span>
<span class="kt">int</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">).</span><span class="n">As</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Same as `v2`.</span>
</pre></div>

<p>This implicit cast makes its use a little simpler in a setting combined with numbers
of that type. However, the object itself is not tied to the type, and it is still possible
to access (read or write) the pixel as other types. For example, this code will print
&ldquo;( 1.0, -3.0 )&rdquo; to the standard output, the template argument to <code>At</code> has no influence
on the results:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">image</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SCOMPLEX</span><span class="w"> </span><span class="p">);</span>
<span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint8</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="mi">85</span><span class="p">,</span><span class="w"> </span><span class="mi">43</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">dcomplex</span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">-3.0</span><span class="w"> </span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">sint32</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="mi">85</span><span class="p">,</span><span class="w"> </span><span class="mi">43</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Tensor and spatial indexing can be combined in either order, but the results are
not identical:</p>
<div class="m-code"><pre><span></span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">];</span>
<span class="n">image</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">].</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The first line above uses <code>[]</code> to index into the <a href="dip-Image-Pixel.html"><code>dip::Image::Pixel</code></a> object, yielding
a <a href="dip-Image-Sample.html"><code>dip::Image::Sample</code></a>. Again, this is a reference to the sample in the image, and can
be written to to change the image. The second line first uses <code>[]</code> to create a scalar
image view, and then extracts a pixel from it. The result is a <code>dip::Image::Pixel</code> object,
not a <code>dip::Image::Sample</code>, though the pixel object references a single sample in the
input image. In practice, these are equally useful, though the first form is slightly
more efficient because the intermediate object generated has less overhead.</p>
<p>See the documentation to <a href="dip-Image-Sample.html"><code>dip::Image::Sample</code></a> and <a href="dip-Image-Pixel.html"><code>dip::Image::Pixel</code></a> for more information
on how these objects can be used. Note however, that this is not an efficient way of
accessing pixels in an image. It is much more efficient to use pointers into the
data segment. However, pointers require knowledge of the data type at compile time.
The indexing described here is a convenient way to read a particular value in a
data-type agnostic way. To access all pixels in a data-type agnostic way, use the
<a href="dip-GenericImageIterator-T.html"><code>dip::GenericImageIterator</code></a>.</p>
<h3 id="regular_indexing">Regular indexing (windows, ROI processing, subsampling)</h3>
<p>The function <a href="dip-Image.html#dip-Image-At-UnsignedArray-CL-C"><code>dip::Image::At</code></a> is also used for creating views that represent a subset of
pixels. In this form, it accepts a set of <a href="dip-Range.html"><code>dip::Range</code></a> objects, or a <a href="dip-Range.html#dip-RangeArray"><code>dip::RangeArray</code></a>,
representing regular pixel intervals along each dimension through a start, stop and
step value. That is, a range indicates a portion of an image line, with optional
subsampling. For example, indexing into a 1D image:</p>
<div class="m-code"><pre><span></span><span class="n">image1D</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Range</span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w">        </span><span class="c1">// Indexes pixel at coordinate 5</span>
<span class="n">image1D</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Range</span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="c1">// Indexes the first 11 pixels</span>
<span class="n">image1D</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Range</span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Indexes every second pixel</span>
</pre></div>

<p>Note that negative values index from the end, without needing to know the exact
size of the image. Note also that the stop value is always included in the range.</p>
<p>For indexing into multidimensional images, simply provide one range per dimension.
For more than 3 dimensions, use a <a href="dip-Range.html#dip-RangeArray"><code>dip::RangeArray</code></a>.</p>
<p>As is the case with the <code>[]</code> indexing, these operations yield a <a href="dip-Image-View.html"><code>dip::Image::View</code></a> that
can be assigned to to change the referenced pixels; and when cast back to a <code>dip::Image</code>,
yields an image that shares data with the original image. For example:</p>
<div class="m-code"><pre><span></span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Range</span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Range</span><span class="p">{</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>

<p>Tensor and spatial indexing can be combined in either order, with identical
results:</p>
<div class="m-code"><pre><span></span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">)[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">];</span>
<span class="n">image</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">].</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The method <a href="dip-Image.html#dip-Image-Cropped-UnsignedArray-CL-Option-CropLocation--C"><code>dip::Image::Cropped</code></a> is a convenience function to extract a view to a
rectangular widow of a given size and with a given anchor (image center or corner).
The <a href="dip-Image.html#dip-Image-Pad-UnsignedArray-CL-Pixel-CL-Option-CropLocation--C"><code>dip::Image::Pad</code></a> method does the opposite operation, but creates a new image and
copies the data over.</p>
<h3 id="irregular_indexing">Irregular indexing (mask image, arbitrary set of pixels)</h3>
<p>An arbitrary subset of pixels can be indexed in three ways, using one of:</p>
<ul>
<li>a mask image</li>
<li>a list of pixel coordinates</li>
<li>a list of linear indices into the image</li>
</ul>
<p>The first two forms are again available through the <a href="dip-Image.html#dip-Image-At-UnsignedArray-CL-C"><code>dip::Image::At</code></a> method, the
third one through the <a href="dip-Image.html#dip-Image-AtIndices-UnsignedArray-CL-C"><code>dip::Image::AtIndices</code></a> method (since the input argument would
not be distinguishable from indexing a single pixel through its coordinates). As with
regular indexing, the returned object is a <a href="dip-Image-View.html"><code>dip::Image::View</code></a>, which can be assigned
to to change the referenced pixels. But as opposed to regular indexing, when cast
back to a <code>dip::Image</code>, the operation results in a 1D image with a copy of the sample
values. Thus, once cast back to an <code>Image</code>, pixels are no longer shared and can
be modified without affecting the original image. This is by necessity, as the <code>Image</code>
object cannot reference samples that are not stored in memory on a regular grid.</p>
<div class="m-code"><pre><span></span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">);</span>
<span class="n">out</span><span class="p">.</span><span class="n">Fill</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Careful! Does not affect `image`.</span>
</pre></div>

<p>Another typical example:</p>
<div class="m-code"><pre><span></span><span class="n">image</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">otherImage</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<h2 id="reshaping">Reshaping</h2>
<p>There is a large collection of methods to reshape the image without physically
moving samples around in memory. These functions accomplish their goal simply
by modifying the sizes and strides arrays, and the tensor representation
values. Thus, they are very cheap. All of these functions modify the object
directly, and return a reference so that they can be chained.</p>
<p>For example, <a href="dip-Image.html#dip-Image-Rotation90-dip-sint--dip-uint--dip-uint-"><code>dip::Image::Rotation90</code></a> rotates the image in 90 degree increments
by mirroring and swapping dimensions. More generic methods are <a href="dip-Image.html#dip-Image-Mirror-dip-uint-"><code>dip::Image::Mirror</code></a>,
and <a href="dip-Image.html#dip-Image-SwapDimensions-dip-uint--dip-uint-"><code>dip::Image::SwapDimensions</code></a>. <a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a> reorders the
image&rsquo;s dimensions, an optionally adds or removes singleton dimensions. Singleton
dimensions are dimensions with a size of 1, and can be added or removed without
affecting the data layout in memory.</p>
<p>Several of these methods are meant to manipulate singleton dimensions.
<a href="dip-Image.html#dip-Image-AddSingleton-dip-uint-"><code>dip::Image::AddSingleton</code></a> and <a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a> add and remove singleton
dimensions. <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a> adds singleton dimensions at the
end to increase the number of image dimensions. It is also possible to expand
singleton dimensions so they no longer are singleton, by replicating the data
along that dimensions, again without physically replicating or modifying the
data in memory. See <a href="dip-Image.html#singleton_expansion">Singleton expansion</a>. The methods
<a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonDimensions-UnsignedArray-CL"><code>dip::Image::ExpandSingletonDimensions</code></a>
and <a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a> are used for this.
<a href="dip-Image.html#dip-Image-UnexpandSingletonDimensions"><code>dip::Image::UnexpandSingletonDimensions</code></a> does the opposite operation.</p>
<p>The method <a href="dip-Image.html#dip-Image-StandardizeStrides"><code>dip::Image::StandardizeStrides</code></a> undoes all rotation, mirroring,
dimension reordering, and singleton expansion, by making all strides positive
and sorting them from smallest to largest. It also removes singleton dimensions
(as <a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a>).
The <a href="dip-Image.html#dip-Image-Flatten"><code>dip::Image::Flatten</code></a> method converts the image to 1D (though if the image
does not have contiguous data, it will have to be copied to form a 1D image).
<a href="dip-Image.html#dip-Image-FlattenAsMuchAsPossible"><code>dip::Image::FlattenAsMuchAsPossible</code></a> does the same thing, but never copies.
If the data is not contiguous, the image will not be 1D, though it will hopefully
have fewer dimensions than before the method call. <a href="dip-Image.html#dip-Image-SplitDimension-dip-uint--dip-uint-"><code>dip::Image::SplitDimension</code></a>
splits a dimension into two.</p>
<p>A group of methods manipulate the image&rsquo;s tensor shape:
<a href="dip-Image.html#dip-Image-ReshapeTensor-dip-uint--dip-uint-"><code>dip::Image::ReshapeTensor</code></a> requires the target tensor shape to have as many
tensor elements as the image already has. For example, a 3-vector image can be
converted into a 2x2 symmetric tensor image. <a href="dip-Image.html#dip-Image-ReshapeTensorAsVector"><code>dip::Image::ReshapeTensorAsVector</code></a> and
<a href="dip-Image.html#dip-Image-ReshapeTensorAsDiagonal"><code>dip::Image::ReshapeTensorAsDiagonal</code></a> turn the image into the given tensor shapes.
The <a href="dip-Image.html#dip-Image-Transpose"><code>dip::Image::Transpose</code></a> method belongs in this set, though it has a mathematical
meaning. <code>Transpose</code> changes the row-major matrix into a column-major matrix and
vice-versa, thereby transposing the tensor.</p>
<p>It is also possible to turn the tensor dimension into a spatial dimension and
back, using <a href="dip-Image.html#dip-Image-TensorToSpatial-dip-uint-"><code>dip::Image::TensorToSpatial</code></a> and <a href="dip-Image.html#dip-Image-SpatialToTensor-dip-uint--dip-uint--dip-uint-"><code>dip::Image::SpatialToTensor</code></a>.
Turning the tensor dimension into a spatial dimension can be useful for example
to apply the same operation to all samples in a vector image: it is easier to loop
over a scalar image with a single <a href="dip-ImageIterator-T.html"><code>dip::ImageIterator</code></a> loop than to loop over a
tensor image using a double loop over pixels and over tensor elements.</p>
<p>Similar in purpose and function to <a href="dip-Image.html#dip-Image-TensorToSpatial-dip-uint-"><code>dip::Image::TensorToSpatial</code></a> are functions
that split the complex-valued samples into two floating-point&ndash;valued samples,
and present these as either a new spatial dimension, or the tensor dimension:
<a href="dip-Image.html#dip-Image-SplitComplex-dip-uint-"><code>dip::Image::SplitComplex</code></a>, and <a href="dip-Image.html#dip-Image-SplitComplexToTensor"><code>dip::Image::SplitComplexToTensor</code></a>. The inverse
operation is accomplished with <a href="dip-Image.html#dip-Image-MergeComplex-dip-uint-"><code>dip::Image::MergeComplex</code></a> and
<a href="dip-Image.html#dip-Image-MergeTensorToComplex"><code>dip::Image::MergeTensorToComplex</code></a>.</p>
<h2 id="protect">The &ldquo;protect&rdquo; flag</h2>
<p>An image carries a &ldquo;protect&rdquo; flag. When set, the <a href="dip-Image.html#dip-Image-Strip"><code>dip::Image::Strip</code></a> function
throws an exception. That is, when the flag is set, the data segment cannot
be stripped (freed) or reforged (reallocated). Furthermore, when the protect
flag is set, the assignment operator will perform a deep copy. For example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img1</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SFLOAT</span><span class="w"> </span><span class="p">);</span>
<span class="n">img1</span><span class="p">.</span><span class="n">Protect</span><span class="p">();</span>
<span class="c1">//img1.Strip();  // Throws!</span>
<span class="n">img1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img2</span><span class="p">;</span><span class="w">     </span><span class="c1">// Equivalent to: `img1.Copy( img2 )`.</span>
</pre></div>

<p>The protect flag has two purposes:</p>
<p><strong>First:</strong> To prevent an image from being reforged, for example when the data segment
is allocated in a special way and one needs to ensure it stays that way. In this
case, it functions as a warning.</p>
<p><strong>Second:</strong> To provide a simple means of specifying the data type for the output image
or a filter. Most filters and operations in
<em>DIPlib</em> choose a specific data type for their output based on the input data
type, and in such a way that little precision is lost. For example, the Gaussian
filter will produce a single-precision floating point output image by default
when the input image is an 8-bit unsigned integer. Under the assumption that
this default choice is suitable most of the time, we have chosen to not give
all these functions an additional input argument to specify the data type for
the output image. Instead, if the output image has the protect flag set, these
functions will not modify its data type. Thus, you can set the output image&rsquo;s
data type, protect it, and receive the result of the filter in that data type:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="n">out</span><span class="p">.</span><span class="n">SetDataType</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SINT16</span><span class="w"> </span><span class="p">);</span>
<span class="n">out</span><span class="p">.</span><span class="n">Protect</span><span class="p">();</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Gauss</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="c1">// `out` is forged with correct sizes to receive filter result, and as 16-bit integer.</span>
</pre></div>

<p>This is especially suitable for in-place operations where we want to receive the
output in the same data segment as the input:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
<span class="n">img</span><span class="p">.</span><span class="n">Protect</span><span class="p">();</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Gauss</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>If the filter is called with a protected, forged image as output, as is the case
in the last code snipped above, the filter will not be able to strip and re-forge
the image, meaning that the image must have the correct sizes and tensor elements
to receive the output. However, if the image is not forged, as in the first
code snippet, then the filter can set its sizes and forge it.</p>
<p>Note, however, that some functions require specific data types for their output image,
and will throw an error if the wrong output data type is requested.</p>
<h2 id="const_correctness">Const correctness</h2>
<p>When an image object is marked <code>const</code>, the compiler will prevent modifications
to it, it cannot be assigned to, and it cannot be used as the output argument
to a filter function. However, the <a href="dip-Image.html#indexing">indexing operators</a>, the copy
assignment operator, and <a href="dip-Image.html#dip-Image-QuickCopy-C"><code>dip::Image::QuickCopy</code></a> all allow the user to make
a non-const object that points to the same data, making it possible to
modify the pixel values of a const image (see <a href="design.html#design_const_correctness">Const correctness</a>
for our reasons to allow this). Because of that, it did not really make sense
either to have <a href="dip-Image.html#dip-Image-Data-C"><code>dip::Image::Data</code></a>, <a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a>, and <a href="dip-Image.html#dip-Image-Pointer-dip-sint--C"><code>dip::Image::Pointer</code></a>
return const pointers when applied to a const image.</p>
<p>Thus, there is nothing prevent you from modifying the pixel values of a const image.
However, none of the functions in <em>DIPlib</em> will do so. A const image (usually
the input images to functions are marked const) will not be modified.</p>
<h2 id="arithmetic">Arithmetic and comparison operators</h2>
<p>Arithmetic operations, logical operations, and comparisons
can all be performed using operators, but there are also functions defined
that perform the same function with more flexibility. See <a href="math_arithmetic.html">Arithmetic operators</a>
and <a href="math_comparison.html">Comparison operators</a> for a full list of these functions.</p>
<p>For example, to add two images <code>a</code> and <code>b</code>, one can simply do:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
</pre></div>

<p>But it is also possible to control the output image by using the <a href="math_arithmetic.html#dip-Add-Image-CL-Image-CL-Image-L-DataType-"><code>dip::Add</code></a>
function:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SINT32</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The fourth argument specifies the data type of the output image. The computation
is performed in that data type, meaning that both inputs are first cast to that
data type (with clamping). The operation is then performed with saturation. This
means that adding -5 and 10 in an unsigned integer format will not yield 5, but 10,
because the -5 is first cast to unsigned, becoming 0. Also, adding 200 and 200 in an 8-bit
unsigned integer format will yield 255, there is no dropping of the higher-order
bit as in standard C++ arithmetic.</p>
<p>As is true for most image processing functions in <em>DIPlib</em> (see <a href="design.html#design_function_signatures">Function signatures</a>),
the statement above is identical to</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SINT32</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>However, the former version allows for writing to already-allocated memory space
in image <code>c</code>, or to an image with an external interface (see <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a>).</p>
<p>For in-place addition, use</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">DataType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>or simply</p>
<div class="m-code"><pre><span></span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
</pre></div>

<p>All dyadic operations (arithmetic, logical, comparison) perform <a href="dip-Image.html#singleton_expansion">Singleton expansion</a>.
They also correctly handle tensor images of any shape. For example, it is possible
to add a vector image and a tensor image, but it is not possible to add two vector
images of different lengths. The multiplication operation always performs matrix
multiplication on the tensors, use the <a href="math_arithmetic.html#dip-MultiplySampleWise-Image-CL-Image-CL-Image-L-DataType-"><code>dip::MultiplySampleWise</code></a> function to do
sample-wise multiplication. Other operators are sample-wise by definition (including
the division, which is not really defined for tensors).</p>
<h2 id="color">Color images</h2>
<p>A color image is a vector image where each vector element represents a color
channel. <a href="dip-Image.html#dip-Image-SetColorSpace-String-"><code>dip::Image::SetColorSpace</code></a> assigns a string into the image object that
flags it as a color image. The string identifies the color space. An empty string
indicates that the image is not a color image.</p>
<p>There are no checks made when
marking the image as a color image. For example, and RGB image is expected to
have three channels (<code>img.TensorElements() == 3</code>).
However, the call <code>img.SetColorSpace("RGB")</code> will mark <code>img</code> as an RGB image
no matter how many tensor elements it has (this is because the function has
no knowledge of color spaces). If the image has other than three
tensor elements, errors will occur when the color space information is used,
for example when trying to convert the image to a different color space.</p>
<p>Nonetheless, when manipulating an image in such a way that the number of tensor
elements changes, the color space information in the image is reset, turning it
into a non-color image.</p>
<p>An object of type <a href="dip-ColorSpaceManager.html"><code>dip::ColorSpaceManager</code></a> is used to convert an image from one
known color space to another. This object is the only place in the library where
there is knowledge about color spaces. Create one of these objects for any
application that requires color space knowledge. It is possible to register new
color spaces and color space conversion functions with this object. Other functions
that use specific color spaces will have knowledge only of those specific color
spaces, and will expect their input to be in one of those color spaces.</p>
<h2 id="pixel_size">Pixel size</h2>
<p>Each image carries with it the size of its pixels as a series of physical
quantities (<a href="dip-PhysicalQuantity.html"><code>dip::PhysicalQuantity</code></a>), one for each image dimension. The advantage
of keeping the pixel size with the image rather than as a separate value taken
manually from the image file metadata is that it is automatically updated through
manipulations such as scaling (zoom), dimension permutations, etc. When the pixel
size in a particular dimension is not set, it is always presumed to be of size 1
(a dimensionless unit). See <a href="dip-PixelSize.html"><code>dip::PixelSize</code></a> for details.</p>
<p>There are three ways in which the pixel size can be used:</p>
<ul>
<li>
<p>The measurement function will return its measurements as physical quantities,
  using the pixel sizes, if known, to derive those from measurements in pixels.</p>
</li>
<li>
<p>The <code>dip::Image::PhysicalToPixels</code> method converts a filter size in physical
  units to one in pixels, suitable to pass to a filtering function. For example,
  to apply a filter with a sigma of 1 micron to an image:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">PhysicalQuantityArray</span><span class="w"> </span><span class="n">fsz_phys</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">PhysicalQuantity</span><span class="o">::</span><span class="n">Micrometer</span><span class="p">()</span><span class="w"> </span><span class="p">};</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Filter</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">PhysicalToPixels</span><span class="p">(</span><span class="w"> </span><span class="n">fsz_phys</span><span class="w"> </span><span class="p">));</span>
</pre></div>

</li>
<li>
<p>The <code>dip::Image::PixelsToPhysical</code> method converts coordinates in pixels to
  coordinates in physical units. For example, to determine the position in
  physical units of a pixel w.r.t. the top left pixel:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">FloatArray</span><span class="w"> </span><span class="n">pos_pix</span><span class="p">{</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="w"> </span><span class="p">};</span>
<span class="n">dip</span><span class="o">::</span><span class="n">PhysicalQuantityArray</span><span class="w"> </span><span class="n">pos_phys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">PixelsToPhysical</span><span class="p">(</span><span class="w"> </span><span class="n">pos_pix</span><span class="w"> </span><span class="p">);</span>
</pre></div>

</li>
</ul>
<p>It is currently possible to add, subtract, multiply and divide two physical quantities,
and elevate a physical quantity to an integer power. Other operations should be
added as necessary.</p>
<h2 id="external_data_segment">Controlling data segment allocation</h2>
<p>It is possible to create <code>dip::Image</code> objects whose pixels are not allocated
by <em>DIPlib</em> using two different methods:</p>
<ol>
<li>
<p>Create an image around an existing data segment. This is used in the case
when passing data from other imaging libraries, or from interpreted languages
that have their own array type. Just about any data can be encapsulated by a
a <code>dip::Image</code> without copy.</p>
</li>
<li>
<p>Define an image&rsquo;s allocator, so that when <em>DIPlib</em> forges the image, the
user&rsquo;s allocator is called instead of <code>std::malloc</code>. This is used in the
case when the result of <em>DIPlib</em> functions will be passed to another
imaging library, or to an interpreted language.</p>
</li>
</ol>
<p>In both cases, <a href="dip-Image.html#dip-Image-IsExternalData-C"><code>dip::Image::IsExternalData</code></a> returns true.</p>
<p>Note that when the image needs to be reforged (sizes and/or data type do not
match what is required for output by some function), but the data segment is
of the correct size, <a href="dip-Image.html#dip-Image-ReForge-Image-CL-Option-AcceptDataTypeChange-"><code>dip::Image::ReForge</code></a> would typically re-use the data
segment if it is not shared with another image. However, when the data segment
is external, it is always reforged.</p>
<h3 id="use_external_data">Create an image around existing data</h3>
<p>One of the <code>dip::Image</code> constructors takes a pointer to the first pixel of a
data segment (i.e. pixel buffer), and image sizes and strides, and creates a new
image that references that data. The only requirement is that all pixels are
aligned on boundaries given by the size of the sample data type. That is,
<em>DIPlib</em> strides are not in bytes but in samples. The resulting image is identical
to any other image in all respects, except the behavior of <a href="dip-Image.html#dip-Image-ReForge-Image-CL-Option-AcceptDataTypeChange-"><code>dip::Image::ReForge</code></a>,
as mentioned in the previous paragraph.</p>
<p>For example, in this bit of code we take the data of a <code>std::vector</code> and build an
image around it, which we can use as both an input or an output image:</p>
<div class="m-code"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">src</span><span class="p">(</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// existing data</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="p">(</span>
<span class="w">   </span><span class="n">NonOwnedRefToDataSegment</span><span class="p">(</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"> </span><span class="p">),</span>
<span class="w">   </span><span class="n">src</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w">    </span><span class="c1">// origin</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT8</span><span class="p">,</span><span class="w"> </span><span class="c1">// dataType</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// sizes</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">}</span><span class="w">     </span><span class="c1">// strides</span>
<span class="p">);</span>
<span class="n">img</span><span class="p">.</span><span class="n">Protect</span><span class="p">();</span><span class="w">          </span><span class="c1">// Prevent `dip::Gauss` from reallocating its output image.</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Gauss</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Apply Gaussian filter, output is written to input array.</span>
</pre></div>

<p>The first argument to this constructor is a <a href="imagetype.html#dip-DataSegment"><code>dip::DataSegment</code></a> object, which is just
a shared pointer to void. If you want the <code>dip::Image</code> object to own the resources,
pass a shared pointer with an appropriate deleter function. Otherwise, use the
function <a href="imagetype.html#dip-NonOwnedRefToDataSegment-void-P"><code>dip::NonOwnedRefToDataSegment</code></a> to create a shared pointer without a deleter
function (as in the example above), indicating that ownership is not to be transferred.
In the example below, we do the same as above, but we transfer ownership of the
<code>std::vector</code> to the image. When the image goes out of scope (or is reallocated) the
<code>std::vector</code> is deleted:</p>
<div class="m-code"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// existing data</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="p">(</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">DataSegment</span><span class="p">{</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="c1">// transfer ownership of the data</span>
<span class="w">   </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w">   </span><span class="c1">// origin</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT8</span><span class="p">,</span><span class="w"> </span><span class="c1">// dataType</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// sizes</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">}</span><span class="w">     </span><span class="c1">// strides</span>
<span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Gauss</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Apply Gaussian filter, output is written to a different data segment.</span>
</pre></div>

<p>After the call to <a href="linear.html#dip-Gauss-Image-CL-Image-L-FloatArray--UnsignedArray--String-CL-StringArray-CL-dfloat-"><code>dip::Gauss</code></a>, <code>*src</code> no longer exists. <code>dip::Gauss</code> has reforged
<code>img</code> to be of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a>, triggering the deletion of object pointed to
by <code>src</code>.</p>
<p>Another form of the constructor simplifies the above in the case where ownership is not
transferred. It takes two or three input arguments: a pointer to the data and an array
with sizes, and optionally the number of tensor elements (channels). The strides are
assumed to be normal (see <a href="concepts.html#normal_strides">Normal strides</a>).
The data pointer must be of any of the allowed data types:</p>
<div class="m-code"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">src</span><span class="p">(</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// existing data</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="p">(</span>
<span class="w">   </span><span class="n">src</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w">    </span><span class="c1">// origin</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">// sizes</span>
<span class="p">);</span>
</pre></div>

<h3 id="external_interface">Define an image&rsquo;s allocator</h3>
<p>The the previous sub-section we saw how to encapsulate external data. The
resulting image object can be used as input and output, but most <em>DIPlib</em>
functions will reforge their output images to be of appropriate size and data type.
Unless the allocated image is of suitable size and data type, and the image is
protected, a new data segment will be allocated. This means that the output of the
function call will not be written into the buffer we had provided.</p>
<p>Instead we can define an allocator class, derived from <a href="dip-ExternalInterface.html"><code>dip::ExternalInterface</code></a>,
and assign a pointer to an object of the allocator class to an image using
<a href="dip-Image.html#dip-Image-SetExternalInterface-dip-ExternalInterface-P"><code>dip::Image::SetExternalInterface</code></a>. When that image is forged or reforged,
the <a href="dip-ExternalInterface.html#dip-ExternalInterface-AllocateData-void-PL-dip-DataType--UnsignedArray-CL-IntegerArray-L-dip-Tensor-CL-dip-sint-L"><code>dip::ExternalInterface::AllocateData</code></a> method is called. This method is
free to allocate whatever objects it needs, and sets the image&rsquo;s origin pointer
and strides (much like in the previous section). As before, it is possible to
set the <a href="imagetype.html#dip-DataSegment"><code>dip::DataSegment</code></a> also, so that ownership of the allocated objects is
transferred to the image object. As can be seen in the <em>DIPlib&ndash;MATLAB</em> interface
(see <a href="dml-MatlabInterface.html"><code>dml::MatlabInterface</code></a> in <a href="file--dip_matlab_interface-h.html">dip_matlab_interface.h</a>), the
<a href="imagetype.html#dip-DataSegment"><code>dip::DataSegment</code></a> can contain a custom deleter function that again calls the
external interface object to take care of proper object cleaning.</p>
<p>The external interface remains owned by the calling code, and can be linked to
many images.</p>
<p>Note that an image with an external interface behaves differently when assigned
to: usual assignment causes the source and destination images to share the data
segment (i.e. no copy of samples is made); if the destination has an external
interface that is different from the source&rsquo;s, the samples are copied.
Additionally, these images behave differently when reforged,
<a href="dip-Image.html#external_data_segment">as mentioned above</a>.</p>
<p>The example below is a simple external interface that allocates data using a
<code>std::vector</code>. The <code>AllocateData</code> method returns without setting the <code>origin</code>,
indicating to the calling <a href="dip-Image.html#dip-Image-Forge"><code>dip::Image::Forge</code></a> function that it cannot allocate
such an image. <code>Forge</code> will then allocate the data itself. If you prefer the
forging to fail, simply throw an exception.</p>
<div class="m-code"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">VectorInterface</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">ExternalInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">public</span><span class="o">:</span>
<span class="w">      </span><span class="k">virtual</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DataSegment</span><span class="w"> </span><span class="n">AllocateData</span><span class="p">(</span>
<span class="w">            </span><span class="kt">void</span><span class="o">*&amp;</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span>
<span class="w">            </span><span class="n">dip</span><span class="o">::</span><span class="n">DataType</span><span class="w"> </span><span class="n">datatype</span><span class="p">,</span>
<span class="w">            </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sizes</span><span class="p">,</span>
<span class="w">            </span><span class="n">dip</span><span class="o">::</span><span class="n">IntegerArray</span><span class="o">&amp;</span><span class="w"> </span><span class="n">strides</span><span class="p">,</span>
<span class="w">            </span><span class="n">dip</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tensor</span><span class="p">,</span>
<span class="w">            </span><span class="n">dip</span><span class="o">::</span><span class="n">sint</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tstride</span>
<span class="w">      </span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">if</span><span class="p">((</span><span class="w"> </span><span class="n">sizes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">tensor</span><span class="p">.</span><span class="n">IsScalar</span><span class="p">()</span><span class="w"> </span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// We do not want to handle such images.</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">auto</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">sizes</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizes</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">         </span><span class="n">strides</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">sizes</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">};</span>
<span class="w">         </span><span class="n">tstride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DataSegment</span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">};</span>
<span class="w">      </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>See the source code to <a href="dml-MatlabInterface.html"><code>dml::MatlabInterface</code></a> for a more realistic example
of this feature. That class stores the data in such a way that ownership can
be retrieved from the shared pointer, so that the data array can be used by
<em>MATLAB</em> after the <code>dip::Image</code> object that originally owned it has been
destroyed.</p>
<h2 id="singleton_expansion">Singleton expansion</h2>
<p>When two images need to be of the same size, a process we refer to as
singleton expansion is performed. First, singleton dimensions (dimensions
with a size of 1) are added to the image with the fewer dimensions. This
process does not require a data copy. Next, all singleton dimensions
are expanded to match the size of the corresponding dimension in the other
image. This expansion simply repeats the value all along that dimension,
and is accomplished by setting the image&rsquo;s size in that dimension to
the expected value, and the corresponding stride to 0 (again, no data are
physically copied). This will cause an algorithm to read the same value,
no matter how many steps it takes along this dimension. For example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img1</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="p">{</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">img2</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="p">{</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">img2</span><span class="p">;</span>
</pre></div>

<p>Here, the dimension array for <code>img2</code> will be extended to <code>{ 50, 30, 1 }</code>
in the first step. In the second step, the arrays for both images will
be changed to <code>{ 50, 30, 60 }</code>. <code>img1</code> gets its second dimension expanded,
whereas <code>img2</code> will get its new third dimension expanded. The output image
<code>img3</code> will thus have 50x30x60 pixels.</p>
        <section id="group--Constructors%20and%20assignment%20operators">
            <h2>Constructors and assignment operators</h2>
            <dl class="m-doc">
            <dt id="dip-Image-Image">
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap">) <span class="m-label m-flat m-info">defaulted</span></span>
            </dt>
            <dd>The default-initialized image is 0D (an empty sizes array), one tensor element, <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a>,
and raw (it has no data segment).</dd>
            <dt id="dip-Image-Image-Image-R">
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Image-R" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;&amp; rhs) <span class="m-label m-flat m-success">noexcept</span></span>
            </dt>
            <dd>Move constructor, <code>rhs</code> ends up in default-initialized state, <code>this</code> even robs the external interface
from <code>rhs</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%3D-Image-CL" class="m-doc">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; rhs) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Copy assignment</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%3D-Image-R" class="m-doc">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;&amp; rhs) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Move assignment</dd>
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-UnsignedArray--dip-uint--dip-DataType-" class="m-doc">Image</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> tensorElems = 1,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt = DT_SFLOAT) <span class="m-label m-flat m-info">explicit</span> </span>
            </dt>
            <dd>Forged image of given sizes and data type. The data is left uninitialized.</dd>
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Pixel-CL" class="m-doc">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel) <span class="m-label m-flat m-info">explicit</span> </span>
            </dt>
            <dd>Create a 0-D image with the data type, tensor shape, and values of <code>pixel</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Pixel-CL-dip-DataType-" class="m-doc">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt) <span class="m-label m-flat m-info">explicit</span> </span>
            </dt>
            <dd>Create a 0-D image with data type <code>dt</code>, and tensor shape and values of <code>pixel</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Sample-CL" class="m-doc">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample) <span class="m-label m-flat m-info">explicit</span> </span>
            </dt>
            <dd>Create a 0-D image with the data type and value of <code>sample</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Sample-CL-dip-DataType-" class="m-doc">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt) <span class="m-label m-flat m-info">explicit</span> </span>
            </dt>
            <dd>Create a 0-D image with data type <code>dt</code> and value of <code>sample</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-FloatArray-CL-dip-DataType-" class="m-doc">Image</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; values,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt = DT_SFLOAT) <span class="m-label m-flat m-info">explicit</span> </span>
            </dt>
            <dd>Create a 0-D vector image with data type <code>dt</code>, and values of <code>values</code>.</dd>
            <dt id="dip-Image-Image-View-CL">
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-View-CL" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a> const&amp; view)</span>
            </dt>
            <dd>A <a href="dip-Image-View.html"><code>dip::Image::View</code></a> implicitly converts to a <code>dip::Image</code>.</dd>
            <dt id="dip-Image-Image-View-R">
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-View-R" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>&amp;&amp; view)</span>
            </dt>
            <dd>A <a href="dip-Image-View.html"><code>dip::Image::View</code></a> implicitly converts to a <code>dip::Image</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-DataSegment-CL-void-P-dip-DataType--UnsignedArray--IntegerArray--dip-Tensor-CL-dip-sint--dip-ExternalInterface-P" class="m-doc">Image</a>(</span><span class="m-doc-wrap"><a href="imagetype.html#dip-DataSegment" class="m-doc">dip::DataSegment</a> const&amp; data,
              void* origin,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dataType,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> strides = {},
              <a href="dip-Tensor.html" class="m-doc">dip::Tensor</a> const&amp; tensor = {},
              <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> tensorStride = 1,
              <a href="dip-ExternalInterface.html" class="m-doc">dip::ExternalInterface</a>* externalInterface = nullptr)</span>
            </dt>
            <dd>Create an image around existing data.</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T, typename &lt;SFINAE&gt;&gt;</div>
              <span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-T-T-CP-UnsignedArray--dip-uint-" class="m-doc">Image</a>(</span><span class="m-doc-wrap">T const* data,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> nTensorElements = 1)</span>
            </dt>
            <dd>Create an image around existing data. No ownership is transferred.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Similar-C" class="m-doc">Similar</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Create a new forged image similar to <code>this</code>. The data is not copied.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Similar-dip-DataType--C" class="m-doc">Similar</a>(</span><span class="m-doc-wrap"><a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Create a new forged image similar to <code>this</code>, but with different data type. The data is not copied.</dd>
            </dl>
        </section>
        <section id="group--Sizes">
            <h2>Sizes</h2>
            <dl class="m-doc">
            <dt id="dip-Image-Dimensionality-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Dimensionality-C" class="m-doc-self">Dimensionality</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the number of spatial dimensions.</dd>
            <dt id="dip-Image-Sizes-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Sizes-C" class="m-doc-self">Sizes</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp;</span>
            </dt>
            <dd>Get a const reference to the sizes array (image size).</dd>
            <dt id="dip-Image-Size-dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Size-dip-uint--C" class="m-doc-self">Size</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the image size along a specific dimension, without test for dimensionality.</dd>
            <dt id="dip-Image-NumberOfPixels-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-NumberOfPixels-C" class="m-doc-self">NumberOfPixels</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the number of pixels. Works also for a raw image, using current values of sizes.</dd>
            <dt id="dip-Image-NumberOfSamples-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-NumberOfSamples-C" class="m-doc-self">NumberOfSamples</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the number of samples. Works also for a raw image, using current values of sizes and tensor elements.</dd>
            <dt id="dip-Image-SetSizes-UnsignedArray-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetSizes-UnsignedArray-" class="m-doc-self">SetSizes</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> d)</span>
            </dt>
            <dd>Set the image sizes. The image must be raw.</dd>
            </dl>
        </section>
        <section id="group--Strides">
            <h2>Strides</h2>
            <dl class="m-doc">
            <dt id="dip-Image-Strides-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Strides-C" class="m-doc-self">Strides</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp;</span>
            </dt>
            <dd>Get a const reference to the strides array.</dd>
            <dt id="dip-Image-Stride-dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Stride-dip-uint--C" class="m-doc-self">Stride</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) const -&gt; <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a></span>
            </dt>
            <dd>Get the stride along a specific dimension, without test for dimensionality.</dd>
            <dt id="dip-Image-TensorStride-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorStride-C" class="m-doc-self">TensorStride</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a></span>
            </dt>
            <dd>Get the tensor stride.</dd>
            <dt id="dip-Image-SetStrides-IntegerArray-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetStrides-IntegerArray-" class="m-doc-self">SetStrides</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> s)</span>
            </dt>
            <dd>Set the strides array. The image must be raw.</dd>
            <dt id="dip-Image-SetTensorStride-dip-sint-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetTensorStride-dip-sint-" class="m-doc-self">SetTensorStride</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> ts)</span>
            </dt>
            <dd>Set the tensor stride. The image must be raw.</dd>
            <dt id="dip-Image-ComputeStrides-UnsignedArray-CL-dip-uint-">
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-ComputeStrides-UnsignedArray-CL-dip-uint-" class="m-doc-self">ComputeStrides</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> tensorElements) -&gt; <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a></span>
            </dt>
            <dd>Computes <a href="concepts.html#normal_strides">Normal strides</a> given the sizes array and the number of tensor elements. Note that the
tensor stride is presumed to be 1. If tensor dimension is to be sorted at the end, set <code>tensorElements</code> to 1.</dd>
            <dt id="dip-Image-SetNormalStrides">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetNormalStrides" class="m-doc-self">SetNormalStrides</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Set the strides array and tensor stride so strides are normal (see <a href="concepts.html#normal_strides">Normal strides</a>).
The image must be raw, but its sizes should be set first.</dd>
            <dt id="dip-Image-MatchStrideOrder-Image-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-MatchStrideOrder-Image-CL" class="m-doc-self">MatchStrideOrder</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src)</span>
            </dt>
            <dd>Set the strides array and tensor stride to match the dimension order of <code>src</code>. The image must be raw,
but its sizes should be set first.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-HasContiguousData-C" class="m-doc">HasContiguousData</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if all the pixels are contiguous.</dd>
            <dt id="dip-Image-HasNormalStrides-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-HasNormalStrides-C" class="m-doc-self">HasNormalStrides</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if strides are as by default (see <a href="concepts.html#normal_strides">Normal strides</a>). The image must be forged.</dd>
            <dt id="dip-Image-HasSingletonDimension-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-HasSingletonDimension-C" class="m-doc-self">HasSingletonDimension</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if any of the image dimensions is a singleton dimension (size is 1). Singleton expanded
dimensions are not considered. The image must be forged.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsSingletonExpanded-C" class="m-doc">IsSingletonExpanded</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if the image has been singleton expanded.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-HasSimpleStride-C" class="m-doc">HasSimpleStride</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if the whole image can be traversed with a single stride
value.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-GetSimpleStrideAndOrigin-C" class="m-doc">GetSimpleStrideAndOrigin</a>(</span><span class="m-doc-wrap">) const -&gt; std::pair&lt;dip::sint, void *&gt;</span>
            </dt>
            <dd>Return a single stride to walk through all pixels and pointer to the start of the data.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-HasSameDimensionOrder-Image-CL-C" class="m-doc">HasSameDimensionOrder</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const -&gt; bool</span>
            </dt>
            <dd>Checks to see if <code>other</code> and <code>this</code> have their dimensions ordered in
the same way.</dd>
            </dl>
        </section>
        <section id="group--Tensor">
            <h2>Tensor</h2>
            <dl class="m-doc">
            <dt id="dip-Image-TensorSizes-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorSizes-C" class="m-doc-self">TensorSizes</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a></span>
            </dt>
            <dd>Get the tensor sizes. The array returned can have 0, 1 or
2 elements, as those are the allowed tensor dimensionalities.</dd>
            <dt id="dip-Image-TensorElements-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorElements-C" class="m-doc-self">TensorElements</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the number of tensor elements (i.e. the number of samples per pixel),
the product of the elements in the array returned by TensorSizes.</dd>
            <dt id="dip-Image-TensorColumns-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorColumns-C" class="m-doc-self">TensorColumns</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the number of tensor columns.</dd>
            <dt id="dip-Image-TensorRows-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorRows-C" class="m-doc-self">TensorRows</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the number of tensor rows.</dd>
            <dt id="dip-Image-TensorShape-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorShape-C" class="m-doc-self">TensorShape</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Tensor.html#dip-Tensor-Shape" class="m-doc">dip::Tensor::Shape</a></span>
            </dt>
            <dd>Get the tensor shape.</dd>
            <dt id="dip-Image-Tensor-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Tensor-C" class="m-doc-self">Tensor</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Tensor.html" class="m-doc">dip::Tensor</a> const&amp;</span>
            </dt>
            <dd>Get the tensor shape.</dd>
            <dt id="dip-Image-IsScalar-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsScalar-C" class="m-doc-self">IsScalar</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>True for non-tensor (grey-value) images.</dd>
            <dt id="dip-Image-IsVector-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsVector-C" class="m-doc-self">IsVector</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>True for vector images, where the tensor is one-dimensional.</dd>
            <dt id="dip-Image-IsSquare-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsSquare-C" class="m-doc-self">IsSquare</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>True for square matrix images, independent from how they are stored.</dd>
            <dt id="dip-Image-SetTensorSizes-UnsignedArray-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetTensorSizes-UnsignedArray-CL" class="m-doc-self">SetTensorSizes</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; tdims)</span>
            </dt>
            <dd>Set tensor sizes. The image must be raw.</dd>
            <dt id="dip-Image-SetTensorSizes-dip-uint-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetTensorSizes-dip-uint-" class="m-doc-self">SetTensorSizes</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> nelems)</span>
            </dt>
            <dd>Set tensor sizes. The image must be raw.</dd>
            </dl>
        </section>
        <section id="group--Data%20type">
            <h2>Data type</h2>
            <dl class="m-doc">
            <dt id="dip-Image-DataType-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-DataType-C" class="m-doc-self">DataType</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-DataType.html" class="m-doc">dip::DataType</a></span>
            </dt>
            <dd>Get the image&rsquo;s data type.</dd>
            <dt id="dip-Image-SetDataType-dip-DataType-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetDataType-dip-DataType-" class="m-doc-self">SetDataType</a>(</span><span class="m-doc-wrap"><a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt)</span>
            </dt>
            <dd>Set the image&rsquo;s data type. The image must be raw.</dd>
            </dl>
        </section>
        <section id="group--Color%20space">
            <h2>Color space</h2>
            <dl class="m-doc">
            <dt id="dip-Image-ColorSpace-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ColorSpace-C" class="m-doc-self">ColorSpace</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp;</span>
            </dt>
            <dd>Get the image&rsquo;s color space name.</dd>
            <dt id="dip-Image-IsColor-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsColor-C" class="m-doc-self">IsColor</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Returns true if the image is in color, false if the image is grey-valued.</dd>
            <dt id="dip-Image-SetColorSpace-String-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetColorSpace-String-" class="m-doc-self">SetColorSpace</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> cs)</span>
            </dt>
            <dd>Sets the image&rsquo;s color space name. This causes the image to be a color image,
but will cause errors to occur (eventually, not immediately) if the number of tensor elements
does not match the expected number of channels for the given color space.</dd>
            <dt id="dip-Image-ResetColorSpace">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ResetColorSpace" class="m-doc-self">ResetColorSpace</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Resets the image&rsquo;s color space information, turning the image into a non-color image.</dd>
            </dl>
        </section>
        <section id="group--Pixel%20size">
            <h2>Pixel size</h2>
            <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-PixelSize" class="m-doc">PixelSize</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-PixelSize.html" class="m-doc">dip::PixelSize</a>&amp;</span>
            </dt>
            <dd>Get the pixels&rsquo; size in physical units, by reference, allowing to modify it at will.</dd>
            <dt id="dip-Image-PixelSize-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-PixelSize-C" class="m-doc-self">PixelSize</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-PixelSize.html" class="m-doc">dip::PixelSize</a> const&amp;</span>
            </dt>
            <dd>Get the pixels&rsquo; size in physical units.</dd>
            <dt id="dip-Image-PixelSize-dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-PixelSize-dip-uint--C" class="m-doc-self">PixelSize</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) const -&gt; <a href="dip-PhysicalQuantity.html" class="m-doc">dip::PhysicalQuantity</a></span>
            </dt>
            <dd>Get the pixels&rsquo; size along the given dimension in physical units.</dd>
            <dt id="dip-Image-SetPixelSize-dip-PixelSize-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetPixelSize-dip-PixelSize-" class="m-doc-self">SetPixelSize</a>(</span><span class="m-doc-wrap"><a href="dip-PixelSize.html" class="m-doc">dip::PixelSize</a> ps)</span>
            </dt>
            <dd>Set the pixels&rsquo; size in physical units.</dd>
            <dt id="dip-Image-SetPixelSize-dip-uint--PhysicalQuantity-">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetPixelSize-dip-uint--PhysicalQuantity-" class="m-doc-self">SetPixelSize</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim,
              <a href="dip-PhysicalQuantity.html" class="m-doc">dip::PhysicalQuantity</a> sz)</span>
            </dt>
            <dd>Set the pixels&rsquo; size along the given dimension in physical units.</dd>
            <dt id="dip-Image-ResetPixelSize">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ResetPixelSize" class="m-doc-self">ResetPixelSize</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Reset the pixels&rsquo; size, so that <code>HasPixelSize</code> returns false.</dd>
            <dt id="dip-Image-HasPixelSize-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-HasPixelSize-C" class="m-doc-self">HasPixelSize</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Returns true if the pixel has physical dimensions.</dd>
            <dt id="dip-Image-IsIsotropic-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsIsotropic-C" class="m-doc-self">IsIsotropic</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Returns true if the pixel has the same size in all dimensions.</dd>
            <dt id="dip-Image-AspectRatio-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-AspectRatio-C" class="m-doc-self">AspectRatio</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a></span>
            </dt>
            <dd>Returns an array with aspect ratios: [1, y/x, z/x, &hellip;]. If dimensions don&rsquo;t match, returns
0 for that dimension.</dd>
            <dt id="dip-Image-PixelsToPhysical-FloatArray-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-PixelsToPhysical-FloatArray-CL-C" class="m-doc-self">PixelsToPhysical</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; in) const -&gt; <a href="dip-PhysicalQuantity.html#dip-PhysicalQuantityArray" class="m-doc">dip::PhysicalQuantityArray</a></span>
            </dt>
            <dd>Converts a size in pixels to a size in physical units.</dd>
            <dt id="dip-Image-PhysicalToPixels-PhysicalQuantityArray-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-PhysicalToPixels-PhysicalQuantityArray-CL-C" class="m-doc-self">PhysicalToPixels</a>(</span><span class="m-doc-wrap"><a href="dip-PhysicalQuantity.html#dip-PhysicalQuantityArray" class="m-doc">dip::PhysicalQuantityArray</a> const&amp; in) const -&gt; <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a></span>
            </dt>
            <dd>Converts a size in physical units to a size in pixels.</dd>
            </dl>
        </section>
        <section id="group--Utility%20functions">
            <h2>Utility functions</h2>
            <dl class="m-doc">
            <dt id="dip-Image-CompareProperties-Image-CL-Option-CmpPropFlags--Option-ThrowException--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CompareProperties-Image-CL-Option-CmpPropFlags--Option-ThrowException--C" class="m-doc-self">CompareProperties</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="supporttypes.html#dip-Option-CmpPropFlags" class="m-doc">dip::Option::CmpPropFlags</a> cmpProps,
              <a href="supporttypes.html#dip-Option-ThrowException" class="m-doc">dip::Option::ThrowException</a> throwException = Option::ThrowException::DO_THROW) const -&gt; bool</span>
            </dt>
            <dd>Compare properties of an image against a template, either
returns true/false or throws an error.</dd>
            <dt id="dip-Image-CheckProperties-dip-uint--dip-DataType-Classes--Option-ThrowException--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CheckProperties-dip-uint--dip-DataType-Classes--Option-ThrowException--C" class="m-doc-self">CheckProperties</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> ndims,
              <a href="dip-DataType.html#dip-DataType-Classes" class="m-doc">dip::DataType::Classes</a> dts,
              <a href="supporttypes.html#dip-Option-ThrowException" class="m-doc">dip::Option::ThrowException</a> throwException = Option::ThrowException::DO_THROW) const -&gt; bool</span>
            </dt>
            <dd>Check image properties, either returns true/false or throws an error.</dd>
            <dt id="dip-Image-CheckProperties-dip-uint--dip-uint--dip-DataType-Classes--Option-ThrowException--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CheckProperties-dip-uint--dip-uint--dip-DataType-Classes--Option-ThrowException--C" class="m-doc-self">CheckProperties</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> ndims,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> tensorElements,
              <a href="dip-DataType.html#dip-DataType-Classes" class="m-doc">dip::DataType::Classes</a> dts,
              <a href="supporttypes.html#dip-Option-ThrowException" class="m-doc">dip::Option::ThrowException</a> throwException = Option::ThrowException::DO_THROW) const -&gt; bool</span>
            </dt>
            <dd>Check image properties, either returns true/false or throws an error.</dd>
            <dt id="dip-Image-CheckProperties-UnsignedArray-CL-dip-DataType-Classes--Option-ThrowException--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CheckProperties-UnsignedArray-CL-dip-DataType-Classes--Option-ThrowException--C" class="m-doc-self">CheckProperties</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="dip-DataType.html#dip-DataType-Classes" class="m-doc">dip::DataType::Classes</a> dts,
              <a href="supporttypes.html#dip-Option-ThrowException" class="m-doc">dip::Option::ThrowException</a> throwException = Option::ThrowException::DO_THROW) const -&gt; bool</span>
            </dt>
            <dd>Check image properties, either returns true/false or throws an error.</dd>
            <dt id="dip-Image-CheckProperties-UnsignedArray-CL-dip-uint--dip-DataType-Classes--Option-ThrowException--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CheckProperties-UnsignedArray-CL-dip-uint--dip-DataType-Classes--Option-ThrowException--C" class="m-doc-self">CheckProperties</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> tensorElements,
              <a href="dip-DataType.html#dip-DataType-Classes" class="m-doc">dip::DataType::Classes</a> dts,
              <a href="supporttypes.html#dip-Option-ThrowException" class="m-doc">dip::Option::ThrowException</a> throwException = Option::ThrowException::DO_THROW) const -&gt; bool</span>
            </dt>
            <dd>Check image properties, either returns true/false or throws an error.</dd>
            <dt id="dip-Image-CheckIsMask-UnsignedArray-CL-Option-AllowSingletonExpansion--Option-ThrowException--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CheckIsMask-UnsignedArray-CL-Option-AllowSingletonExpansion--Option-ThrowException--C" class="m-doc-self">CheckIsMask</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-Option-AllowSingletonExpansion" class="m-doc">dip::Option::AllowSingletonExpansion</a> allowSingletonExpansion = Option::AllowSingletonExpansion::DONT_ALLOW,
              <a href="supporttypes.html#dip-Option-ThrowException" class="m-doc">dip::Option::ThrowException</a> throwException = Option::ThrowException::DO_THROW) const -&gt; bool</span>
            </dt>
            <dd>Check image properties for a mask image, either returns true/false or throws an error.</dd>
            <dt id="dip-Image-CopyProperties-Image-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-CopyProperties-Image-CL" class="m-doc-self">CopyProperties</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src)</span>
            </dt>
            <dd>Copy all image properties from <code>src</code>, including strides. The image must be raw.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-CopyNonDataProperties-Image-CL" class="m-doc">CopyNonDataProperties</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src)</span>
            </dt>
            <dd>Copy non-data image properties from <code>src</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ResetNonDataProperties" class="m-doc">ResetNonDataProperties</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Reset non-data image properties.</dd>
            <dt id="dip-Image-swap-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-swap-Image-L" class="m-doc-self">swap</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; other) <span class="m-label m-flat m-success">noexcept</span></span>
            </dt>
            <dd>Swaps <code>this</code> and <code>other</code>.</dd>
            </dl>
        </section>
        <section id="group--Data">
            <h2>Data</h2>
            <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Data-C" class="m-doc">Data</a>(</span><span class="m-doc-wrap">) const -&gt; void*</span>
            </dt>
            <dd>Get pointer to the data segment.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsShared-C" class="m-doc">IsShared</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Check to see if the data segment is shared with other images.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ShareCount-C" class="m-doc">ShareCount</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Get the number of images that share their data with this image.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-SharesData-Image-CL-C" class="m-doc">SharesData</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const -&gt; bool</span>
            </dt>
            <dd>Determine if <code>this</code> shares its data pointer with <code>other</code>.</dd>
            <dt id="dip-Image-IsExternalData-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsExternalData-C" class="m-doc-self">IsExternalData</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Returns true if the data segment was not allocated by <em>DIPlib</em>. See <a href="dip-Image.html#external_data_segment">Controlling data segment allocation</a>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Aliases-Image-CL-C" class="m-doc">Aliases</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const -&gt; bool</span>
            </dt>
            <dd>Determine if <code>this</code> shares any samples with <code>other</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsIdenticalView-Image-CL-C" class="m-doc">IsIdenticalView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const -&gt; bool</span>
            </dt>
            <dd>Determine if <code>this</code> and <code>other</code> offer an identical view of the
same set of pixels.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsOverlappingView-Image-CL-C" class="m-doc">IsOverlappingView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const -&gt; bool</span>
            </dt>
            <dd>Determine if <code>this</code> and <code>other</code> offer different views of the
same data segment, and share at least one sample.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsOverlappingView-ImageConstRefArray-CL-C" class="m-doc">IsOverlappingView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; other) const -&gt; bool</span>
            </dt>
            <dd>Determine if <code>this</code> and any of those in <code>other</code> offer different views of the
same data segment, and share at least one sample.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsOverlappingView-ImageArray-CL-C" class="m-doc">IsOverlappingView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageArray" class="m-doc">dip::ImageArray</a> const&amp; other) const -&gt; bool</span>
            </dt>
            <dd>Determine if <code>this</code> and any of those in <code>other</code> offer different views of the</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Forge" class="m-doc">Forge</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Allocate data segment.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ReForge-Image-CL-Option-AcceptDataTypeChange-" class="m-doc">ReForge</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="supporttypes.html#dip-Option-AcceptDataTypeChange" class="m-doc">dip::Option::AcceptDataTypeChange</a> acceptDataTypeChange = Option::AcceptDataTypeChange::DONT_ALLOW)</span>
            </dt>
            <dd>Modify image properties and forge the image.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ReForge-Image-CL-dip-DataType--Option-AcceptDataTypeChange-" class="m-doc">ReForge</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt,
              <a href="supporttypes.html#dip-Option-AcceptDataTypeChange" class="m-doc">dip::Option::AcceptDataTypeChange</a> acceptDataTypeChange = Option::AcceptDataTypeChange::DONT_ALLOW)</span>
            </dt>
            <dd>Modify image properties and forge the image.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ReForge-UnsignedArray-CL-dip-uint--dip-DataType--Option-AcceptDataTypeChange-" class="m-doc">ReForge</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> tensorElems = 1,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt = DT_SFLOAT,
              <a href="supporttypes.html#dip-Option-AcceptDataTypeChange" class="m-doc">dip::Option::AcceptDataTypeChange</a> acceptDataTypeChange = Option::AcceptDataTypeChange::DONT_ALLOW)</span>
            </dt>
            <dd>Modify image properties and forge the image.</dd>
            <dt id="dip-Image-Strip">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Strip" class="m-doc-self">Strip</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Disassociate the data segment from the image. If there are no
other images using the same data segment, it will be freed.
Throws if the image is protected and has a data segment.</dd>
            <dt id="dip-Image-IsForged-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsForged-C" class="m-doc-self">IsForged</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if forged.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Protect-bool-" class="m-doc">Protect</a>(</span><span class="m-doc-wrap">bool set = true) -&gt; bool</span>
            </dt>
            <dd>Set protection flag.</dd>
            <dt id="dip-Image-Unprotect">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Unprotect" class="m-doc-self">Unprotect</a>(</span><span class="m-doc-wrap">) -&gt; bool</span>
            </dt>
            <dd>Reset protection flag. Alias for <code>Protect(false)</code>.</dd>
            <dt id="dip-Image-IsProtected-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsProtected-C" class="m-doc-self">IsProtected</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if protected. See <a href="dip-Image.html#dip-Image-Protect-bool-"><code>dip::Image::Protect</code></a> for information.</dd>
            <dt id="dip-Image-SetExternalInterface-dip-ExternalInterface-P">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SetExternalInterface-dip-ExternalInterface-P" class="m-doc-self">SetExternalInterface</a>(</span><span class="m-doc-wrap"><a href="dip-ExternalInterface.html" class="m-doc">dip::ExternalInterface</a>* ei)</span>
            </dt>
            <dd>Set external interface pointer. The image must be raw. See <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a>.</dd>
            <dt id="dip-Image-ResetExternalInterface">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ResetExternalInterface" class="m-doc-self">ResetExternalInterface</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Remove external interface pointer. The image behaves like a native one (for assignment, reforging,
etc.), but the current pixel buffer (if forged) is not affected. See <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a>.</dd>
            <dt id="dip-Image-ExternalInterface-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ExternalInterface-C" class="m-doc-self">ExternalInterface</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-ExternalInterface.html" class="m-doc">dip::ExternalInterface</a>*</span>
            </dt>
            <dd>Get external interface pointer. See <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a></dd>
            <dt id="dip-Image-HasExternalInterface-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-HasExternalInterface-C" class="m-doc-self">HasExternalInterface</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd>Test if an external interface is set. See <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a></dd>
            </dl>
        </section>
        <section id="group--Pointers%2C%20offsets%2C%20indices">
            <h2>Pointers, offsets, indices</h2>
            <dl class="m-doc">
            <dt id="dip-Image-Origin-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Origin-C" class="m-doc-self">Origin</a>(</span><span class="m-doc-wrap">) const -&gt; void*</span>
            </dt>
            <dd>Get pointer to the first sample in the image, the first tensor
element at coordinates (0,0,0,&hellip;). The image must be forged.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Pointer-dip-sint--C" class="m-doc">Pointer</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> offset) const -&gt; void*</span>
            </dt>
            <dd>Get a pointer to the pixel given by the offset.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Pointer-UnsignedArray-CL-C" class="m-doc">Pointer</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const -&gt; void*</span>
            </dt>
            <dd>Get a pointer to the pixel given by the coordinates index.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Pointer-IntegerArray-CL-C" class="m-doc">Pointer</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; coords) const -&gt; void*</span>
            </dt>
            <dd>Get a pointer to the pixel given by the coordinates index.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsOnEdge-UnsignedArray-CL-C" class="m-doc">IsOnEdge</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const -&gt; bool</span>
            </dt>
            <dd>Return true if the coordinates are on the image edge.</dd>
            <dt id="dip-Image-IsInside-T-DimensionArray<CoordType>-CL-C">
              <div class="m-doc-template">template&lt;typename CoordType&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsInside-T-DimensionArray<CoordType>-CL-C" class="m-doc-self">IsInside</a>(</span><span class="m-doc-wrap"><a href="dip-DimensionArray-T.html" class="m-doc">dip::DimensionArray</a> const&amp; coords) const -&gt; bool</span>
            </dt>
            <dd>Returns whether the coordinates are inside the image</dd>
            <dt>
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL" class="m-doc">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; strides,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes) -&gt; <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a></span>
            </dt>
            <dd>Compute offset given coordinates and strides.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-Offset-IntegerArray-CL-IntegerArray-CL" class="m-doc">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; coords,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; strides) -&gt; <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a></span>
            </dt>
            <dd>Compute offset given coordinates.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Offset-UnsignedArray-CL-C" class="m-doc">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const -&gt; <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a></span>
            </dt>
            <dd>Compute offset given coordinates.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Offset-IntegerArray-CL-C" class="m-doc">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; coords) const -&gt; <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a></span>
            </dt>
            <dd>Compute offset given coordinates.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-OffsetToCoordinates-dip-sint--C" class="m-doc">OffsetToCoordinates</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> offset) const -&gt; <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a></span>
            </dt>
            <dd>Compute coordinates given an offset.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-OffsetToCoordinatesComputer-C" class="m-doc">OffsetToCoordinatesComputer</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="imagetype.html#dip-CoordinatesComputer" class="m-doc">dip::CoordinatesComputer</a></span>
            </dt>
            <dd>Returns a functor that computes coordinates given an offset.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-Index-UnsignedArray-CL-UnsignedArray-CL" class="m-doc">Index</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes) -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Compute linear index (not offset) given coordinates and image sizes.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Index-UnsignedArray-CL-C" class="m-doc">Index</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const -&gt; <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a></span>
            </dt>
            <dd>Compute linear index (not offset) given coordinates.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IndexToCoordinates-dip-uint--C" class="m-doc">IndexToCoordinates</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> index) const -&gt; <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a></span>
            </dt>
            <dd>Compute coordinates given a linear index.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IndexToCoordinatesComputer-C" class="m-doc">IndexToCoordinatesComputer</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="imagetype.html#dip-CoordinatesComputer" class="m-doc">dip::CoordinatesComputer</a></span>
            </dt>
            <dd>Returns a functor that computes coordinates given a linear index.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-GetCenter-String-CL-C" class="m-doc">GetCenter</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; mode = "right") const -&gt; <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a></span>
            </dt>
            <dd>Returns the coordinates for the center of the image.</dd>
            </dl>
        </section>
        <section id="group--Reshaping%20forged%20image">
            <h2>Reshaping forged image</h2>
            <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-PermuteDimensions-UnsignedArray-CL" class="m-doc">PermuteDimensions</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; order) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Permute dimensions.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-SwapDimensions-dip-uint--dip-uint-" class="m-doc">SwapDimensions</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim1,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim2) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Swap dimensions d1 and d2. This is a simplified version of <code>PermuteDimensions</code>.</dd>
            <dt id="dip-Image-ReverseDimensions">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReverseDimensions" class="m-doc-self">ReverseDimensions</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Reverses the dimensions, such that indexing switches from (x,y,z) to (z,y,x).</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Flatten" class="m-doc">Flatten</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Make image 1D.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-FlattenAsMuchAsPossible" class="m-doc">FlattenAsMuchAsPossible</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Make image have as few dimensions as possible.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-SplitDimension-dip-uint--dip-uint-" class="m-doc">SplitDimension</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> size) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Splits a dimension into two.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Squeeze-UnsignedArray-L" class="m-doc">Squeeze</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a>&amp; dims) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Remove singleton dimensions (dimensions with size==1).</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Squeeze" class="m-doc">Squeeze</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Remove singleton dimensions (dimensions with size==1).</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Squeeze-dip-uint-" class="m-doc">Squeeze</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Remove singleton dimension <code>dim</code> (has size==1).</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-AddSingleton-dip-uint-" class="m-doc">AddSingleton</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Add a singleton dimension (with size==1) to the image.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-AddSingleton-UnsignedArray-CL" class="m-doc">AddSingleton</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; dims) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Add a singleton dimensions (with size==1) to the image.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ExpandDimensionality-dip-uint-" class="m-doc">ExpandDimensionality</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Append singleton dimensions to increase the image dimensionality.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-" class="m-doc">ExpandSingletonDimension</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> sz) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Expand singleton dimension <code>dim</code> to <code>sz</code> pixels, setting the corresponding stride to 0.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ExpandSingletonDimensions-UnsignedArray-CL" class="m-doc">ExpandSingletonDimensions</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; newSizes) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Performs singleton expansion.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-UnexpandSingletonDimensions" class="m-doc">UnexpandSingletonDimensions</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Unexpands singleton-expanded dimensions.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-UnexpandSingletonDimension-dip-uint-" class="m-doc">UnexpandSingletonDimension</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Unexpands a singleton-expanded dimension.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-IsSingletonExpansionPossible-UnsignedArray-CL-C" class="m-doc">IsSingletonExpansionPossible</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; newSizes) const -&gt; bool</span>
            </dt>
            <dd>Tests if the image can be singleton-expanded to <code>size</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ExpandSingletonTensor-dip-uint-" class="m-doc">ExpandSingletonTensor</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> sz) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Expand singleton tensor dimension <code>sz</code> samples, setting the tensor stride to 0.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-UnexpandSingletonTensor" class="m-doc">UnexpandSingletonTensor</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Unexpands the singleton-expanded tensor dimension.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Mirror-dip-uint-" class="m-doc">Mirror</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Mirror the image about a single axes.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Mirror-BooleanArray-" class="m-doc">Mirror</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-BooleanArray" class="m-doc">dip::BooleanArray</a> process = {}) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Mirror the image about selected axes.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Rotation90-dip-sint--dip-uint--dip-uint-" class="m-doc">Rotation90</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> n,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension1,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension2) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Rotates the image by <code>n</code> times 90 degrees, in the plane defined by dimensions
<code>dimension1</code> and <code>dimension2</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Rotation90-dip-sint--dip-uint-" class="m-doc">Rotation90</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> n,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Rotates the 3D image by <code>n</code> times 90 degrees, in the plane perpendicular to dimension <code>axis</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Rotation90-dip-sint-" class="m-doc">Rotation90</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> n = 1) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Rotates the image by <code>n</code> times 90 degrees, in the x-y plane.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-StandardizeStrides" class="m-doc">StandardizeStrides</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Undo the effects of <code>Mirror</code>, <code>Rotation90</code>, <code>PermuteDimensions</code>, and singleton expansion.
Also removes singleton dimensions.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-StandardizeStrides-IntegerArray-L-UnsignedArray-L" class="m-doc">StandardizeStrides</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a>&amp; strides,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a>&amp; sizes) -&gt; std::pair&lt;UnsignedArray, dip::sint&gt;</span>
            </dt>
            <dd>Transforms input arrays and outputs ordering required to standardize an image&rsquo;s strides.</dd>
            <dt id="dip-Image-ReshapeTensor-dip-uint--dip-uint-">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReshapeTensor-dip-uint--dip-uint-" class="m-doc-self">ReshapeTensor</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> rows,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> cols) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Change the tensor shape, without changing the number of tensor elements.</dd>
            <dt id="dip-Image-ReshapeTensor-dip-Tensor-CL">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReshapeTensor-dip-Tensor-CL" class="m-doc-self">ReshapeTensor</a>(</span><span class="m-doc-wrap"><a href="dip-Tensor.html" class="m-doc">dip::Tensor</a> const&amp; example) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Change the tensor shape, without changing the number of tensor elements.</dd>
            <dt id="dip-Image-ReshapeTensorAsVector">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReshapeTensorAsVector" class="m-doc-self">ReshapeTensorAsVector</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Change the tensor to a vector, without changing the number of tensor elements.</dd>
            <dt id="dip-Image-ReshapeTensorAsDiagonal">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReshapeTensorAsDiagonal" class="m-doc-self">ReshapeTensorAsDiagonal</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Change the tensor to a diagonal matrix, without changing the number of tensor elements.</dd>
            <dt id="dip-Image-Transpose">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Transpose" class="m-doc-self">Transpose</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Transpose the tensor.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorToSpatial-dip-uint-" class="m-doc">TensorToSpatial</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Convert tensor dimensions to spatial dimension.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-SpatialToTensor-dip-uint--dip-uint--dip-uint-" class="m-doc">SpatialToTensor</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> rows,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> cols) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Convert spatial dimension to tensor dimensions. The image must be scalar.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-SplitComplex-dip-uint-" class="m-doc">SplitComplex</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Split the two values in a complex sample into separate samples,
creating a new spatial dimension of size 2.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-MergeComplex-dip-uint-" class="m-doc">MergeComplex</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Merge the two samples along dimension <code>dim</code> into a single complex-valued sample.</dd>
            <dt id="dip-Image-SplitComplexToTensor">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-SplitComplexToTensor" class="m-doc-self">SplitComplexToTensor</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Split the two values in a complex sample into separate samples of
a tensor. The image must be scalar and forged.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-MergeTensorToComplex" class="m-doc">MergeTensorToComplex</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Merge the two samples in the tensor into a single complex-valued sample.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReinterpretCast-dip-DataType-" class="m-doc">ReinterpretCast</a>(</span><span class="m-doc-wrap"><a href="dip-DataType.html" class="m-doc">dip::DataType</a> dataType) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Changes the data type of <code>this</code> without changing or copying the data.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReinterpretCastToSignedInteger" class="m-doc">ReinterpretCastToSignedInteger</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Changes the data type of <code>this</code> to a signed integer of the same size, without changing the data.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-ReinterpretCastToUnsignedInteger" class="m-doc">ReinterpretCastToUnsignedInteger</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Changes the data type of <code>this</code> to an unsigned integer of the same size, without changing the data.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-" class="m-doc">Crop</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Reduces the size of the image by cropping off the borders.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Crop-UnsignedArray-CL-String-CL" class="m-doc">Crop</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Reduces the size of the image by cropping off the borders.</dd>
            <dt id="dip-Image-CropWindow-UnsignedArray-CL-Option-CropLocation--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CropWindow-UnsignedArray-CL-Option-CropLocation--C" class="m-doc-self">CropWindow</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) const -&gt; <a href="dip-Range.html#dip-RangeArray" class="m-doc">dip::RangeArray</a></span>
            </dt>
            <dd>Returns the <a href="dip-Range.html#dip-RangeArray"><code>dip::RangeArray</code></a> indexing data that corresponds to the result of <a href="dip-Image.html#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-"><code>dip::Image::Crop</code></a>.</dd>
            <dt id="dip-Image-CropWindow-UnsignedArray-CL-String-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-CropWindow-UnsignedArray-CL-String-CL-C" class="m-doc-self">CropWindow</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) const -&gt; <a href="dip-Range.html#dip-RangeArray" class="m-doc">dip::RangeArray</a></span>
            </dt>
            <dd>Returns the <a href="dip-Range.html#dip-RangeArray"><code>dip::RangeArray</code></a> indexing data that corresponds to the result of <a href="dip-Image.html#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-"><code>dip::Image::Crop</code></a>.</dd>
            <dt id="dip-Image-CropWindow-UnsignedArray-CL-UnsignedArray-CL-Option-CropLocation-">
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-CropWindow-UnsignedArray-CL-UnsignedArray-CL-Option-CropLocation-" class="m-doc-self">CropWindow</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; imageSizes,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; windowSizes,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) -&gt; <a href="dip-Range.html#dip-RangeArray" class="m-doc">dip::RangeArray</a></span>
            </dt>
            <dd>Returns the <a href="dip-Range.html#dip-RangeArray"><code>dip::RangeArray</code></a> indexing data that corresponds to the result of <a href="dip-Image.html#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-"><code>dip::Image::Crop</code></a>,
for an image of size <code>imageSizes</code>.</dd>
            <dt id="dip-Image-CropWindow-UnsignedArray-CL-UnsignedArray-CL-String-CL">
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-CropWindow-UnsignedArray-CL-UnsignedArray-CL-String-CL" class="m-doc-self">CropWindow</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; imageSizes,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; windowSizes,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) -&gt; <a href="dip-Range.html#dip-RangeArray" class="m-doc">dip::RangeArray</a></span>
            </dt>
            <dd>Returns the <a href="dip-Range.html#dip-RangeArray"><code>dip::RangeArray</code></a> indexing data that corresponds to the result of <a href="dip-Image.html#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-"><code>dip::Image::Crop</code></a>,
for an image of size <code>imageSizes</code>.</dd>
            </dl>
        </section>
        <section id="group--Indexing%20without%20data%20copy">
            <h2>Indexing without data copy</h2>
            <dl class="m-doc">
            <dt id="dip-Image-operator%5B%5D-UnsignedArray-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%5B%5D-UnsignedArray-CL-C" class="m-doc-self">operator[]</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; indices) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extract a tensor element, <code>indices</code> must have one or two elements. The image must be forged.</dd>
            <dt id="dip-Image-operator%5B%5D-T-T--C">
              <div class="m-doc-template">template&lt;typename T, typename &lt;SFINAE&gt;&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%5B%5D-T-T--C" class="m-doc-self">operator[]</a>(</span><span class="m-doc-wrap">T index) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extract a tensor element using linear indexing. Negative indices start at the end. The image must be forged.</dd>
            <dt id="dip-Image-operator%5B%5D-Range--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%5B%5D-Range--C" class="m-doc-self">operator[]</a>(</span><span class="m-doc-wrap"><a href="dip-Range.html" class="m-doc">dip::Range</a> range) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extract tensor elements using linear indexing. The image must be forged.</dd>
            <dt id="dip-Image-Diagonal-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Diagonal-C" class="m-doc-self">Diagonal</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts the tensor elements along the diagonal. The image must be forged.</dd>
            <dt id="dip-Image-TensorRow-dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorRow-dip-uint--C" class="m-doc-self">TensorRow</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> index) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts the tensor elements along the given row. The image must be forged and the tensor
representation must be full (i.e. no symmetric or triangular matrices). Use <a href="dip-Image.html#dip-Image-ExpandTensor"><code>dip::Image::ExpandTensor</code></a>
to obtain a full representation.</dd>
            <dt id="dip-Image-TensorColumn-dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-TensorColumn-dip-uint--C" class="m-doc-self">TensorColumn</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> index) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts the tensor elements along the given column. The image must be forged and the tensor
representation must be full (i.e. no symmetric or triangular matrices). Use <a href="dip-Image.html#dip-Image-ExpandTensor"><code>dip::Image::ExpandTensor</code></a>
to obtain a full representation.</dd>
            <dt id="dip-Image-At-UnsignedArray-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-UnsignedArray-CL-C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const -&gt; <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a></span>
            </dt>
            <dd>Extracts the pixel at the given coordinates. The image must be forged.</dd>
            <dt id="dip-Image-At-T-UnsignedArray-CL-C">
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-T-UnsignedArray-CL-C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const -&gt; <a href="dip-Image-CastPixel-T.html" class="m-doc">dip::Image::CastPixel</a></span>
            </dt>
            <dd>Same as above, but returns a type that implicitly casts to <code>T</code>.</dd>
            <dt id="dip-Image-At-dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-dip-uint--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> index) const -&gt; <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a></span>
            </dt>
            <dd>Extracts the pixel at the given linear index (inefficient if image is not 1D!). The image must be forged.</dd>
            <dt id="dip-Image-At-T-dip-uint--C">
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-T-dip-uint--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> index) const -&gt; <a href="dip-Image-CastPixel-T.html" class="m-doc">dip::Image::CastPixel</a></span>
            </dt>
            <dd>Same as above, but returns a type that implicitly casts to <code>T</code>.</dd>
            <dt id="dip-Image-At-dip-uint--dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-dip-uint--dip-uint--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> x_index,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> y_index) const -&gt; <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a></span>
            </dt>
            <dd>Extracts the pixel at the given coordinates from a 2D image. The image must be forged.</dd>
            <dt id="dip-Image-At-T-dip-uint--dip-uint--C">
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-T-dip-uint--dip-uint--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> x_index,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> y_index) const -&gt; <a href="dip-Image-CastPixel-T.html" class="m-doc">dip::Image::CastPixel</a></span>
            </dt>
            <dd>Same as above, but returns a type that implicitly casts to <code>T</code>.</dd>
            <dt id="dip-Image-At-dip-uint--dip-uint--dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-dip-uint--dip-uint--dip-uint--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> x_index,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> y_index,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> z_index) const -&gt; <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a></span>
            </dt>
            <dd>Extracts the pixel at the given coordinates from a 3D image. The image must be forged.</dd>
            <dt id="dip-Image-At-T-dip-uint--dip-uint--dip-uint--C">
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-T-dip-uint--dip-uint--dip-uint--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> x_index,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> y_index,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> z_index) const -&gt; <a href="dip-Image-CastPixel-T.html" class="m-doc">dip::Image::CastPixel</a></span>
            </dt>
            <dd>Same as above, but returns a type that implicitly casts to <code>T</code>.</dd>
            <dt id="dip-Image-begin">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-begin" class="m-doc-self">begin</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-GenericImageIterator-T.html" class="m-doc">dip::GenericImageIterator</a></span>
            </dt>
            <dd>Returns an iterator to the first pixel in the image. Include <a href="file--diplib--generic_iterators-h.html">diplib/generic_iterators.h</a>
to use this.</dd>
            <dt id="dip-Image-end">
              <span class="m-doc-wrap-bumper">static auto <a href="#dip-Image-end" class="m-doc-self">end</a>(</span><span class="m-doc-wrap">) -&gt; <a href="dip-GenericImageIterator-T.html" class="m-doc">dip::GenericImageIterator</a></span>
            </dt>
            <dd>Returns an iterator to the end of the iterator range. It cannot be dereferenced or manipulated,
and is meant solely as an end-of-iteration marker.</dd>
            <dt id="dip-Image-At-Range-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-Range-CL-C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="dip-Range.html" class="m-doc">dip::Range</a> const&amp; x_range) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts a subset of pixels from a 1D image. The image must be forged.</dd>
            <dt id="dip-Image-At-Range-CL-Range-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-Range-CL-Range-CL-C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="dip-Range.html" class="m-doc">dip::Range</a> const&amp; x_range,
              <a href="dip-Range.html" class="m-doc">dip::Range</a> const&amp; y_range) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts a subset of pixels from a 2D image. The image must be forged.</dd>
            <dt id="dip-Image-At-Range-CL-Range-CL-Range-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-Range-CL-Range-CL-Range-CL-C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="dip-Range.html" class="m-doc">dip::Range</a> const&amp; x_range,
              <a href="dip-Range.html" class="m-doc">dip::Range</a> const&amp; y_range,
              <a href="dip-Range.html" class="m-doc">dip::Range</a> const&amp; z_range) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts a subset of pixels from a 3D image. The image must be forged.</dd>
            <dt id="dip-Image-At-RangeArray--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-RangeArray--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="dip-Range.html#dip-RangeArray" class="m-doc">dip::RangeArray</a> ranges) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts a subset of pixels from an image. The image must be forged.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-Image--C" class="m-doc">At</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> mask) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Creates a 1D image view containing the pixels selected by <code>mask</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-At-CoordinateArray-CL-C" class="m-doc">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-CoordinateArray" class="m-doc">dip::CoordinateArray</a> const&amp; coordinates) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Creates a 1D image view containing the pixels selected by <code>coordinates</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-AtIndices-UnsignedArray-CL-C" class="m-doc">AtIndices</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; indices) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Creates a 1D image view containing the pixels selected by <code>indices</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Cropped-UnsignedArray-CL-Option-CropLocation--C" class="m-doc">Cropped</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts a subset of pixels from an image.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Cropped-UnsignedArray-CL-String-CL-C" class="m-doc">Cropped</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts a subset of pixels from an image.</dd>
            <dt id="dip-Image-Real-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Real-C" class="m-doc-self">Real</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts the real component of a complex-typed image. The image must be forged.</dd>
            <dt id="dip-Image-Imaginary-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Imaginary-C" class="m-doc-self">Imaginary</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Extracts the imaginary component of a complex-typed image. The image must be forged and complex-valued.</dd>
            <dt id="dip-Image-AsScalar-dip-uint--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-AsScalar-dip-uint--C" class="m-doc-self">AsScalar</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>Creates a scalar view of the image, where the tensor dimension is converted to a new spatial
dimension. See <a href="dip-Image.html#dip-Image-TensorToSpatial-dip-uint-"><code>dip::Image::TensorToSpatial</code></a>.</dd>
            <dt id="dip-Image-AsScalar-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-AsScalar-C" class="m-doc-self">AsScalar</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a></span>
            </dt>
            <dd>\overload</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-QuickCopy-C" class="m-doc">QuickCopy</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Quick copy, returns a new image that points at the same data as <code>this</code>,
and has mostly the same properties.</dd>
            </dl>
        </section>
        <section id="group--Setting%20pixel%20values%2C%20copying">
            <h2>Setting pixel values, copying</h2>
            <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Pad-UnsignedArray-CL-Pixel-CL-Option-CropLocation--C" class="m-doc">Pad</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; value,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Extends the image by padding with <code>value</code>.</dd>
            <dt id="dip-Image-Pad-UnsignedArray-CL-Option-CropLocation--C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Pad-UnsignedArray-CL-Option-CropLocation--C" class="m-doc-self">Pad</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Extends the image by padding with zeros, overload for function above with <code>value</code> equal to 0.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Pad-UnsignedArray-CL-Pixel-CL-String-CL-C" class="m-doc">Pad</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; value,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Extends the image by padding with <code>value</code>.</dd>
            <dt id="dip-Image-Pad-UnsignedArray-CL-String-CL-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Pad-UnsignedArray-CL-String-CL-C" class="m-doc-self">Pad</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Extends the image by padding with zeros, overload for function above with <code>value</code> equal to 0.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Copy-Image-CL" class="m-doc">Copy</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src)</span>
            </dt>
            <dd>Deep copy, <code>this</code> will become a copy of <code>src</code> with its own data.</dd>
            <dt id="dip-Image-Copy-Image-View-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Copy-Image-View-CL" class="m-doc-self">Copy</a>(</span><span class="m-doc-wrap"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a> const&amp; src)</span>
            </dt>
            <dd>Idem as above, but with a <a href="dip-Image-View.html"><code>dip::Image::View</code></a> as input.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-Copy-C" class="m-doc">Copy</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Deep copy, returns a copy of <code>this</code> with its own data.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Convert-dip-DataType-" class="m-doc">Convert</a>(</span><span class="m-doc-wrap"><a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt)</span>
            </dt>
            <dd>Converts the image to another data type.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-SwapBytesInSample" class="m-doc">SwapBytesInSample</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Swaps bytes in each sample, converting from little endian to big endian or vice versa.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ExpandTensor" class="m-doc">ExpandTensor</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Expands the image&rsquo;s tensor, such that the tensor representation is a column-major matrix.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ForceNormalStrides" class="m-doc">ForceNormalStrides</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Copies pixel data over to a new data segment if the strides are not normal.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-ForceContiguousData" class="m-doc">ForceContiguousData</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>Copies pixel data over to a new data segment if the data is not contiguous.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Separate" class="m-doc">Separate</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>If the image shares its data segment with another image, create a data copy so it no longer
shares data.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Fill-Pixel-CL" class="m-doc">Fill</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel)</span>
            </dt>
            <dd>Sets all pixels in the image to the value <code>pixel</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Fill-Sample-CL" class="m-doc">Fill</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample)</span>
            </dt>
            <dd>Sets all samples in the image to the value <code>sample</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%3D-Pixel-CL" class="m-doc">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Sets all pixels in the image to the value <code>pixel</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%3D-Sample-CL" class="m-doc">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;</span>
            </dt>
            <dd>Sets all samples in the image to the value <code>sample</code>.</dd>
            <dt id="dip-Image-As-T-C">
              <div class="m-doc-template">template&lt;typename T, typename &lt;SFINAE&gt;&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-As-T-C" class="m-doc-self">As</a>(</span><span class="m-doc-wrap">) const -&gt; T</span>
            </dt>
            <dd>Returns the value of the first sample in the first pixel in the image as the given numeric type.</dd>
            <dt id="dip-Image-operator%20FloatArray-C">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Image-operator%20FloatArray-C" class="m-doc-self">operator FloatArray</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a></span>
            </dt>
            <dd>Returns a FloatArray containing the sample values of the first pixel in the image.
For a complex-valued image, the modulus (absolute value) is returned.</dd>
            <dt id="dip-Image-Mask-dip-Image-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-Mask-dip-Image-CL" class="m-doc-self">Mask</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; mask)</span>
            </dt>
            <dd>Sets all pixels not in <code>mask</code> to zero. <code>img.Mask(mask)</code> is equivalent to <code>img.At(~mask).Fill(0)</code>, but
without creating an intermediate copy of <code>mask</code>. Can also be expressed as <code>img *= mask</code>.</dd>
            </dl>
        </section>
        <section id="nested-classes">
          <h2>Classes</h2>
          <dl class="m-doc">
            <dt>
              class <a href="dip-Image-Sample.html" class="m-doc">Sample</a>
            </dt>
            <dd>A sample represents a single numeric value in an image, see <a href="dip-Image.html#image_representation">Image representation</a>.</dd>
            <dt>
              class <a href="dip-Image-Pixel.html" class="m-doc">Pixel</a>
            </dt>
            <dd>A pixel represents a set of numeric value in an image, see <a href="dip-Image.html#image_representation">Image representation</a>.</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              class <a href="dip-Image-CastSample-T.html" class="m-doc">CastSample</a>
            </dt>
            <dd>Derived from <a href="dip-Image-Sample.html"><code>dip::Image::Sample</code></a>, works identically except it implicitly converts to type <code>T</code>.
\relates dip::Image::Sample</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              class <a href="dip-Image-CastPixel-T.html" class="m-doc">CastPixel</a>
            </dt>
            <dd>Derived from <a href="dip-Image-Pixel.html"><code>dip::Image::Pixel</code></a>, works identically except it implicitly converts to type <code>T</code>.
\relates dip::Image::Pixel</dd>
            <dt>
              class <a href="dip-Image-View.html" class="m-doc">View</a>
            </dt>
            <dd>A view represents a subset of samples in an image. It can be assigned to to change those samples.</dd>
          </dl>
        </section>
        <section id="function-members">
          <h2>Functions</h2>
          <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Image-CopyDataToNewDataSegment" class="m-doc">CopyDataToNewDataSegment</a>(</span><span class="m-doc-wrap">) <span class="m-label m-flat m-danger">private</span></span>
            </dt>
            <dd>Allocates a new data segment and copies the data over. The image will be the same as before, but
have <a href="concepts.html#normal_strides">Normal strides</a> and not share data with another image.</dd>
          </dl>
        </section>
        <section id="related">
          <h2>Related</h2>
          <dl class="m-doc">
            <dt id="dip-ImageArray">
              using <a href="#dip-ImageArray" class="m-doc-self">dip::<wbr />ImageArray</a> = std::vector&lt;Image&gt;

            </dt>
            <dd>An array of images</dd>
            <dt id="dip-ImageRefArray">
              using <a href="#dip-ImageRefArray" class="m-doc-self">dip::<wbr />ImageRefArray</a> = std::vector&lt;std::reference_wrapper&lt;Image&gt;&gt;

            </dt>
            <dd>An array of image references</dd>
            <dt id="dip-ImageConstRefArray">
              using <a href="#dip-ImageConstRefArray" class="m-doc-self">dip::<wbr />ImageConstRefArray</a> = std::vector&lt;std::reference_wrapper&lt;const Image&gt;&gt;

            </dt>
            <dd>An array of const image references</dd>
            <dt id="dip-operator%3C%3C-std-ostream-L-Image-CL">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-operator%3C%3C-std-ostream-L-Image-CL" class="m-doc-self">dip::<wbr />operator<<</a>(</span><span class="m-doc-wrap">std::ostream&amp; os,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; img) -&gt; std::ostream&amp;</span>
            </dt>
            <dd>You can output a <a href="dip-Image.html"><code>dip::Image</code></a> to <code>std::cout</code> or any other stream. Some
information about the image is printed.</dd>
            <dt id="dip-Alias-Image-CL-Image-CL">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Alias-Image-CL-Image-CL" class="m-doc-self">dip::<wbr />Alias</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; img1,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; img2) -&gt; bool</span>
            </dt>
            <dd>Calls <code>img1.Aliases( img2 )</code>. See <a href="dip-Image.html#dip-Image-Aliases-Image-CL-C"><code>dip::Image::Aliases</code></a>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-DefineROI-Image-CL-Image-L-UnsignedArray--UnsignedArray--UnsignedArray-" class="m-doc">dip::<wbr />DefineROI</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> origin = {},
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes = {},
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> spacing = {})</span>
            </dt>
            <dd>Makes a new image object pointing to same pixel data as <code>src</code>, but
with different origin, strides and size.</dd>
            <dt id="dip-Copy-Image-CL-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Copy-Image-CL-Image-L" class="m-doc-self">dip::<wbr />Copy</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest)</span>
            </dt>
            <dd>Copies samples over from <code>src</code> to <code>dest</code>, identical to the <a href="dip-Image.html#dip-Image-Copy-Image-CL"><code>dip::Image::Copy</code></a> method.</dd>
            <dt id="dip-Copy-Image-View-CL-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Copy-Image-View-CL-Image-L" class="m-doc-self">dip::<wbr />Copy</a>(</span><span class="m-doc-wrap"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest)</span>
            </dt>
            <dd>Copies samples over from <code>src</code> to <code>dest</code>, identical to the <a href="dip-Image.html#dip-Image-Copy-Image-CL"><code>dip::Image::Copy</code></a> method.</dd>
            <dt id="dip-Copy-Image-CL-Image-View-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Copy-Image-CL-Image-View-L" class="m-doc-self">dip::<wbr />Copy</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>&amp; dest)</span>
            </dt>
            <dd>Copies samples over from <code>src</code> to <code>dest</code>, identical to the <a href="dip-Image-View.html#dip-Image-View-Copy-View-CL"><code>dip::Image::View::Copy</code></a> method.</dd>
            <dt id="dip-Copy-Image-View-CL-Image-View-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Copy-Image-View-CL-Image-View-L" class="m-doc-self">dip::<wbr />Copy</a>(</span><span class="m-doc-wrap"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a> const&amp; src,
              <a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>&amp; dest)</span>
            </dt>
            <dd>Copies samples over from <code>src</code> to <code>dest</code>, identical to the <a href="dip-Image-View.html#dip-Image-View-Copy-View-CL"><code>dip::Image::View::Copy</code></a> method.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-CopyFrom-Image-CL-Image-L-Image-CL" class="m-doc">dip::<wbr />CopyFrom</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; srcMask)</span>
            </dt>
            <dd>Copies the pixels selected by <code>srcMask</code> in <code>src</code> over to <code>dest</code>. <code>dest</code> will be a 1D image.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-CopyFrom-Image-CL-Image-L-IntegerArray-CL" class="m-doc">dip::<wbr />CopyFrom</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; srcOffsets)</span>
            </dt>
            <dd>Copies the pixels selected by <code>srcOffsets</code> over from <code>src</code> to <code>dest</code>. <code>dest</code> will be a 1D image.</dd>
            <dt id="dip-CopyTo-Image-CL-Image-L-Image-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-CopyTo-Image-CL-Image-L-Image-CL" class="m-doc-self">dip::<wbr />CopyTo</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; destMask)</span>
            </dt>
            <dd>Copies all pixels from <code>src</code> over to the pixels selected by <code>destMask</code> in <code>dest</code>. <code>dest</code> must be forged.</dd>
            <dt id="dip-CopyTo-Image-CL-Image-L-IntegerArray-CL">
              <span class="m-doc-wrap-bumper">void <a href="#dip-CopyTo-Image-CL-Image-L-IntegerArray-CL" class="m-doc-self">dip::<wbr />CopyTo</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; destOffsets)</span>
            </dt>
            <dd>Copies all pixels from <code>src</code> over to the pixels selected by <code>destOffsets</code> in <code>dest</code>. <code>dest</code> must be forged.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-ExpandTensor-Image-CL-Image-L" class="m-doc">dip::<wbr />ExpandTensor</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest)</span>
            </dt>
            <dd>Copies samples over from <code>src</code> to <code>dest</code>, expanding the tensor so it&rsquo;s a standard, column-major matrix.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Convert-Image-CL-Image-L-dip-DataType-" class="m-doc">dip::<wbr />Convert</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt)</span>
            </dt>
            <dd>Copies samples over from <code>src</code> to <code>dest</code>, with data type conversion.</dd>
            <dt id="dip-CreateImageRefArray-ImageArray-L">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-CreateImageRefArray-ImageArray-L" class="m-doc-self">dip::<wbr />CreateImageRefArray</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageArray" class="m-doc">dip::ImageArray</a>&amp; imar) -&gt; <a href="dip-Image.html#dip-ImageRefArray" class="m-doc">dip::ImageRefArray</a></span>
            </dt>
            <dd>Creates a <a href="dip-Image.html#dip-ImageRefArray"><code>dip::ImageRefArray</code></a> from a <a href="dip-Image.html#dip-ImageArray"><code>dip::ImageArray</code></a>.</dd>
            <dt id="dip-CreateImageConstRefArray-ImageArray-CL">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-CreateImageConstRefArray-ImageArray-CL" class="m-doc-self">dip::<wbr />CreateImageConstRefArray</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageArray" class="m-doc">dip::ImageArray</a> const&amp; imar) -&gt; <a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a></span>
            </dt>
            <dd>Creates a <a href="dip-Image.html#dip-ImageConstRefArray"><code>dip::ImageConstRefArray</code></a> from a <a href="dip-Image.html#dip-ImageArray"><code>dip::ImageArray</code></a>.</dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="dip-Image-operator%3D-Image-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-operator%3D-Image-CL" class="m-doc-self">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; rhs)</span></span>
            </h3>
            <p>Copy assignment</p>
<p>Copies the data if the LHS (<code>this</code>) is protected or has an external interface set, and this external
interface is different from the one in <code>rhs</code> (see <a href="dip-Image.html#protect">The &ldquo;protect&rdquo; flag</a> and <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a>).
In this case, <code>rhs</code> will not be modified.</p>
<p>Otherwise, <code>this</code> and <code>rhs</code> will share the data segment. See <a href="dip-Image.html#assignment">Creation, assignment and copy</a>.</p>
<p>The <code>protect</code> flag will not be copied over.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-operator%3D-Image-R"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-operator%3D-Image-R" class="m-doc-self">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;&amp; rhs)</span></span>
            </h3>
            <p>Move assignment</p>
<p>Copies the data if the LHS (<code>this</code>) is protected or has an external interface set, and this external
interface is different from the one in <code>rhs</code> (see <a href="dip-Image.html#protect">The &ldquo;protect&rdquo; flag</a> and <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a>).
In this case, <code>rhs</code> will not be modified. Note that this copy can throw.</p>
<p>Otherwise, <code>this</code> will become exactly what <code>rhs</code> was, and <code>rhs</code> will become raw.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-UnsignedArray--dip-uint--dip-DataType-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-UnsignedArray--dip-uint--dip-DataType-" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> tensorElems = 1,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt = DT_SFLOAT) <span class="m-label m-info">explicit</span></span></span>
            </h3>
            <p>Forged image of given sizes and data type. The data is left uninitialized.</p>
<p>Note that to call this constructor with a single parameter, you need to explicitly type the parameter,
an initializer list by itself will be considered a pixel, see the constructor below.</p>
<p>The data segment is not initialized, use <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> to set it to constant
value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-Pixel-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Pixel-CL" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel) <span class="m-label m-info">explicit</span></span></span>
            </h3>
            <p>Create a 0-D image with the data type, tensor shape, and values of <code>pixel</code>.</p>
<p>Note that <code>pixel</code> can be created through an initializer list. Thus, the following
is a valid way of creating a 0-D tensor image with 3 tensor components:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">image</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">10.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The image in the example above will be of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a>.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-Pixel-CL-dip-DataType-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Pixel-CL-dip-DataType-" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt) <span class="m-label m-info">explicit</span></span></span>
            </h3>
            <p>Create a 0-D image with data type <code>dt</code>, and tensor shape and values of <code>pixel</code>.</p>
<p>Note that <code>pixel</code> can be created through an initializer list. Thus, the following
is a valid way of creating a 0-D tensor image with 3 tensor components:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">image</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SFLOAT</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The image in the example above will be of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a>.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-Sample-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Sample-CL" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample) <span class="m-label m-info">explicit</span></span></span>
            </h3>
            <p>Create a 0-D image with the data type and value of <code>sample</code>.</p>
<p>Note that <code>sample</code> can be created by implicit cast from any numeric value. Thus, the following
are valid ways of creating a 0-D image:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">image</span><span class="p">(</span><span class="w"> </span><span class="mf">10.0f</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">complex_image</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">dcomplex</span><span class="p">(</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">));</span>
</pre></div>

<p>The images in the examples above will be of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a> and <a href="pixeltypes.html#dip-DT_DCOMPLEX"><code>dip::DT_DCOMPLEX</code></a>.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-Sample-CL-dip-DataType-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-Sample-CL-dip-DataType-" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt) <span class="m-label m-info">explicit</span></span></span>
            </h3>
            <p>Create a 0-D image with data type <code>dt</code> and value of <code>sample</code>.</p>
<p>Note that <code>sample</code> can be created by implicit cast from any numeric value. Thus, the following
is a valid way of creating a 0-D image:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">image</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SFLOAT</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>The image in the example above will be of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a>.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-FloatArray-CL-dip-DataType-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-FloatArray-CL-dip-DataType-" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a> const&amp; values,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt = DT_SFLOAT) <span class="m-label m-info">explicit</span></span></span>
            </h3>
            <p>Create a 0-D vector image with data type <code>dt</code>, and values of <code>values</code>.</p>
<p>Note that if <code>values</code> is specified as an initializer list, the constructor <a href="dip-Image.html#dip-Image-Image-Pixel-CL"><code>dip::Image::Image</code></a>
is called instead.</p>
<p>Note also that this constructor is specifically with a <code>FloatArray</code>. If the array is of type
<code>UnsignedArray</code>, a different constructor will be called, and the array will be interpreted as image
sizes, not sample values.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-DataSegment-CL-void-P-dip-DataType--UnsignedArray--IntegerArray--dip-Tensor-CL-dip-sint--dip-ExternalInterface-P"><div>
            <h3>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-DataSegment-CL-void-P-dip-DataType--UnsignedArray--IntegerArray--dip-Tensor-CL-dip-sint--dip-ExternalInterface-P" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap"><a href="imagetype.html#dip-DataSegment" class="m-doc">dip::DataSegment</a> const&amp; data,
              void* origin,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dataType,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> strides = {},
              <a href="dip-Tensor.html" class="m-doc">dip::Tensor</a> const&amp; tensor = {},
              <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> tensorStride = 1,
              <a href="dip-ExternalInterface.html" class="m-doc">dip::ExternalInterface</a>* externalInterface = nullptr)</span></span>
            </h3>
            <p>Create an image around existing data.</p>
<p><code>data</code> is a shared pointer used to manage the lifetime of the data segment.
If the image is supposed to take ownership, put a pointer to the data segment or the object
that owns it in <code>data</code>, with a deleter function that will delete the data segment or object
when the image is stripped or deleted. Otherwise, use <a href="imagetype.html#dip-NonOwnedRefToDataSegment-void-P"><code>dip::NonOwnedRefToDataSegment</code></a> to
create a shared pointer without a deleter function, implying ownership is not transferred.</p>
<p><code>origin</code> is the pointer to the first pixel. It must be a valid pointer. This is typically,
but not necessarily, the same pointer as used in <code>data</code>.</p>
<p><code>dataType</code> and <code>sizes</code> must be set appropriately. <code>strides</code> must either have the same number
of elements as <code>sizes</code>, or be an empty array. If <code>strides</code> is an empty array, <a href="concepts.html#normal_strides">Normal strides</a>
will be assumed. In this case, <code>tensorStride</code> will be ignored. <code>tensor</code> defaults to scalar
(i.e. a single tensor element). No tests will be performed on the validity of the values
passed in, except to enforce a few class invariants.</p>
<p>See <a href="dip-Image.html#external_interface">Define an image&rsquo;s allocator</a> for information about the <code>externalInterface</code> parameter.</p>
<p>See <a href="dip-Image.html#use_external_data">Create an image around existing data</a> for more information on how to use this constructor.</p>
<p>See the next constructor for a simplified interface to this constructor.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Image-T-T-CP-UnsignedArray--dip-uint-"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T, typename &lt;SFINAE&gt;&gt;
              </div>
              <span class="m-doc-wrap-bumper">
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Image-T-T-CP-UnsignedArray--dip-uint-" class="m-doc-self">Image</a>(</span><span class="m-doc-wrap">T const* data,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> nTensorElements = 1)</span></span>
            </h3>
            <p>Create an image around existing data. No ownership is transferred.</p>
<p><code>data</code> is a raw pointer to the data that will be encapsulated by the output image. <a href="concepts.html#normal_strides">Normal strides</a>
will be assumed. That is, the data is contiguous and in row-major order, with the channels interleaved.
<code>sizes</code> indicates the size of each dimension in the data, and <code>nTensorElements</code> the number of channels.
<code>data</code> must point to a buffer that is at least <code>sizes.product() * nTensorElements</code> elements long.</p>
<p>To encapsulate data in a different format, or to transfer ownership of the data to the image, see
the previous constructor.</p>
<p>See <a href="dip-Image.html#use_external_data">Create an image around existing data</a> for more information on how to use this function.</p>
<aside class="m-note m-warning">
<h4>Warning</h4>
<p>There is no way to make the data segment in an image read-only. It is possible to use this
function to create an image around const data, and then write to that data. Use images pointing to
const data only as input images!</p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Similar-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Similar-C" class="m-doc-self">Similar</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Create a new forged image similar to <code>this</code>. The data is not copied.</p>
<p>The data segment is not initialized, use <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> to set it to constant
value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Similar-dip-DataType--C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Similar-dip-DataType--C" class="m-doc-self">Similar</a>(</span><span class="m-doc-wrap"><a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt) const</span></span>
            </h3>
            <p>Create a new forged image similar to <code>this</code>, but with different data type. The data is not copied.</p>
<p>The data segment is not initialized, use <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> to set it to constant
value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-HasContiguousData-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-HasContiguousData-C" class="m-doc-self">HasContiguousData</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Test if all the pixels are contiguous.</p>
<p>If all pixels are contiguous, you can traverse the whole image,
accessing each of the pixels, using a single stride with a value
of 1. To do so, you don&rsquo;t necessarily start at the origin: if any
of the strides is negative, the origin of the contiguous data will
be elsewhere.
Use <a href="dip-Image.html#dip-Image-GetSimpleStrideAndOrigin-C"><code>dip::Image::GetSimpleStrideAndOrigin</code></a> to get a pointer to the origin
of the contiguous data.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-GetSimpleStrideAndOrigin-C"><code>dip::Image::GetSimpleStrideAndOrigin</code></a>, <a href="dip-Image.html#dip-Image-HasSimpleStride-C"><code>dip::Image::HasSimpleStride</code></a>, <a href="dip-Image.html#dip-Image-HasNormalStrides-C"><code>dip::Image::HasNormalStrides</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a>, <a href="dip-Image.html#dip-Image-Strides-C"><code>dip::Image::Strides</code></a>, <a href="dip-Image.html#dip-Image-TensorStride-C"><code>dip::Image::TensorStride</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsSingletonExpanded-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsSingletonExpanded-C" class="m-doc-self">IsSingletonExpanded</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Test if the image has been singleton expanded.</p>
<p>If any dimension is larger than 1, but has a stride of 0, it means that a single pixel is being used
across that dimension. The methods <a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a> and
<a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a> create such dimensions.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-HasContiguousData-C"><code>dip::Image::HasContiguousData</code></a>, <a href="dip-Image.html#dip-Image-HasNormalStrides-C"><code>dip::Image::HasNormalStrides</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-HasSimpleStride-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-HasSimpleStride-C" class="m-doc-self">HasSimpleStride</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Test if the whole image can be traversed with a single stride
value.</p>
<p>This is similar to <a href="dip-Image.html#dip-Image-HasContiguousData-C"><code>dip::Image::HasContiguousData</code></a>, but the stride
value can be larger than 1.
Use <a href="dip-Image.html#dip-Image-GetSimpleStrideAndOrigin-C"><code>dip::Image::GetSimpleStrideAndOrigin</code></a> to get a pointer to the origin
of the contiguous data. Note that this only tests spatial
dimensions, the tensor dimension must still be accessed separately.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-GetSimpleStrideAndOrigin-C"><code>dip::Image::GetSimpleStrideAndOrigin</code></a>, <a href="dip-Image.html#dip-Image-HasContiguousData-C"><code>dip::Image::HasContiguousData</code></a>, <a href="dip-Image.html#dip-Image-HasNormalStrides-C"><code>dip::Image::HasNormalStrides</code></a>, <a href="dip-Image.html#dip-Image-Strides-C"><code>dip::Image::Strides</code></a>, <a href="dip-Image.html#dip-Image-TensorStride-C"><code>dip::Image::TensorStride</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-GetSimpleStrideAndOrigin-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">std::pair&lt;dip::sint, void *&gt;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-GetSimpleStrideAndOrigin-C" class="m-doc-self">GetSimpleStrideAndOrigin</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Return a single stride to walk through all pixels and pointer to the start of the data.</p>
<p>If this is not possible, the function returns <code>nullptr</code> for the pointer.
Note that this only tests spatial dimensions, the tensor dimension must still be accessed separately.</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">sint</span><span class="w"> </span><span class="n">stride</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">origin</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">GetSimpleStrideAndOrigin</span><span class="p">();</span>
</pre></div>

<p>The <code>stride</code> returned is always positive.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-HasSimpleStride-C"><code>dip::Image::HasSimpleStride</code></a>, <a href="dip-Image.html#dip-Image-HasContiguousData-C"><code>dip::Image::HasContiguousData</code></a>, <a href="dip-Image.html#dip-Image-HasNormalStrides-C"><code>dip::Image::HasNormalStrides</code></a>, <a href="dip-Image.html#dip-Image-Strides-C"><code>dip::Image::Strides</code></a>, <a href="dip-Image.html#dip-Image-TensorStride-C"><code>dip::Image::TensorStride</code></a>, <a href="dip-Image.html#dip-Image-Data-C"><code>dip::Image::Data</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-HasSameDimensionOrder-Image-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-HasSameDimensionOrder-Image-CL-C" class="m-doc-self">HasSameDimensionOrder</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const</span></span>
            </h3>
            <p>Checks to see if <code>other</code> and <code>this</code> have their dimensions ordered in
the same way.</p>
<p>Traversing more than one image using simple strides is only
possible if they have their dimensions ordered in the same way, otherwise
the simple stride does not visit the pixels in the same order in the
various images.</p>
<p>The images must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-HasSimpleStride-C"><code>dip::Image::HasSimpleStride</code></a>, <a href="dip-Image.html#dip-Image-GetSimpleStrideAndOrigin-C"><code>dip::Image::GetSimpleStrideAndOrigin</code></a>, <a href="dip-Image.html#dip-Image-HasContiguousData-C"><code>dip::Image::HasContiguousData</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-PixelSize"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-PixelSize.html" class="m-doc">dip::PixelSize</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-PixelSize" class="m-doc-self">PixelSize</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Get the pixels&rsquo; size in physical units, by reference, allowing to modify it at will.</p>
<p>There are other <code>Image</code> methods that can be used to modify the pixel size, and might be
simpler. For example:</p>
<div class="m-code"><pre><span></span><span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ps</span><span class="p">;</span><span class="w">                   </span><span class="n">img</span><span class="p">.</span><span class="n">SetPixelSize</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
<span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">sz</span><span class="p">);</span><span class="w">            </span><span class="n">img</span><span class="p">.</span><span class="n">SetPixelSize</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">sz</span><span class="p">);</span>
<span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">().</span><span class="n">Clear</span><span class="p">();</span><span class="w">                </span><span class="n">img</span><span class="p">.</span><span class="n">ResetPixelSize</span><span class="p">();</span>
</pre></div>

<p>Also for querying the pixel size there are several <code>Image</code> methods:</p>
<div class="m-code"><pre><span></span><span class="n">pq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">()[</span><span class="n">dim</span><span class="p">];</span><span class="w">              </span><span class="n">pq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">(</span><span class="n">dim</span><span class="p">);</span>
<span class="n">bd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">().</span><span class="n">IsDefined</span><span class="p">();</span><span class="w">       </span><span class="n">bd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">HasPixelSize</span><span class="p">();</span>
<span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">().</span><span class="n">IsIsotropic</span><span class="p">();</span><span class="w">     </span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">IsIsotropic</span><span class="p">();</span>
<span class="n">ar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">PixelSize</span><span class="p">().</span><span class="n">AspectRatio</span><span class="p">(</span><span class="n">img</span><span class="p">.</span><span class="n">Dimensionality</span><span class="p">());</span>
<span class="w">                                        </span><span class="n">ar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">AspectRatio</span><span class="p">();</span>
</pre></div>
          </div></section>
          <section class="m-doc-details" id="dip-Image-CopyNonDataProperties-Image-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-CopyNonDataProperties-Image-CL" class="m-doc-self">CopyNonDataProperties</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src)</span></span>
            </h3>
            <p>Copy non-data image properties from <code>src</code>.</p>
<p>The non-data image properties are those that do not influence how the data is stored in
memory: tensor shape, color space, and pixel size. The number of tensor elements of the
the two images must match. The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-CopyProperties-Image-CL"><code>dip::Image::CopyProperties</code></a>, <a href="dip-Image.html#dip-Image-ResetNonDataProperties"><code>dip::Image::ResetNonDataProperties</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ResetNonDataProperties"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ResetNonDataProperties" class="m-doc-self">ResetNonDataProperties</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Reset non-data image properties.</p>
<p>The non-data image properties are those that do not influence how the data is stored in
memory: tensor shape, color space, and pixel size.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-CopyNonDataProperties-Image-CL"><code>dip::Image::CopyNonDataProperties</code></a>, <a href="dip-Image.html#dip-Image-Strip"><code>dip::Image::Strip</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Data-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void*
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Data-C" class="m-doc-self">Data</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Get pointer to the data segment.</p>
<p>This is useful to identify
the data segment, but not to access the pixel data stored in
it. Use <a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a> instead. The image must be forged.</p>
<p>The pointer returned could be tangentially related to the data segment, if
<a href="dip-Image.html#dip-Image-IsExternalData-C"><code>dip::Image::IsExternalData</code></a> is true.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a>, <a href="dip-Image.html#dip-Image-IsShared-C"><code>dip::Image::IsShared</code></a>, <a href="dip-Image.html#dip-Image-ShareCount-C"><code>dip::Image::ShareCount</code></a>, <a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-IsExternalData-C"><code>dip::Image::IsExternalData</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsShared-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsShared-C" class="m-doc-self">IsShared</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Check to see if the data segment is shared with other images.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Data-C"><code>dip::Image::Data</code></a>, <a href="dip-Image.html#dip-Image-ShareCount-C"><code>dip::Image::ShareCount</code></a>, <a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-IsExternalData-C"><code>dip::Image::IsExternalData</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ShareCount-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ShareCount-C" class="m-doc-self">ShareCount</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Get the number of images that share their data with this image.</p>
<p>For normal images the count is always at least 1. If the count is
larger than 1, <a href="dip-Image.html#dip-Image-IsShared-C"><code>dip::Image::IsShared</code></a> is true.</p>
<p>If <code>this</code> encapsulates external data (<a href="dip-Image.html#dip-Image-IsExternalData-C"><code>dip::Image::IsExternalData</code></a> is true),
then the share count is not necessarily correct, as it might not count
the uses of the source data.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Data-C"><code>dip::Image::Data</code></a>, <a href="dip-Image.html#dip-Image-IsShared-C"><code>dip::Image::IsShared</code></a>, <a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-IsExternalData-C"><code>dip::Image::IsExternalData</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-SharesData-Image-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-SharesData-Image-CL-C" class="m-doc-self">SharesData</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const</span></span>
            </h3>
            <p>Determine if <code>this</code> shares its data pointer with <code>other</code>.</p>
<p>Note that sharing the data pointer
does not imply that the two images share any pixel data, as it
is possible for the two images to represent disjoint windows
into the same data block. To determine if any pixels are shared,
use <a href="dip-Image.html#dip-Image-Aliases-Image-CL-C"><code>dip::Image::Aliases</code></a>.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Aliases-Image-CL-C"><code>dip::Image::Aliases</code></a>, <a href="dip-Image.html#dip-Image-IsIdenticalView-Image-CL-C"><code>dip::Image::IsIdenticalView</code></a>, <a href="dip-Image.html#dip-Image-IsOverlappingView-Image-CL-C"><code>dip::Image::IsOverlappingView</code></a>, <a href="dip-Image.html#dip-Image-Data-C"><code>dip::Image::Data</code></a>, <a href="dip-Image.html#dip-Image-IsShared-C"><code>dip::Image::IsShared</code></a>, <a href="dip-Image.html#dip-Image-ShareCount-C"><code>dip::Image::ShareCount</code></a>, <a href="dip-Image.html#dip-Image-IsExternalData-C"><code>dip::Image::IsExternalData</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Aliases-Image-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Aliases-Image-CL-C" class="m-doc-self">Aliases</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const</span></span>
            </h3>
            <p>Determine if <code>this</code> shares any samples with <code>other</code>.</p>
<p>If <code>true</code>, writing into this image will change the data in
<code>other</code>, and vice-versa.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-IsIdenticalView-Image-CL-C"><code>dip::Image::IsIdenticalView</code></a>, <a href="dip-Image.html#dip-Image-IsOverlappingView-Image-CL-C"><code>dip::Image::IsOverlappingView</code></a>, <a href="dip-Image.html#dip-Alias-Image-CL-Image-CL"><code>dip::Alias</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsIdenticalView-Image-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsIdenticalView-Image-CL-C" class="m-doc-self">IsIdenticalView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const</span></span>
            </h3>
            <p>Determine if <code>this</code> and <code>other</code> offer an identical view of the
same set of pixels.</p>
<p>If <code>true</code>, changing one sample in this image will change the same sample in <code>other</code>.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-Aliases-Image-CL-C"><code>dip::Image::Aliases</code></a>, <a href="dip-Image.html#dip-Image-IsOverlappingView-Image-CL-C"><code>dip::Image::IsOverlappingView</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsOverlappingView-Image-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsOverlappingView-Image-CL-C" class="m-doc-self">IsOverlappingView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; other) const</span></span>
            </h3>
            <p>Determine if <code>this</code> and <code>other</code> offer different views of the
same data segment, and share at least one sample.</p>
<p>If <code>true</code>, changing one
sample in this image might change a different sample in <code>other</code>.
An image with an overlapping view of an input image cannot be used as output to a
filter, as it might change input data that still needs to be used. Use this function
to test whether to use the existing data segment or allocate a new one.</p>
<p>Note that this function returns false if the two images offer the same view of
the same data segment.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-Aliases-Image-CL-C"><code>dip::Image::Aliases</code></a>, <a href="dip-Image.html#dip-Image-IsIdenticalView-Image-CL-C"><code>dip::Image::IsIdenticalView</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsOverlappingView-ImageConstRefArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsOverlappingView-ImageConstRefArray-CL-C" class="m-doc-self">IsOverlappingView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageConstRefArray" class="m-doc">dip::ImageConstRefArray</a> const&amp; other) const</span></span>
            </h3>
            <p>Determine if <code>this</code> and any of those in <code>other</code> offer different views of the
same data segment, and share at least one sample.</p>
<p>If <code>true</code>, changing one
sample in this image might change a different sample in at least one image in <code>other</code>.
An image with an overlapping view of an input image cannot be used as output to a
filter, as it might change input data that still needs to be used. Use this function
to test whether to use the existing data segment or allocate a new one.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-Aliases-Image-CL-C"><code>dip::Image::Aliases</code></a>, <a href="dip-Image.html#dip-Image-IsIdenticalView-Image-CL-C"><code>dip::Image::IsIdenticalView</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsOverlappingView-ImageArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsOverlappingView-ImageArray-CL-C" class="m-doc-self">IsOverlappingView</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html#dip-ImageArray" class="m-doc">dip::ImageArray</a> const&amp; other) const</span></span>
            </h3>
            <p>Determine if <code>this</code> and any of those in <code>other</code> offer different views of the</p>
<p>same data segment, and share at least one sample.</p>
<p>If <code>true</code>, changing one
sample in this image might change a different sample in at least one image in <code>other</code>.
An image with an overlapping view of an input image cannot be used as output to a
filter, as it might change input data that still needs to be used. Use this function
to test whether to use the existing data segment or allocate a new one.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-SharesData-Image-CL-C"><code>dip::Image::SharesData</code></a>, <a href="dip-Image.html#dip-Image-Aliases-Image-CL-C"><code>dip::Image::Aliases</code></a>, <a href="dip-Image.html#dip-Image-IsIdenticalView-Image-CL-C"><code>dip::Image::IsIdenticalView</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Forge"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Forge" class="m-doc-self">Forge</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Allocate data segment.</p>
<p>This function allocates a memory block
to hold the pixel data. If the stride array is consistent with
size array, and leads to a compact data segment, it is honored.
Otherwise, it is ignored and a new stride array is created that
leads to an image that has <a href="concepts.html#normal_strides">Normal strides</a>. If an
external interface is registered for this image, that interface
may create whatever strides are suitable, may honor or not the
existing stride array, and may or may not produce normal strides.</p>
<p>The data segment is not initialized, use <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> to set it to constant
value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ReForge-Image-CL-Option-AcceptDataTypeChange-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ReForge-Image-CL-Option-AcceptDataTypeChange-" class="m-doc-self">ReForge</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="supporttypes.html#dip-Option-AcceptDataTypeChange" class="m-doc">dip::Option::AcceptDataTypeChange</a> acceptDataTypeChange = Option::AcceptDataTypeChange::DONT_ALLOW)</span></span>
            </h3>
            <p>Modify image properties and forge the image.</p>
<p><code>ReForge</code> has three
signatures that match three image constructors. <code>ReForge</code> will try
to avoid freeing the current data segment and allocating a new one.
This version will cause <code>this</code> to be an identical copy of <code>src</code>,
but with uninitialized data. The external interface of <code>src</code> is
not used, nor are its strides.</p>
<p>If <code>this</code> doesn&rsquo;t match the requested properties, it must be stripped
and forged. If <code>this</code> is protected (see <a href="dip-Image.html#dip-Image-Protect-bool-"><code>dip::Image::Protect</code></a>) and
forged, an exception will be thrown by <a href="dip-Image.html#dip-Image-Strip"><code>dip::Image::Strip</code></a>. However,
if <code>acceptDataTypeChange</code> is <a href="supporttypes.html#dip-Option-AcceptDataTypeChange-DO_ALLOW"><code>dip::Option::AcceptDataTypeChange::DO_ALLOW</code></a>,
a protected image will keep its
old data type, and no exception will be thrown if this data type
is different from <code>dt</code>. Note that other properties much still match
if <code>this</code> was forged. Thus, this flag allows <code>this</code> to control the
data type of the image, ignoring any requested data type here.</p>
<p>The data segment is not initialized, use <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> to set it to constant
value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ReForge-Image-CL-dip-DataType--Option-AcceptDataTypeChange-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ReForge-Image-CL-dip-DataType--Option-AcceptDataTypeChange-" class="m-doc-self">ReForge</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt,
              <a href="supporttypes.html#dip-Option-AcceptDataTypeChange" class="m-doc">dip::Option::AcceptDataTypeChange</a> acceptDataTypeChange = Option::AcceptDataTypeChange::DONT_ALLOW)</span></span>
            </h3>
            <p>Modify image properties and forge the image.</p>
<p><code>ReForge</code> has three
signatures that match three image constructors. <code>ReForge</code> will try
to avoid freeing the current data segment and allocating a new one.
This version will cause <code>this</code> to be an identical copy of <code>src</code>,
but with a different data type and uninitialized data. The
external interface of <code>src</code> is not used, nor are its strides.</p>
<p>If <code>this</code> doesn&rsquo;t match the requested properties, it must be stripped
and forged. If <code>this</code> is protected (see <a href="dip-Image.html#dip-Image-Protect-bool-"><code>dip::Image::Protect</code></a>) and
forged, an exception will be thrown by <a href="dip-Image.html#dip-Image-Strip"><code>dip::Image::Strip</code></a>. However,
if <code>acceptDataTypeChange</code> is <a href="supporttypes.html#dip-Option-AcceptDataTypeChange-DO_ALLOW"><code>dip::Option::AcceptDataTypeChange::DO_ALLOW</code></a>,
a protected image will keep its
old data type, and no exception will be thrown if this data type
is different from <code>dt</code>. Note that other properties much still match
if <code>this</code> was forged. Thus, this flag allows <code>this</code> to control the
data type of the image, ignoring any requested data type here.</p>
<p>The data segment is not initialized, use <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> to set it to constant
value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ReForge-UnsignedArray-CL-dip-uint--dip-DataType--Option-AcceptDataTypeChange-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ReForge-UnsignedArray-CL-dip-uint--dip-DataType--Option-AcceptDataTypeChange-" class="m-doc-self">ReForge</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> tensorElems = 1,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt = DT_SFLOAT,
              <a href="supporttypes.html#dip-Option-AcceptDataTypeChange" class="m-doc">dip::Option::AcceptDataTypeChange</a> acceptDataTypeChange = Option::AcceptDataTypeChange::DONT_ALLOW)</span></span>
            </h3>
            <p>Modify image properties and forge the image.</p>
<p><code>ReForge</code> has three
signatures that match three image constructors. <code>ReForge</code> will try
to avoid freeing the current data segment and allocating a new one.
This version will cause <code>this</code> to be of the requested sizes and
data type.</p>
<p>If <code>this</code> doesn&rsquo;t match the requested properties, it must be stripped
and forged. If <code>this</code> is protected (see <a href="dip-Image.html#dip-Image-Protect-bool-"><code>dip::Image::Protect</code></a>) and
forged, an exception will be thrown by <a href="dip-Image.html#dip-Image-Strip"><code>dip::Image::Strip</code></a>. However,
if <code>acceptDataTypeChange</code> is <a href="supporttypes.html#dip-Option-AcceptDataTypeChange-DO_ALLOW"><code>dip::Option::AcceptDataTypeChange::DO_ALLOW</code></a>,
a protected image will keep its
old data type, and no exception will be thrown if this data type
is different from <code>dt</code>. Note that other properties much still match
if <code>this</code> was forged. Thus, this flag allows <code>this</code> to control the
data type of the image, ignoring any requested data type here.</p>
<p>The data segment is not initialized, use <a href="dip-Image.html#dip-Image-Fill-Pixel-CL"><code>dip::Image::Fill</code></a> to set it to constant
value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Protect-bool-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Protect-bool-" class="m-doc-self">Protect</a>(</span><span class="m-doc-wrap">bool set = true)</span></span>
            </h3>
            <p>Set protection flag.</p>
<p>A protected image cannot be stripped or reforged. See <a href="dip-Image.html#protect">The &ldquo;protect&rdquo; flag</a> for more information.</p>
<p>Returns the old setting. This can be used as follows to temporarily
protect an image:</p>
<div class="m-code"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">wasProtected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Protect</span><span class="p">();</span>
<span class="p">[...]</span><span class="w"> </span><span class="c1">// do your thing</span>
<span class="n">img</span><span class="p">.</span><span class="n">Protect</span><span class="p">(</span><span class="w"> </span><span class="n">wasProtected</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Unprotect"><code>dip::Image::Unprotect</code></a>, <a href="dip-Image.html#dip-Image-IsProtected-C"><code>dip::Image::IsProtected</code></a>, <a href="dip-Image.html#dip-Image-Strip"><code>dip::Image::Strip</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Pointer-dip-sint--C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void*
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Pointer-dip-sint--C" class="m-doc-self">Pointer</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> offset) const</span></span>
            </h3>
            <p>Get a pointer to the pixel given by the offset.</p>
<p>Cast the pointer to the right type before use. No check is made on the index.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a>, <a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Pointer-UnsignedArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void*
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Pointer-UnsignedArray-CL-C" class="m-doc-self">Pointer</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const</span></span>
            </h3>
            <p>Get a pointer to the pixel given by the coordinates index.</p>
<p>Cast the
pointer to the right type before use. This is not the most efficient
way of indexing many pixels in the image.</p>
<p>If <code>coords</code> is not within the image domain, an exception is thrown.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a>, <a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Pointer-IntegerArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void*
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Pointer-IntegerArray-CL-C" class="m-doc-self">Pointer</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; coords) const</span></span>
            </h3>
            <p>Get a pointer to the pixel given by the coordinates index.</p>
<p>Cast the
pointer to the right type before use. This is not the most efficient
way of indexing many pixels in the image.</p>
<p><code>coords</code> can be outside the image domain.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a>, <a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsOnEdge-UnsignedArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsOnEdge-UnsignedArray-CL-C" class="m-doc-self">IsOnEdge</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const</span></span>
            </h3>
            <p>Return true if the coordinates are on the image edge.</p>
<p>Coordinates on the image edge are such that at least one neighboring coordinates
(direct neighbor) is outside the image domain.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">static <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL" class="m-doc-self">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; strides,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes)</span></span>
            </h3>
            <p>Compute offset given coordinates and strides.</p>
<p>The offset needs to be multiplied by the number of bytes of each sample to become
a memory offset within the image.</p>
<p>If <code>coords</code> is not within the domain given by <code>sizes</code>, an exception is thrown.
The size of <code>coords</code> is not verified.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Offset-IntegerArray-CL-IntegerArray-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">static <a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Offset-IntegerArray-CL-IntegerArray-CL" class="m-doc-self">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; coords,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; strides)</span></span>
            </h3>
            <p>Compute offset given coordinates.</p>
<p>The offset needs to be multiplied by the number of bytes of each sample to become
a memory offset within the image.</p>
<p><code>coords</code> can have negative values, no domain assumptions are made.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Offset-UnsignedArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Offset-UnsignedArray-CL-C" class="m-doc-self">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const</span></span>
            </h3>
            <p>Compute offset given coordinates.</p>
<p>The offset needs to be multiplied by the number of bytes of each sample to become
a memory offset within the image.</p>
<p>If <code>coords</code> is not within the image domain, an exception is thrown.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a>, <a href="dip-Image.html#dip-Image-Pointer-dip-sint--C"><code>dip::Image::Pointer</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Offset-IntegerArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Offset-IntegerArray-CL-C" class="m-doc-self">Offset</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; coords) const</span></span>
            </h3>
            <p>Compute offset given coordinates.</p>
<p>The offset needs to be multiplied by the number of bytes of each sample to become
a memory offset within the image.</p>
<p><code>coords</code> can be outside the image domain.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Origin-C"><code>dip::Image::Origin</code></a>, <a href="dip-Image.html#dip-Image-Pointer-dip-sint--C"><code>dip::Image::Pointer</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-OffsetToCoordinates-dip-sint--C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-OffsetToCoordinates-dip-sint--C" class="m-doc-self">OffsetToCoordinates</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> offset) const</span></span>
            </h3>
            <p>Compute coordinates given an offset.</p>
<p>If the image has any singleton-expanded
dimensions, the computed coordinate along that dimension will always be 0.
This is an expensive operation, use <a href="dip-Image.html#dip-Image-OffsetToCoordinatesComputer-C"><code>dip::Image::OffsetToCoordinatesComputer</code></a> to make it
more efficient when performing multiple computations in sequence.</p>
<p>Note that the coordinates must be inside the image domain, if the offset given
does not correspond to one of the image&rsquo;s pixels, the result is meaningless.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinatesComputer-C"><code>dip::Image::OffsetToCoordinatesComputer</code></a>, <a href="dip-Image.html#dip-Image-IndexToCoordinates-dip-uint--C"><code>dip::Image::IndexToCoordinates</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-OffsetToCoordinatesComputer-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="imagetype.html#dip-CoordinatesComputer" class="m-doc">dip::CoordinatesComputer</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-OffsetToCoordinatesComputer-C" class="m-doc-self">OffsetToCoordinatesComputer</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Returns a functor that computes coordinates given an offset.</p>
<p>This is
more efficient than using <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a> when repeatedly
computing offsets, but still requires complex calculations.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a>, <a href="dip-Image.html#dip-Image-IndexToCoordinates-dip-uint--C"><code>dip::Image::IndexToCoordinates</code></a>, <a href="dip-Image.html#dip-Image-IndexToCoordinatesComputer-C"><code>dip::Image::IndexToCoordinatesComputer</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Index-UnsignedArray-CL-UnsignedArray-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">static <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Index-UnsignedArray-CL-UnsignedArray-CL" class="m-doc-self">Index</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes)</span></span>
            </h3>
            <p>Compute linear index (not offset) given coordinates and image sizes.</p>
<p>This index is not related to the position of the pixel in memory, and should not be
used to index many pixels in sequence.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Index-UnsignedArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Index-UnsignedArray-CL-C" class="m-doc-self">Index</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; coords) const</span></span>
            </h3>
            <p>Compute linear index (not offset) given coordinates.</p>
<p>This index is not related to the position of the pixel in memory, and should not be
used to index many pixels in sequence.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-IndexToCoordinates-dip-uint--C"><code>dip::Image::IndexToCoordinates</code></a>, <a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IndexToCoordinates-dip-uint--C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IndexToCoordinates-dip-uint--C" class="m-doc-self">IndexToCoordinates</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> index) const</span></span>
            </h3>
            <p>Compute coordinates given a linear index.</p>
<p>If the image has any singleton-expanded
dimensions, the computed coordinate along that dimension will always be 0.
This is an expensive operation, use <a href="dip-Image.html#dip-Image-IndexToCoordinatesComputer-C"><code>dip::Image::IndexToCoordinatesComputer</code></a> to make it
more efficient when performing multiple computations in sequence.</p>
<p>Note that the coordinates must be inside the image domain, if the index given
does not correspond to one of the image&rsquo;s pixels, the result is meaningless.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Index-UnsignedArray-CL-UnsignedArray-CL"><code>dip::Image::Index</code></a>, <a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a>, <a href="dip-Image.html#dip-Image-IndexToCoordinatesComputer-C"><code>dip::Image::IndexToCoordinatesComputer</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IndexToCoordinatesComputer-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="imagetype.html#dip-CoordinatesComputer" class="m-doc">dip::CoordinatesComputer</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IndexToCoordinatesComputer-C" class="m-doc-self">IndexToCoordinatesComputer</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Returns a functor that computes coordinates given a linear index.</p>
<p>This is
more efficient than using <a href="dip-Image.html#dip-Image-IndexToCoordinates-dip-uint--C"><code>dip::Image::IndexToCoordinates</code></a>, when repeatedly
computing indices, but still requires complex calculations.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Index-UnsignedArray-CL-UnsignedArray-CL"><code>dip::Image::Index</code></a>, <a href="dip-Image.html#dip-Image-Offset-UnsignedArray-CL-IntegerArray-CL-UnsignedArray-CL"><code>dip::Image::Offset</code></a>, <a href="dip-Image.html#dip-Image-IndexToCoordinates-dip-uint--C"><code>dip::Image::IndexToCoordinates</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinates-dip-sint--C"><code>dip::Image::OffsetToCoordinates</code></a>, <a href="dip-Image.html#dip-Image-OffsetToCoordinatesComputer-C"><code>dip::Image::OffsetToCoordinatesComputer</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-GetCenter-String-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="supporttypes.html#dip-FloatArray" class="m-doc">dip::FloatArray</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-GetCenter-String-CL-C" class="m-doc-self">GetCenter</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; mode = "right") const</span></span>
            </h3>
            <p>Returns the coordinates for the center of the image.</p>
<p><code>mode</code> specifies the origin of the coordinates. It can be one of the following strings:</p>
<ul>
<li><code>"right"</code>: The origin is on the pixel right of the center (at integer division result of
  <code>size/2</code>). This is the default.</li>
<li><code>"left"</code>: The origin is on the pixel left of the center (at integer division result of
  <code>(size-1)/2</code>).</li>
<li><code>"true"</code>: The origin is halfway the first and last pixel, in between pixels if necessary
  (at floating-point division result of <code>size/2</code>).</li>
<li><code>"corner"</code>: The origin is on the first pixel.</li>
<li><code>"frequency"</code>: The coordinates used are as for the Fourier transform. Same results as
  for <code>"right"</code>.</li>
</ul>
          </div></section>
          <section class="m-doc-details" id="dip-Image-PermuteDimensions-UnsignedArray-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-PermuteDimensions-UnsignedArray-CL" class="m-doc-self">PermuteDimensions</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; order)</span></span>
            </h3>
            <p>Permute dimensions.</p>
<p>This function allows to re-arrange the dimensions
of the image in any order. It also allows to remove singleton dimensions
(but not to add them, should we add that? how?). For example, given
an image with size <code>{ 30, 1, 50 }</code>, and an <code>order</code> array of
<code>{ 2, 0 }</code>, the image will be modified to have size <code>{ 50, 30 }</code>.
Dimension number 1 is not referenced, and was removed (this can only
happen if the dimension has size 1, otherwise an exception will be
thrown!). Dimension 2 was placed first, and dimension 0 was placed second.</p>
<p>The image must be forged. If it is not, you can simply assign any
new sizes array through Image::SetSizes. The data will never
be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-SwapDimensions-dip-uint--dip-uint-"><code>dip::Image::SwapDimensions</code></a>, <a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a>, <a href="dip-Image.html#dip-Image-AddSingleton-dip-uint-"><code>dip::Image::AddSingleton</code></a>, <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a>, <a href="dip-Image.html#dip-Image-Flatten"><code>dip::Image::Flatten</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-SwapDimensions-dip-uint--dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-SwapDimensions-dip-uint--dip-uint-" class="m-doc-self">SwapDimensions</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim1,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim2)</span></span>
            </h3>
            <p>Swap dimensions d1 and d2. This is a simplified version of <code>PermuteDimensions</code>.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Flatten"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Flatten" class="m-doc-self">Flatten</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Make image 1D.</p>
<p>The image must be forged. If HasSimpleStride,
this is a quick and cheap operation, but if not, the data segment
will be copied. Note that the order of the pixels in the
resulting image depend on the strides, and do not necessarily
follow the same order as linear indices.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-FlattenAsMuchAsPossible"><code>dip::Image::FlattenAsMuchAsPossible</code></a>, <a href="dip-Image.html#dip-Image-SplitDimension-dip-uint--dip-uint-"><code>dip::Image::SplitDimension</code></a>, <a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-FlattenAsMuchAsPossible"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-FlattenAsMuchAsPossible" class="m-doc-self">FlattenAsMuchAsPossible</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Make image have as few dimensions as possible.</p>
<p>If the image has contiguous storage (or non-contiguous storage with a simple stride), then
<a href="dip-Image.html#dip-Image-Flatten"><code>dip::Image::Flatten</code></a> will convert it into a 1D image without copy. This method performs a similar
function, but only merges the dimensions that are possible to merge without data copy. In the
cases where <code>dip::Image::Flatten</code> doesn&rsquo;t copy data, this method will yield the same result. In
other cases, the output of this method will yield an image with more than one dimension, sometimes
as many as the input image. Dimensions can be reordered and reversed.</p>
<p>The goal with reducing dimensions is to make it simpler to iterate through the image. Iterators
will be more efficient on a flattened image.</p>
<p>The image must be forged. This is always a quick and cheap operation.
Note that the order of the pixels in the resulting image depend on the strides, and do not necessarily
follow the same order as linear indices.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Flatten"><code>dip::Image::Flatten</code></a>, <a href="dip-Image.html#dip-Image-SplitDimension-dip-uint--dip-uint-"><code>dip::Image::SplitDimension</code></a>, <a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-SplitDimension-dip-uint--dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-SplitDimension-dip-uint--dip-uint-" class="m-doc-self">SplitDimension</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> size)</span></span>
            </h3>
            <p>Splits a dimension into two.</p>
<p>Splits dimension <code>dim</code> into two: one with size <code>size</code>, and one with size <code>Size( dim ) / size</code>. The two
new dimensions will be at <code>dim</code> and <code>dim + 1</code>, moving the previous <code>dim + 1</code> and subsequent dimensions
over by one. <code>Size( dim )</code> must be evenly divisible by <code>size</code> for this to work, an exception will be
thrown if this is not the case.</p>
<p>After this call, the image will have the same number of pixels, stored identically (no copy is made),
but one more dimension. For example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="nf">image</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">43</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="n">image</span><span class="p">.</span><span class="n">SplitDimension</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">Sizes</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// should print { 43, 32, 16, 21 }</span>
</pre></div>

<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Flatten"><code>dip::Image::Flatten</code></a>, <a href="dip-Image.html#dip-Image-FlattenAsMuchAsPossible"><code>dip::Image::FlattenAsMuchAsPossible</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Squeeze-UnsignedArray-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Squeeze-UnsignedArray-L" class="m-doc-self">Squeeze</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a>&amp; dims)</span></span>
            </h3>
            <p>Remove singleton dimensions (dimensions with size==1).</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<p><code>dims</code> will be modified to contain the dimensions that were removed. <code>AddSingleton</code> can be
used with <code>dims</code> to recover the original image sizes.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-AddSingleton-dip-uint-"><code>dip::Image::AddSingleton</code></a>, <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a>, <a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonDimensions"><code>dip::Image::UnexpandSingletonDimensions</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Squeeze"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Squeeze" class="m-doc-self">Squeeze</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Remove singleton dimensions (dimensions with size==1).</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-AddSingleton-dip-uint-"><code>dip::Image::AddSingleton</code></a>, <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a>, <a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonDimensions"><code>dip::Image::UnexpandSingletonDimensions</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Squeeze-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Squeeze-dip-uint-" class="m-doc-self">Squeeze</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim)</span></span>
            </h3>
            <p>Remove singleton dimension <code>dim</code> (has size==1).</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a>, <a href="dip-Image.html#dip-Image-AddSingleton-dip-uint-"><code>dip::Image::AddSingleton</code></a>, <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a>, <a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonDimensions"><code>dip::Image::UnexpandSingletonDimensions</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-AddSingleton-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-AddSingleton-dip-uint-" class="m-doc-self">AddSingleton</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim)</span></span>
            </h3>
            <p>Add a singleton dimension (with size==1) to the image.</p>
<p>Dimensions <code>dim</code> to last are shifted up, dimension <code>dim</code> will have a size of 1.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<p>Example: to an image with sizes <code>{ 4, 5, 6 }</code> we add a
singleton dimension <code>dim == 1</code>. The image will now have
sizes <code>{ 4, 1, 5, 6 }</code>.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a>, <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a>, <a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-AddSingleton-UnsignedArray-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-AddSingleton-UnsignedArray-CL" class="m-doc-self">AddSingleton</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; dims)</span></span>
            </h3>
            <p>Add a singleton dimensions (with size==1) to the image.</p>
<p>The elements of <code>dims</code> will be applied in order.
Dimensions <code>dims[ii]</code> to last are shifted up, dimension <code>dim[ii]</code> will have a size of 1.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a>, <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a>, <a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ExpandDimensionality-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ExpandDimensionality-dip-uint-" class="m-doc-self">ExpandDimensionality</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim)</span></span>
            </h3>
            <p>Append singleton dimensions to increase the image dimensionality.</p>
<p>The image will have <code>n</code> dimensions. However, if the image already
has <code>n</code> or more dimensions, nothing happens.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-AddSingleton-dip-uint-"><code>dip::Image::AddSingleton</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a>, <a href="dip-Image.html#dip-Image-PermuteDimensions-UnsignedArray-CL"><code>dip::Image::PermuteDimensions</code></a>, <a href="dip-Image.html#dip-Image-Flatten"><code>dip::Image::Flatten</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-" class="m-doc-self">ExpandSingletonDimension</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> sz)</span></span>
            </h3>
            <p>Expand singleton dimension <code>dim</code> to <code>sz</code> pixels, setting the corresponding stride to 0.</p>
<p>If <code>dim</code> is not a singleton dimension (size==1), an exception is thrown.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-ExpandSingletonDimensions-UnsignedArray-CL"><code>dip::Image::ExpandSingletonDimensions</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonDimension-dip-uint-"><code>dip::Image::UnexpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonDimensions"><code>dip::Image::UnexpandSingletonDimensions</code></a>, <a href="dip-Image.html#dip-Image-AddSingleton-dip-uint-"><code>dip::Image::AddSingleton</code></a>, <a href="dip-Image.html#dip-Image-ExpandDimensionality-dip-uint-"><code>dip::Image::ExpandDimensionality</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ExpandSingletonDimensions-UnsignedArray-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ExpandSingletonDimensions-UnsignedArray-CL" class="m-doc-self">ExpandSingletonDimensions</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; newSizes)</span></span>
            </h3>
            <p>Performs singleton expansion.</p>
<p>The image is modified so that it has <code>size</code>
as dimensions. It must be forged and singleton-expandable to <code>size</code>,
otherwise an exception is thrown. See <a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>.
<code>size</code> is the array as returned by <a href="frameworks.html#dip-Framework-SingletonExpandedSize-UnsignedArray-L-UnsignedArray-CL"><code>dip::Framework::SingletonExpandedSize</code></a>.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonDimensions"><code>dip::Image::UnexpandSingletonDimensions</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-UnexpandSingletonDimensions"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-UnexpandSingletonDimensions" class="m-doc-self">UnexpandSingletonDimensions</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Unexpands singleton-expanded dimensions.</p>
<p>The image is modified so that each singleton-expanded dimension has a size of 1, including the tensor
dimension. That is, the resulting image will no longer be <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a>.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-UnexpandSingletonDimension-dip-uint-"><code>dip::Image::UnexpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a>, <a href="dip-Image.html#dip-Image-Squeeze-UnsignedArray-L"><code>dip::Image::Squeeze</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-UnexpandSingletonDimension-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-UnexpandSingletonDimension-dip-uint-" class="m-doc-self">UnexpandSingletonDimension</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim)</span></span>
            </h3>
            <p>Unexpands a singleton-expanded dimension.</p>
<p>The image is modified so that the singleton-expanded dimension <code>dim</code> has a size of 1. That is,
this dimension will no longer be singleton-expanded.
If <code>dim</code> was not singleton-expanded, throws an exception.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-IsSingletonExpansionPossible-UnsignedArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-IsSingletonExpansionPossible-UnsignedArray-CL-C" class="m-doc-self">IsSingletonExpansionPossible</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; newSizes) const</span></span>
            </h3>
            <p>Tests if the image can be singleton-expanded to <code>size</code>.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-ExpandSingletonDimensions-UnsignedArray-CL"><code>dip::Image::ExpandSingletonDimensions</code></a>, <a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ExpandSingletonTensor-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ExpandSingletonTensor-dip-uint-" class="m-doc-self">ExpandSingletonTensor</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> sz)</span></span>
            </h3>
            <p>Expand singleton tensor dimension <code>sz</code> samples, setting the tensor stride to 0.</p>
<p>If there is more than one tensor element, an exception is thrown.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-ExpandSingletonDimension-dip-uint--dip-uint-"><code>dip::Image::ExpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonTensor"><code>dip::Image::UnexpandSingletonTensor</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-UnexpandSingletonTensor"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-UnexpandSingletonTensor" class="m-doc-self">UnexpandSingletonTensor</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Unexpands the singleton-expanded tensor dimension.</p>
<p>Undoes the effect of <a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a>. If the tensor dimension was not
singleton-expanded, throws an exception.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-ExpandSingletonTensor-dip-uint-"><code>dip::Image::ExpandSingletonTensor</code></a>, <a href="dip-Image.html#dip-Image-UnexpandSingletonDimension-dip-uint-"><code>dip::Image::UnexpandSingletonDimension</code></a>, <a href="dip-Image.html#dip-Image-IsSingletonExpanded-C"><code>dip::Image::IsSingletonExpanded</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Mirror-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Mirror-dip-uint-" class="m-doc-self">Mirror</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension)</span></span>
            </h3>
            <p>Mirror the image about a single axes.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Mirror-BooleanArray-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Mirror-BooleanArray-" class="m-doc-self">Mirror</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-BooleanArray" class="m-doc">dip::BooleanArray</a> process = {})</span></span>
            </h3>
            <p>Mirror the image about selected axes.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
<p><code>process</code> indicates which axes to mirror. If <code>process</code> is an empty array, all
axes will be mirrored.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Rotation90-dip-sint--dip-uint--dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Rotation90-dip-sint--dip-uint--dip-uint-" class="m-doc-self">Rotation90</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> n,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension1,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dimension2)</span></span>
            </h3>
            <p>Rotates the image by <code>n</code> times 90 degrees, in the plane defined by dimensions
<code>dimension1</code> and <code>dimension2</code>.</p>
<p>The image must be forged, and have at least two dimensions.
The data will never be copied (i.e. this is a quick and cheap operation).</p>
<p>The rotation occurs in the direction of positive angles, as defined in the image coordinate system.
That is, if <code>dimension1</code> is 0 (x-axis) and <code>dimension2</code> is 1 (y-axis), and considering the y-axis is
positive in the down direction, then the rotation happens in clockwise direction. A negative
value for <code>n</code> inverts the direction of rotation.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Rotation90-dip-sint--dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Rotation90-dip-sint--dip-uint-" class="m-doc-self">Rotation90</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> n,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> axis)</span></span>
            </h3>
            <p>Rotates the 3D image by <code>n</code> times 90 degrees, in the plane perpendicular to dimension <code>axis</code>.</p>
<p>The image must be forged and have three dimensions. The data will never be copied
(i.e. this is a quick and cheap operation).</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Rotation90-dip-sint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Rotation90-dip-sint-" class="m-doc-self">Rotation90</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-sint" class="m-doc">dip::sint</a> n = 1)</span></span>
            </h3>
            <p>Rotates the image by <code>n</code> times 90 degrees, in the x-y plane.</p>
<p>The image must be forged. The data will never be copied (i.e. this is a quick and cheap operation).</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-StandardizeStrides"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-StandardizeStrides" class="m-doc-self">StandardizeStrides</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Undo the effects of <code>Mirror</code>, <code>Rotation90</code>, <code>PermuteDimensions</code>, and singleton expansion.
Also removes singleton dimensions.</p>
<p>Modifies the image such that all strides are positive and sorted smaller to larger. The first
dimension will have the smallest stride. Visiting pixels in linear indexing order (as is done
through <a href="dip-ImageIterator-T.html"><code>dip::ImageIterator</code></a>) will be most efficient after calling this function.</p>
<p>Note that strides are not necessarily normal after this call, if the image is a view over a
larger image, if singleton dimensions were created or expanded, etc. Use <code>ForceNormalStrides</code>
to ensure that strides are normal.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-StandardizeStrides-IntegerArray-L-UnsignedArray-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">static std::pair&lt;UnsignedArray, dip::sint&gt;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-StandardizeStrides-IntegerArray-L-UnsignedArray-L" class="m-doc-self">StandardizeStrides</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a>&amp; strides,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a>&amp; sizes)</span></span>
            </h3>
            <p>Transforms input arrays and outputs ordering required to standardize an image&rsquo;s strides.</p>
<p><code>strides</code> and <code>sizes</code> are modified such that any negative strides (mirrored image dimensions) become
positive, and expanded singleton dimensions become singletons again.</p>
<p>The output array can be used to permute the <code>strides</code> and the <code>sizes</code> arrays to reorder image dimensions
such that linear indices match storage order.</p>
<p>The output signed integer is the offset that needs to be applied to the origin to account for any
image dimensions that were reversed.</p>
<p>The non-static <code>Image</code> method with the same name uses this function to standardize the strides of
the image:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">UnsignedArray</span><span class="w"> </span><span class="n">order</span><span class="p">;</span>
<span class="n">dip</span><span class="o">::</span><span class="n">sint</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="o">::</span><span class="n">StandardizeStrides</span><span class="p">(</span><span class="w"> </span><span class="n">strides</span><span class="p">,</span><span class="w"> </span><span class="n">sizes</span><span class="w"> </span><span class="p">);</span>
<span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="n">sizes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sizes</span><span class="p">.</span><span class="n">permute</span><span class="p">(</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="p">);</span>
<span class="n">strides</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strides</span><span class="p">.</span><span class="n">permute</span><span class="p">(</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p><code>sizes</code> and <code>strides</code> are assumed to be of the same length, this is not tested for.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-TensorToSpatial-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-TensorToSpatial-dip-uint-" class="m-doc-self">TensorToSpatial</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim)</span></span>
            </h3>
            <p>Convert tensor dimensions to spatial dimension.</p>
<p>Works even for scalar images, creating a singleton dimension. <code>dim</code>
defines the new dimension, subsequent dimensions will be shifted over.
<code>dim</code> should not be larger than the number of dimensions. <code>dim</code>
defaults to the image dimensionality, meaning that the new dimension will
be the last one. The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-SpatialToTensor-dip-uint--dip-uint--dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-SpatialToTensor-dip-uint--dip-uint--dip-uint-" class="m-doc-self">SpatialToTensor</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> rows,
              <a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> cols)</span></span>
            </h3>
            <p>Convert spatial dimension to tensor dimensions. The image must be scalar.</p>
<p>If <code>rows</code> or <code>cols</code> is zero, its size is computed from the size of the
image along dimension <code>dim</code>. If both are zero (or not given), a default column tensor
is created. <code>dim</code> defaults to the last spatial dimension. The image must
be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-SplitComplex-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-SplitComplex-dip-uint-" class="m-doc-self">SplitComplex</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim)</span></span>
            </h3>
            <p>Split the two values in a complex sample into separate samples,
creating a new spatial dimension of size 2.</p>
<p><code>dim</code> defines the new
dimension, subsequent dimensions will be shifted over. <code>dim</code> should
not be larger than the number of dimensions. <code>dim</code> defaults to the
image dimensionality, meaning that the new dimension will be the last one.
The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-MergeComplex-dip-uint-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-MergeComplex-dip-uint-" class="m-doc-self">MergeComplex</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-uint" class="m-doc">dip::uint</a> dim)</span></span>
            </h3>
            <p>Merge the two samples along dimension <code>dim</code> into a single complex-valued sample.</p>
<p>Dimension <code>dim</code> must have size 2 and a stride of 1. <code>dim</code> defaults to the last
spatial dimension. The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-MergeTensorToComplex"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-MergeTensorToComplex" class="m-doc-self">MergeTensorToComplex</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Merge the two samples in the tensor into a single complex-valued sample.</p>
<p>The image must have two tensor elements, a tensor stride of 1, and be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ReinterpretCast-dip-DataType-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ReinterpretCast-dip-DataType-" class="m-doc-self">ReinterpretCast</a>(</span><span class="m-doc-wrap"><a href="dip-DataType.html" class="m-doc">dip::DataType</a> dataType)</span></span>
            </h3>
            <p>Changes the data type of <code>this</code> without changing or copying the data.</p>
<p>If the target <code>dataType</code> is smaller than the source data type, then the spatial dimension
that has a stride of 1 will grow (for example, casting from 32-bit integer to 8-bit integer
causes that dimension to have four times as many pixels). If no spatial dimension has a
stride of 1, a new dimension with a stride of 1 will be created, this will be dimension
number 0.</p>
<p>If the target <code>dataType</code> is larger than the source data type, then the spatial dimension
that has a stride 1 will shrink. The input size along that dimension must be a multiple
of the shrink factor, otherwise an exception will be thrown. If no spatial dimension has
a stride of 1, an exception will be thrown. Furthermore, all strides in the image must
be compatible with the new data size, if this is not the case, an exception will be thrown.</p>
<p>If the target and source data types have the same size, this operation will always succeed.
For the special case of complex to real casting, see <a href="dip-Image.html#dip-Image-SplitComplex-dip-uint-"><code>dip::Image::SplitComplex</code></a> and
<a href="dip-Image.html#dip-Image-MergeComplex-dip-uint-"><code>dip::Image::MergeComplex</code></a>.</p>
<p>The tensor dimension will never be used in the logic described above.</p>
<p>The pixel sizes for the modified dimension will not change, though they will likely be
meaningless after this operation.</p>
<p>If the image shares data with other images, the other images will still view the pixels in
their original data type. Interpreting data as a different type is inherently dangerous,
the C++ standard considers it Undefined Behaviour. Use this function only if you know what
you are doing.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Convert-dip-DataType-"><code>dip::Image::Convert</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCastToSignedInteger"><code>dip::Image::ReinterpretCastToSignedInteger</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCastToUnsignedInteger"><code>dip::Image::ReinterpretCastToUnsignedInteger</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ReinterpretCastToSignedInteger"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ReinterpretCastToSignedInteger" class="m-doc-self">ReinterpretCastToSignedInteger</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Changes the data type of <code>this</code> to a signed integer of the same size, without changing the data.</p>
<p>If the image shares data with other images, the other images will still view the pixels in
their original data type. Interpreting data as a different type is inherently dangerous,
but changing the signedness of an integer type is relatively benign. Thus, this function is
safer to use than <a href="dip-Image.html#dip-Image-ReinterpretCast-dip-DataType-"><code>dip::Image::ReinterpretCast</code></a>.</p>
<p>This function is always fast. The image must be forged and of an integer type.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Convert-dip-DataType-"><code>dip::Image::Convert</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCast-dip-DataType-"><code>dip::Image::ReinterpretCast</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCastToUnsignedInteger"><code>dip::Image::ReinterpretCastToUnsignedInteger</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ReinterpretCastToUnsignedInteger"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ReinterpretCastToUnsignedInteger" class="m-doc-self">ReinterpretCastToUnsignedInteger</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Changes the data type of <code>this</code> to an unsigned integer of the same size, without changing the data.</p>
<p>If the image shares data with other images, the other images will still view the pixels in
their original data type. Interpreting data as a different type is inherently dangerous,
but changing the signedness of an integer type is relatively benign. Thus, this function is
safer to use than <a href="dip-Image.html#dip-Image-ReinterpretCast-dip-DataType-"><code>dip::Image::ReinterpretCast</code></a>.</p>
<p>This function is always fast. The image must be forged and of an integer type.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-Convert-dip-DataType-"><code>dip::Image::Convert</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCast-dip-DataType-"><code>dip::Image::ReinterpretCast</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCastToSignedInteger"><code>dip::Image::ReinterpretCastToSignedInteger</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-" class="m-doc-self">Crop</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER)</span></span>
            </h3>
            <p>Reduces the size of the image by cropping off the borders.</p>
<p>Crops the image to the given size. Which pixels are selected is controlled by the
<code>cropLocation</code> parameter. The default is <a href="supporttypes.html#dip-Option-CropLocation-CENTER"><code>dip::Option::CropLocation::CENTER</code></a>, which
maintains the origin pixel (as defined in <a href="transform.html#dip-FourierTransform-Image-CL-Image-L-StringSet-CL-BooleanArray-"><code>dip::FourierTransform</code></a> and other other places)
at the origin of the output image.</p>
<p><a href="dip-Image.html#dip-Image-Cropped-UnsignedArray-CL-Option-CropLocation--C"><code>dip::Image::Cropped</code></a> does the same thing, but returning a <a href="dip-Image-View.html"><code>dip::Image::View</code></a> instead
of modifying <code>this</code>. <a href="dip-Image.html#dip-Image-Pad-UnsignedArray-CL-Pixel-CL-Option-CropLocation--C"><code>dip::Image::Pad</code></a> does the inverse operation.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Crop-UnsignedArray-CL-String-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Crop-UnsignedArray-CL-String-CL" class="m-doc-self">Crop</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation)</span></span>
            </h3>
            <p>Reduces the size of the image by cropping off the borders.</p>
<p>This is an overloaded version of the function above. The string <code>cropLocation</code> is translated
to one of the <a href="supporttypes.html#dip-Option-CropLocation"><code>dip::Option::CropLocation</code></a> values as follows:</p>
<table class="m-table">
<thead>
<tr>
<th>String</th>
<th><code>CropLocation</code> constant</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"center"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-CENTER"><code>dip::Option::CropLocation::CENTER</code></a></td>
</tr>
<tr>
<td><code>"mirror center"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-MIRROR_CENTER"><code>dip::Option::CropLocation::MIRROR_CENTER</code></a></td>
</tr>
<tr>
<td><code>"top left"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-TOP_LEFT"><code>dip::Option::CropLocation::TOP_LEFT</code></a></td>
</tr>
<tr>
<td><code>"bottom right"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-BOTTOM_RIGHT"><code>dip::Option::CropLocation::BOTTOM_RIGHT</code></a></td>
</tr>
</tbody>
</table>
          </div></section>
          <section class="m-doc-details" id="dip-Image-At-Image--C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-At-Image--C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> mask) const</span></span>
            </h3>
            <p>Creates a 1D image view containing the pixels selected by <code>mask</code>.</p>
<p>When cast to an image, the values will be copied, not referenced. The output is of the same data type
and tensor shape as <code>this</code>, but has only one dimension. Pixels will be read from <code>mask</code> in the linear
index order.</p>
<p>If <code>mask</code> is a non-scalar image, it must have the same number of tensor elements as <code>this</code>. The created
<code>View</code> will be scalar, as we&rsquo;re selecting individual samples, not pixels. Samples will be read in the
linear index order, reading all samples for the first pixel, then all samples for the second pixel, etc.</p>
<p><code>this</code> must be forged and be of equal size as <code>mask</code>. <code>mask</code> is a binary image.</p>
<p>If mask has no set pixels (i.e. it selects nothing) the <code>View</code> object created will cast to a
<a href="dip-Image.html#image_representation">raw image</a>. For example:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Similar</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">BIN</span><span class="w"> </span><span class="p">);</span>
<span class="n">mask</span><span class="p">.</span><span class="n">Fill</span><span class="p">(</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">);</span>
<span class="n">img</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// This is valid, we write the value 0 to none of the pixels of img.</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// This is also valid, but out will be a raw image.</span>
</pre></div>
          </div></section>
          <section class="m-doc-details" id="dip-Image-At-CoordinateArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-At-CoordinateArray-CL-C" class="m-doc-self">At</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-CoordinateArray" class="m-doc">dip::CoordinateArray</a> const&amp; coordinates) const</span></span>
            </h3>
            <p>Creates a 1D image view containing the pixels selected by <code>coordinates</code>.</p>
<p>When cast to an image, the values will be copied, not referenced. The output is of the same data type
and tensor shape as <code>this</code>, but have only one dimension. It will have as many pixels as coordinates are
in <code>coordinates</code>, and be sorted in the same order.</p>
<p>Each of the coordinates must have the same number of dimensions as <code>this</code>.</p>
<p><code>this</code> must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-AtIndices-UnsignedArray-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-AtIndices-UnsignedArray-CL-C" class="m-doc-self">AtIndices</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; indices) const</span></span>
            </h3>
            <p>Creates a 1D image view containing the pixels selected by <code>indices</code>.</p>
<p>When cast to an image, the values will be copied, not referenced. The output is of the same data type
and tensor shape as <code>this</code>, but have only one dimension. It will have as many pixels as indices are in
<code>indices</code>, and be sorted in the same order.</p>
<p><code>indices</code> contains linear indices into the image. Note that converting indices into offsets is not a
trivial operation; prefer to use the version of this function that uses coordinates.</p>
<p><code>this</code> must be forged.</p>
<p>Note that this function is not called <code>At</code> because of the clash with <code>At( UnsignedArray const&amp; )</code>.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Cropped-UnsignedArray-CL-Option-CropLocation--C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Cropped-UnsignedArray-CL-Option-CropLocation--C" class="m-doc-self">Cropped</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) const</span></span>
            </h3>
            <p>Extracts a subset of pixels from an image.</p>
<p>Returns a view to a smaller area within the image. Which pixels are selected is controlled by the
<code>cropLocation</code> parameter. The default is <a href="supporttypes.html#dip-Option-CropLocation-CENTER"><code>dip::Option::CropLocation::CENTER</code></a>, which
maintains the origin pixel (as defined in <a href="transform.html#dip-FourierTransform-Image-CL-Image-L-StringSet-CL-BooleanArray-"><code>dip::FourierTransform</code></a> and other other places)
at the origin of the output image.</p>
<p><a href="dip-Image.html#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-"><code>dip::Image::Crop</code></a> does the same thing, but modifies the image directly instead of returning a view.
<a href="dip-Image.html#dip-Image-Pad-UnsignedArray-CL-Pixel-CL-Option-CropLocation--C"><code>dip::Image::Pad</code></a> does the inverse operation.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Cropped-UnsignedArray-CL-String-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image-View.html" class="m-doc">dip::Image::View</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Cropped-UnsignedArray-CL-String-CL-C" class="m-doc-self">Cropped</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) const</span></span>
            </h3>
            <p>Extracts a subset of pixels from an image.</p>
<p>This is an overloaded version of the function above. The string <code>cropLocation</code> is translated
to one of the <a href="supporttypes.html#dip-Option-CropLocation"><code>dip::Option::CropLocation</code></a> values as follows:</p>
<table class="m-table">
<thead>
<tr>
<th>String</th>
<th><code>CropLocation</code> constant</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"center"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-CENTER"><code>dip::Option::CropLocation::CENTER</code></a></td>
</tr>
<tr>
<td><code>"mirror center"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-MIRROR_CENTER"><code>dip::Option::CropLocation::MIRROR_CENTER</code></a></td>
</tr>
<tr>
<td><code>"top left"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-TOP_LEFT"><code>dip::Option::CropLocation::TOP_LEFT</code></a></td>
</tr>
<tr>
<td><code>"bottom right"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-BOTTOM_RIGHT"><code>dip::Option::CropLocation::BOTTOM_RIGHT</code></a></td>
</tr>
</tbody>
</table>
          </div></section>
          <section class="m-doc-details" id="dip-Image-QuickCopy-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-QuickCopy-C" class="m-doc-self">QuickCopy</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Quick copy, returns a new image that points at the same data as <code>this</code>,
and has mostly the same properties.</p>
<p>The color space and pixel size information are not copied, and the protect flag is reset.
The external interface is not taken over either.
This function is mostly meant for use in functions that need to modify some properties of
the input images, without actually modifying the input images.</p>
<p><a href="dip-Image.html#dip-Image-Copy-Image-CL"><code>dip::Image::Copy</code></a> is similar, but makes a deep copy of the image, such that the output image
has its own data segment.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Pad-UnsignedArray-CL-Pixel-CL-Option-CropLocation--C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Pad-UnsignedArray-CL-Pixel-CL-Option-CropLocation--C" class="m-doc-self">Pad</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; value,
              <a href="supporttypes.html#dip-Option-CropLocation" class="m-doc">dip::Option::CropLocation</a> cropLocation = Option::CropLocation::CENTER) const</span></span>
            </h3>
            <p>Extends the image by padding with <code>value</code>.</p>
<p>Pads the image to the given size. Where the original image data is located in the output image
is controlled by the <code>cropLocation</code> parameter. The default is <a href="supporttypes.html#dip-Option-CropLocation-CENTER"><code>dip::Option::CropLocation::CENTER</code></a>,
which maintains the origin pixel (as defined in <a href="transform.html#dip-FourierTransform-Image-CL-Image-L-StringSet-CL-BooleanArray-"><code>dip::FourierTransform</code></a> and other other places)
at the origin of the output image.</p>
<p>The object is not modified, a new image is created, with identical properties, but of the requested
size.</p>
<p><a href="boundary.html#dip-ExtendImageToSize-Image-CL-Image-L-UnsignedArray-CL-Option-CropLocation--BoundaryConditionArray--Option-ExtendImageFlags-"><code>dip::ExtendImageToSize</code></a> does the same thing, but filling the new regions according to a boundary
condition. <a href="dip-Image.html#dip-Image-Crop-UnsignedArray-CL-Option-CropLocation-"><code>dip::Image::Crop</code></a> does the inverse operation.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Pad-UnsignedArray-CL-Pixel-CL-String-CL-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Pad-UnsignedArray-CL-Pixel-CL-String-CL-C" class="m-doc-self">Pad</a>(</span><span class="m-doc-wrap"><a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> const&amp; sizes,
              <a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; value,
              <a href="supporttypes.html#dip-String" class="m-doc">dip::String</a> const&amp; cropLocation) const</span></span>
            </h3>
            <p>Extends the image by padding with <code>value</code>.</p>
<p>This is an overloaded version of the function above. The string <code>cropLocation</code> is translated
to one of the <a href="supporttypes.html#dip-Option-CropLocation"><code>dip::Option::CropLocation</code></a> values as follows:</p>
<table class="m-table">
<thead>
<tr>
<th>String</th>
<th><code>CropLocation</code> constant</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"center"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-CENTER"><code>dip::Option::CropLocation::CENTER</code></a></td>
</tr>
<tr>
<td><code>"mirror center"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-MIRROR_CENTER"><code>dip::Option::CropLocation::MIRROR_CENTER</code></a></td>
</tr>
<tr>
<td><code>"top left"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-TOP_LEFT"><code>dip::Option::CropLocation::TOP_LEFT</code></a></td>
</tr>
<tr>
<td><code>"bottom right"</code></td>
<td><a href="supporttypes.html#dip-Option-CropLocation-BOTTOM_RIGHT"><code>dip::Option::CropLocation::BOTTOM_RIGHT</code></a></td>
</tr>
</tbody>
</table>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Copy-Image-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Copy-Image-CL" class="m-doc-self">Copy</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src)</span></span>
            </h3>
            <p>Deep copy, <code>this</code> will become a copy of <code>src</code> with its own data.</p>
<p>If <code>this</code> is forged, and <code>src</code> has the same sizes
and number of tensor elements, then the data is copied over from <code>src</code>
to <code>this</code>. The copy will apply data type conversion, where values are
clipped to the target range and/or truncated, as applicable. Complex
values are converted to non-complex values by taking the absolute
value.</p>
<p>If <code>this</code> is not forged, or its sizes or number of tensor elements don&rsquo;t
match those of <code>src</code>, then <code>this</code> will be forged or reforged to match <code>src</code>,
and then the data from <code>src</code> will be copied over. <code>this</code> will retain its
external interface, if it has one, and not inherit that of <code>src</code>.
Strides will be copied only if the data is contiguous, and any external interface
allows those strides.</p>
<p><code>src</code> must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Copy-C"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Copy-C" class="m-doc-self">Copy</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>Deep copy, returns a copy of <code>this</code> with its own data.</p>
<p><code>this</code> must be forged.</p>
<p>Any external interface is not preserved. Use <a href="dip-Image.html#dip-Copy-Image-CL-Image-L"><code>dip::Copy</code></a> to control the data allocation for the output image.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-QuickCopy-C"><code>dip::Image::QuickCopy</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Convert-dip-DataType-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Convert-dip-DataType-" class="m-doc-self">Convert</a>(</span><span class="m-doc-wrap"><a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt)</span></span>
            </h3>
            <p>Converts the image to another data type.</p>
<p>The data type conversion clips values to the target range and/or truncates them, as applicable.
Complex values are converted to non-complex values by taking the absolute value.</p>
<p>The data segment is replaced by a new one, unless the old and new data
types have the same size and it is not shared with other images.
If the data segment is replaced, strides are set to normal.</p>
<p>A binary image can be converted to an 8-bit integer type without copying or touching the data.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-ReinterpretCast-dip-DataType-"><code>dip::Image::ReinterpretCast</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCastToSignedInteger"><code>dip::Image::ReinterpretCastToSignedInteger</code></a>, <a href="dip-Image.html#dip-Image-ReinterpretCastToUnsignedInteger"><code>dip::Image::ReinterpretCastToUnsignedInteger</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-SwapBytesInSample"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-SwapBytesInSample" class="m-doc-self">SwapBytesInSample</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Swaps bytes in each sample, converting from little endian to big endian or vice versa.</p>
<p>This process works for any data type with more than one byte per sample. For 8-bit integer imgaes and binary
images, nothing is node. The modification will affect all images with shared data. The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ExpandTensor"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ExpandTensor" class="m-doc-self">ExpandTensor</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Expands the image&rsquo;s tensor, such that the tensor representation is a column-major matrix.</p>
<p>If the image has a non-full tensor representation (diagonal, symmetric, triangular), or
a row-major ordering, then the data segment is replaced by a new one. Otherwise, nothing is done.</p>
<p>After calling this method, the object always has <a href="dip-Tensor.html#dip-Tensor-HasNormalOrder-C"><code>dip::Tensor::HasNormalOrder</code></a> equal <code>true</code>.
This method simplifies manipulating tensors by normalizing their storage.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ForceNormalStrides"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ForceNormalStrides" class="m-doc-self">ForceNormalStrides</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Copies pixel data over to a new data segment if the strides are not normal.</p>
<p>Will throw an exception if reallocating the data segment does not yield <a href="concepts.html#normal_strides">Normal strides</a>.
This can happen only if there is an external interface.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-HasNormalStrides-C"><code>dip::Image::HasNormalStrides</code></a>, <a href="dip-Image.html#dip-Image-ForceContiguousData"><code>dip::Image::ForceContiguousData</code></a>, <a href="dip-Image.html#dip-Image-StandardizeStrides"><code>dip::Image::StandardizeStrides</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-ForceContiguousData"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-ForceContiguousData" class="m-doc-self">ForceContiguousData</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>Copies pixel data over to a new data segment if the data is not contiguous.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-HasContiguousData-C"><code>dip::Image::HasContiguousData</code></a>, <a href="dip-Image.html#dip-Image-ForceNormalStrides"><code>dip::Image::ForceNormalStrides</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Separate"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Separate" class="m-doc-self">Separate</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>If the image shares its data segment with another image, create a data copy so it no longer
shares data.</p>
<p>The image must be forged.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Image-IsShared-C"><code>dip::Image::IsShared</code></a>, <a href="dip-Image.html#dip-Image-Copy-Image-CL"><code>dip::Image::Copy</code></a>, <a href="dip-Image.html#dip-Image-ForceNormalStrides"><code>dip::Image::ForceNormalStrides</code></a>, <a href="dip-Image.html#dip-Image-ForceContiguousData"><code>dip::Image::ForceContiguousData</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Fill-Pixel-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Fill-Pixel-CL" class="m-doc-self">Fill</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel)</span></span>
            </h3>
            <p>Sets all pixels in the image to the value <code>pixel</code>.</p>
<p><code>pixel</code> must have the same number of tensor elements as the image, or be a scalar.
Its values will be clipped to the target range and/or truncated, as applicable.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-Fill-Sample-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-Fill-Sample-CL" class="m-doc-self">Fill</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample)</span></span>
            </h3>
            <p>Sets all samples in the image to the value <code>sample</code>.</p>
<p>The value will be clipped to the target range and/or truncated, as applicable.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-operator%3D-Pixel-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-operator%3D-Pixel-CL" class="m-doc-self">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Pixel.html" class="m-doc">dip::Image::Pixel</a> const&amp; pixel)</span></span>
            </h3>
            <p>Sets all pixels in the image to the value <code>pixel</code>.</p>
<p><code>pixel</code> must have the same number of tensor elements as the image, or be a scalar.
Its values will be clipped to the target range and/or truncated, as applicable.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-operator%3D-Sample-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp;
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-operator%3D-Sample-CL" class="m-doc-self">operator=</a>(</span><span class="m-doc-wrap"><a href="dip-Image-Sample.html" class="m-doc">dip::Image::Sample</a> const&amp; sample)</span></span>
            </h3>
            <p>Sets all samples in the image to the value <code>sample</code>.</p>
<p>The value will be clipped to the target range and/or truncated, as applicable.</p>
<p>The image must be forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Image-CopyDataToNewDataSegment"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Image-CopyDataToNewDataSegment" class="m-doc-self">CopyDataToNewDataSegment</a>(</span><span class="m-doc-wrap">) <span class="m-label m-danger">private</span></span></span>
            </h3>
            <p>Allocates a new data segment and copies the data over. The image will be the same as before, but
have <a href="concepts.html#normal_strides">Normal strides</a> and not share data with another image.</p>
<p>Don&rsquo;t call this function if the image is not forged.</p>
          </div></section>
          <section class="m-doc-details" id="dip-DefineROI-Image-CL-Image-L-UnsignedArray--UnsignedArray--UnsignedArray-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-DefineROI-Image-CL-Image-L-UnsignedArray--UnsignedArray--UnsignedArray-" class="m-doc-self">dip::<wbr />DefineROI</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> origin = {},
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> sizes = {},
              <a href="supporttypes.html#dip-UnsignedArray" class="m-doc">dip::UnsignedArray</a> spacing = {})</span></span>
            </h3>
            <p>Makes a new image object pointing to same pixel data as <code>src</code>, but
with different origin, strides and size.</p>
<p>This function does the same as <a href="dip-Image.html#dip-Image-At-UnsignedArray-CL-C"><code>dip::Image::At</code></a>, but allows for more flexible
defaults: If <code>origin</code>, <code>sizes</code> or <code>spacing</code> have only one value, that value is
repeated for each dimension. For empty arrays, <code>origin</code> defaults to all zeros,
<code>sizes</code> to <code>src.Sizes() - origin</code>, and <code>spacing</code> to all ones. These defaults
make it easy to crop pixels from one side of the image, to subsample the image,
etc. For example, the following code subsamples by a factor 2 in each dimension:</p>
<div class="m-code"><pre><span></span><span class="n">DefineROI</span><span class="p">(</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>If <code>dest</code> is protected, or has an external interface set that is different from
<code>src</code>&rsquo;s, then the pixel data will be copied over. Otherwise, <code>dest</code> will share
data with <code>src</code>.</p>
          </div></section>
          <section class="m-doc-details" id="dip-CopyFrom-Image-CL-Image-L-Image-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-CopyFrom-Image-CL-Image-L-Image-CL" class="m-doc-self">dip::<wbr />CopyFrom</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; srcMask)</span></span>
            </h3>
            <p>Copies the pixels selected by <code>srcMask</code> in <code>src</code> over to <code>dest</code>. <code>dest</code> will be a 1D image.</p>
<p>If <code>dest</code> is already forged and has the right number of pixels and tensor elements, it will not be reforged.
In this case, the copy will apply data type conversion, where values are clipped to the target range and/or
truncated, as applicable, and complex values are converted to non-complex values by taking the absolute value.</p>
<p>If <code>srcMask</code> selects no pixels, <code>dest</code> will be a raw image.</p>
          </div></section>
          <section class="m-doc-details" id="dip-CopyFrom-Image-CL-Image-L-IntegerArray-CL"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-CopyFrom-Image-CL-Image-L-IntegerArray-CL" class="m-doc-self">dip::<wbr />CopyFrom</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="supporttypes.html#dip-IntegerArray" class="m-doc">dip::IntegerArray</a> const&amp; srcOffsets)</span></span>
            </h3>
            <p>Copies the pixels selected by <code>srcOffsets</code> over from <code>src</code> to <code>dest</code>. <code>dest</code> will be a 1D image.</p>
<p>If <code>dest</code> is already forged and has the right number of pixels and tensor elements, it will not be reforged.
In this case, the copy will apply data type conversion, where values are clipped to the target range and/or
truncated, as applicable, and complex values are converted to non-complex values by taking the absolute value.</p>
          </div></section>
          <section class="m-doc-details" id="dip-ExpandTensor-Image-CL-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-ExpandTensor-Image-CL-Image-L" class="m-doc-self">dip::<wbr />ExpandTensor</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest)</span></span>
            </h3>
            <p>Copies samples over from <code>src</code> to <code>dest</code>, expanding the tensor so it&rsquo;s a standard, column-major matrix.</p>
<p>If the tensor representation in <code>src</code> is one of those that do not save symmetric or zero values, to save space,
a new data segment will be allocated for <code>dest</code>, where the tensor representation is a column-major matrix
(<code>dest</code> will have <a href="dip-Tensor.html#dip-Tensor-HasNormalOrder-C"><code>dip::Tensor::HasNormalOrder</code></a> be true). Otherwise, <code>dest</code> will share the data segment with <code>src</code>
(unless it&rsquo;s protected or has an external interface, in which case data must be copied).
This function simplifies manipulating tensors by normalizing their storage.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="dip-Image.html#dip-Copy-Image-CL-Image-L"><code>dip::Copy</code></a>, <a href="dip-Image.html#dip-Convert-Image-CL-Image-L-dip-DataType-"><code>dip::Convert</code></a>, <a href="dip-Image.html#dip-Image-ExpandTensor"><code>dip::Image::ExpandTensor</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Convert-Image-CL-Image-L-dip-DataType-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Convert-Image-CL-Image-L-dip-DataType-" class="m-doc-self">dip::<wbr />Convert</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; src,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; dest,
              <a href="dip-DataType.html" class="m-doc">dip::DataType</a> dt)</span></span>
            </h3>
            <p>Copies samples over from <code>src</code> to <code>dest</code>, with data type conversion.</p>
<p>If <code>dest</code> is forged,
has the same size as number of tensor elements as <code>src</code>, and has data type <code>dt</code>, then
its data segment is reused. If <code>src</code> and <code>dest</code> are the same object, its <a href="dip-Image.html#dip-Image-Convert-dip-DataType-"><code>dip::Image::Convert</code></a>
method is called instead.</p>
<p>The data type conversion clips values to the target range and/or truncates them, as applicable.
Complex values are converted to non-complex values by taking the absolute value.</p>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form action="https://diplib.org/diplib-docs/#search">
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:diplib.org+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or modules.
              You can omit any prefix from the symbol or file path; adding a <code>:</code> or
              <code>/</code> suffix lists all members of given symbol or directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span> / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
              <span class="m-label m-dim">Enter</span> to go.
              <span class="m-label m-dim">Tab</span> autocompletes common prefix.
              You can copy a link to the result using <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">L</span>,
              or <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">M</span> to copy a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:diplib.org+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>DIPlib, a library for quantitative image analysis. Documentation compiled with <a href="https://crisluengo.github.io/doxpp/">dox++</a> and styled with <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>