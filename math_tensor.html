<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Math and statistics &raquo; Tensor operators module | DIPlib | a library for quantitative image analysis</title>
  <link rel="stylesheet" href="m-dip+documentation.compiled.css" />
  <link rel="icon" href="DIPlib_logo_32.png" type="image/png" />
  <link rel="search" type="application/opensearchdescription+xml" href="opensearch.xml" title="Search DIPlib documentation" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#ffffff" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://diplib.org"><img src="DIPlib_logo.svg" alt="" />DIPlib</a><span class="m-breadcrumb">┃</span><a href="index.html" class="m-thin">a library for quantitative image analysis</a><span class="m-breadcrumb">┃</span><a href="https://github.com/DIPlib/diplib/releases/tag/3.4.0" class="m-thin">version 3.4.0</a>      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="classes.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="math.html">Math and statistics</a> &raquo;</span>
          Tensor operators <span class="m-thin">module</span>          <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="file--diplib--math-h.html">"diplib/math.h"</a></div>
        </h1>
        <p>Operators specific to tensor images.</p>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#function-members">Functions</a></li>
              </ul>
            </li>
          </ul>
        </div>
        <section id="function-members">
          <h2>Functions</h2>
          <dl class="m-doc">
            <dt id="dip-Transpose-dip-Image-CL">
              <span class="m-doc-wrap-bumper">auto <a href="#dip-Transpose-dip-Image-CL" class="m-doc-self">dip::<wbr />Transpose</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in) -&gt; <a href="dip-Image.html" class="m-doc">dip::Image</a></span>
            </dt>
            <dd>Transposes the tensor image, the data are not copied.</dd>
            <dt id="dip-ConjugateTranspose-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-ConjugateTranspose-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />ConjugateTranspose</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the conjugate transpose of the tensor image <code>in</code>.</dd>
            <dt id="dip-DotProduct-dip-Image-CL-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-DotProduct-dip-Image-CL-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />DotProduct</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; lhs,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; rhs,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the dot product (inner product) of two vector images.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-CrossProduct-dip-Image-CL-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />CrossProduct</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; lhs,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; rhs,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the cross product (inner product) of two vector images.</dd>
            <dt id="dip-Norm-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Norm-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Norm</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the norm of the vector at each pixel in image <code>in</code>.</dd>
            <dt id="dip-SquareNorm-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-SquareNorm-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />SquareNorm</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the square of the norm of the vector at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Angle-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />Angle</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the angle of the vector at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Orientation-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />Orientation</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the orientation of the vector at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-CartesianToPolar-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />CartesianToPolar</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Converts the vector at each pixel in image <code>in</code> from Cartesian coordinates to polar
(or spherical) coordinates.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-PolarToCartesian-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />PolarToCartesian</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Converts the vector at each pixel in image <code>in</code> from polar (or spherical) coordinates to
Cartesian coordinates.</dd>
            <dt id="dip-Determinant-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Determinant-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Determinant</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the determinant of the square matrix at each pixel in image <code>in</code>.</dd>
            <dt id="dip-Trace-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Trace-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Trace</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the trace of the square matrix at each pixel in image <code>in</code>.</dd>
            <dt id="dip-Rank-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-Rank-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Rank</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the rank of the square matrix at each pixel in image <code>in</code>.
The output is DT_UINT8, under the assumption that we won&rsquo;t have tensor images with a rank higher than 255.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Eigenvalues-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />Eigenvalues</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the eigenvalues of the square matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-LargestEigenvalue-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />LargestEigenvalue</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Finds the largest eigenvalue of the square matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-SmallestEigenvalue-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />SmallestEigenvalue</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Finds the smallest eigenvalue of the square matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-EigenDecomposition-dip-Image-CL-dip-Image-L-dip-Image-L" class="m-doc">dip::<wbr />EigenDecomposition</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; eigenvectors)</span>
            </dt>
            <dd>Computes the eigenvalues and eigenvectors of the square matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-LargestEigenvector-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />LargestEigenvector</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Finds the largest eigenvector of the symmetric matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-SmallestEigenvector-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />SmallestEigenvector</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Finds the smallest eigenvector of the symmetric matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Inverse-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />Inverse</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the inverse of the square matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-PseudoInverse-dip-Image-CL-dip-Image-L-dip-dfloat-" class="m-doc">dip::<wbr />PseudoInverse</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> tolerance = 1e-7)</span>
            </dt>
            <dd>Computes the pseudo-inverse of the matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-SingularValues-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />SingularValues</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the &ldquo;thin&rdquo; singular value decomposition of the matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-SingularValueDecomposition-dip-Image-CL-dip-Image-L-dip-Image-L-dip-Image-L" class="m-doc">dip::<wbr />SingularValueDecomposition</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; A,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; U,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; S,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; V)</span>
            </dt>
            <dd>Computes the &ldquo;thin&rdquo; singular value decomposition of the matrix at each pixel in image <code>in</code>.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#dip-Identity-dip-Image-CL-dip-Image-L" class="m-doc">dip::<wbr />Identity</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Creates an image whose pixels are identity matrices.</dd>
            <dt id="dip-SumTensorElements-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-SumTensorElements-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />SumTensorElements</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Adds all tensor elements, producing a scalar image.</dd>
            <dt id="dip-ProductTensorElements-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-ProductTensorElements-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />ProductTensorElements</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Multiplies all tensor elements, producing a scalar image.</dd>
            <dt id="dip-AllTensorElements-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-AllTensorElements-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />AllTensorElements</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Determines if all tensor elements are non-zero, producing a binary scalar image.</dd>
            <dt id="dip-AnyTensorElement-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-AnyTensorElement-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />AnyTensorElement</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Determines if any tensor element is non-zero, producing a binary scalar image.</dd>
            <dt id="dip-MaximumTensorElement-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-MaximumTensorElement-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />MaximumTensorElement</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Takes the maximum tensor element at each pixel, producing a scalar image.</dd>
            <dt id="dip-MaximumAbsTensorElement-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-MaximumAbsTensorElement-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />MaximumAbsTensorElement</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Takes the maximum absolute tensor element at each pixel, producing a scalar image. For float and complex images only.</dd>
            <dt id="dip-MinimumTensorElement-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-MinimumTensorElement-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />MinimumTensorElement</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Takes the minimum tensor element at each pixel, producing a scalar image.</dd>
            <dt id="dip-MinimumAbsTensorElement-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-MinimumAbsTensorElement-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />MinimumAbsTensorElement</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Takes the minimum absolute tensor element at each pixel, producing a scalar image. For float and complex images only.</dd>
            <dt id="dip-MeanTensorElement-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-MeanTensorElement-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />MeanTensorElement</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the mean tensor element value at each pixel, producing a scalar image.</dd>
            <dt id="dip-GeometricMeanTensorElement-dip-Image-CL-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-GeometricMeanTensorElement-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />GeometricMeanTensorElement</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Computes the geometric mean tensor element value at each pixel, producing a scalar image.</dd>
            <dt id="dip-SortTensorElements-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-SortTensorElements-dip-Image-L" class="m-doc-self">dip::<wbr />SortTensorElements</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Sorts the tensor elements within each pixel from largest to smallest. Works in-place. <code>out</code> must be
real-valued.</dd>
            <dt id="dip-SortTensorElementsByMagnitude-dip-Image-L">
              <span class="m-doc-wrap-bumper">void <a href="#dip-SortTensorElementsByMagnitude-dip-Image-L" class="m-doc-self">dip::<wbr />SortTensorElementsByMagnitude</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span>
            </dt>
            <dd>Sorts the tensor elements within each pixel by magnitude from largest to smallest. Works in-place.
<code>out</code> must be of a floating point or complex type.</dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="dip-CrossProduct-dip-Image-CL-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-CrossProduct-dip-Image-CL-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />CrossProduct</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; lhs,
              <a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; rhs,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Computes the cross product (inner product) of two vector images.</p>
<p>Input image tensors must be 2-vectors or 3-vectors. For 3-vectors, the cross product is as
commonly defined in 3D. For 2-vectors, we define the cross product as the z-component
of the cross product of the 3D vectors obtained by adding a 0 z-component to the inputs.
That is, it is the area of the parallelogram formed by the two 2D vectors.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Angle-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Angle-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Angle</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Computes the angle of the vector at each pixel in image <code>in</code>.</p>
<p><code>in</code> must be a 2-vector or a 3-vector. For a 2-vector, <code>out</code> is a scalar image representing
<em>phi</em>, the angle from the x-axis. For a 3-vector, <code>out</code> has 2 tensor components, corresponding
to <em>phi</em> and <em>theta</em>. <em>phi</em>, as in the 2D case, is the angle from the x-axis within the x-y plane
(azimuth). <em>theta</em> is the angle from the z-axis (inclination). See <a href="math_tensor.html#dip-CartesianToPolar-dip-Image-CL-dip-Image-L"><code>dip::CartesianToPolar</code></a> for
more details. This function yields the same output as <a href="math_tensor.html#dip-CartesianToPolar-dip-Image-CL-dip-Image-L"><code>dip::CartesianToPolar</code></a>, but without
the first tensor component.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="numeric.html#dip-Norm-T-dip-uint--ConstSampleIterator&lt;T&gt;-"><code>dip::Norm</code></a>, <a href="math_tensor.html#dip-Orientation-dip-Image-CL-dip-Image-L"><code>dip::Orientation</code></a>, <a href="math_tensor.html#dip-PolarToCartesian-dip-Image-CL-dip-Image-L"><code>dip::PolarToCartesian</code></a>, <a href="math_tensor.html#dip-CartesianToPolar-dip-Image-CL-dip-Image-L"><code>dip::CartesianToPolar</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Orientation-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Orientation-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Orientation</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Computes the orientation of the vector at each pixel in image <code>in</code>.</p>
<p>Orientation is defined as the angle mapped to the half-circle or half-sphere with positive x-coordinate.
That is, in 2D it is an angle in the range (-&pi;/2, &pi;/2), and in 3D the <em>phi</em> component is mapped to
that same range. See <a href="dip-Vertex-T.html#dip-Angle-T-Vertex&lt;T&gt;-CL-Vertex&lt;T&gt;-CL"><code>dip::Angle</code></a> for more information.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="numeric.html#dip-Norm-T-dip-uint--ConstSampleIterator&lt;T&gt;-"><code>dip::Norm</code></a>, <a href="dip-Vertex-T.html#dip-Angle-T-Vertex&lt;T&gt;-CL-Vertex&lt;T&gt;-CL"><code>dip::Angle</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-CartesianToPolar-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-CartesianToPolar-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />CartesianToPolar</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Converts the vector at each pixel in image <code>in</code> from Cartesian coordinates to polar
(or spherical) coordinates.</p>
<p><code>in</code> must be a 2-vector or a 3-vector. <code>out</code> is a same-size vector containing <em>r</em> and <em>phi</em>
in the 2D case, and <em>r</em>, <em>phi</em> and <em>theta</em> in the 3D case. <em>phi</em> is the angle to the x-axis
within the x-y plane (azimuth). <em>theta</em> is the angle from the z-axis (inclination).</p>
<p>That is, in 2D:</p>
<div class="m-code"><pre><span></span><span class="n">in</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Cos</span><span class="p">(</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">in</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sin</span><span class="p">(</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>and in 3D:</p>
<div class="m-code"><pre><span></span><span class="n">in</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Cos</span><span class="p">(</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sin</span><span class="p">(</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">in</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sin</span><span class="p">(</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sin</span><span class="p">(</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">in</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Cos</span><span class="p">(</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>

<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="math_tensor.html#dip-PolarToCartesian-dip-Image-CL-dip-Image-L"><code>dip::PolarToCartesian</code></a>, <a href="numeric.html#dip-Norm-T-dip-uint--ConstSampleIterator&lt;T&gt;-"><code>dip::Norm</code></a>, <a href="dip-Vertex-T.html#dip-Angle-T-Vertex&lt;T&gt;-CL-Vertex&lt;T&gt;-CL"><code>dip::Angle</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-PolarToCartesian-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-PolarToCartesian-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />PolarToCartesian</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Converts the vector at each pixel in image <code>in</code> from polar (or spherical) coordinates to
Cartesian coordinates.</p>
<p><code>in</code> must be a 2-vector or a 3-vector. See <a href="math_tensor.html#dip-CartesianToPolar-dip-Image-CL-dip-Image-L"><code>dip::CartesianToPolar</code></a> for a description of the polar
coordinates used.</p>
<aside class="m-note m-default">
<h4>See also</h4>
<p><a href="math_tensor.html#dip-CartesianToPolar-dip-Image-CL-dip-Image-L"><code>dip::CartesianToPolar</code></a>, <a href="numeric.html#dip-Norm-T-dip-uint--ConstSampleIterator&lt;T&gt;-"><code>dip::Norm</code></a>, <a href="dip-Vertex-T.html#dip-Angle-T-Vertex&lt;T&gt;-CL-Vertex&lt;T&gt;-CL"><code>dip::Angle</code></a></p>
</aside>
          </div></section>
          <section class="m-doc-details" id="dip-Eigenvalues-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Eigenvalues-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Eigenvalues</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Computes the eigenvalues of the square matrix at each pixel in image <code>in</code>.</p>
<p><code>out</code> is a vector image containing the eigenvalues. If <code>in</code> is symmetric and
real-valued, then <code>out</code> is real-valued, otherwise, <code>out</code> is complex-valued.
The eigenvalues are sorted by magnitude, in descending order.</p>
          </div></section>
          <section class="m-doc-details" id="dip-LargestEigenvalue-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-LargestEigenvalue-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />LargestEigenvalue</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Finds the largest eigenvalue of the square matrix at each pixel in image <code>in</code>.</p>
<p>Computes the eigenvalues in the same way as <a href="math_tensor.html#dip-Eigenvalues-dip-Image-CL-dip-Image-L"><code>dip::Eigenvalues</code></a>, but
outputs only the eigenvector with the largest magnitude.</p>
          </div></section>
          <section class="m-doc-details" id="dip-SmallestEigenvalue-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-SmallestEigenvalue-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />SmallestEigenvalue</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Finds the smallest eigenvalue of the square matrix at each pixel in image <code>in</code>.</p>
<p>Computes the eigenvalues in the same way as <a href="math_tensor.html#dip-Eigenvalues-dip-Image-CL-dip-Image-L"><code>dip::Eigenvalues</code></a>, but
outputs only the eigenvector with the smallest magnitude.</p>
          </div></section>
          <section class="m-doc-details" id="dip-EigenDecomposition-dip-Image-CL-dip-Image-L-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-EigenDecomposition-dip-Image-CL-dip-Image-L-dip-Image-L" class="m-doc-self">dip::<wbr />EigenDecomposition</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; eigenvectors)</span></span>
            </h3>
            <p>Computes the eigenvalues and eigenvectors of the square matrix at each pixel in image <code>in</code>.</p>
<p>The decomposition is such that <code>in * eigenvectors == eigenvectors * out</code>.
<code>eigenvectors</code> is almost always invertible, in which case one can write
<code>in == eigenvectors * out * Inverse( eigenvectors )</code>.</p>
<p><code>out</code> is a diagonal matrix image containing the eigenvalues. If <code>in</code> is symmetric and
real-valued, then <code>out</code> is real-valued, otherwise, <code>out</code> is complex-valued.
The eigenvalues are sorted by magnitude, in descending order.</p>
<p>The eigenvectors are the columns <code>eigenvectors</code>. It has the same data type as <code>out</code>.</p>
          </div></section>
          <section class="m-doc-details" id="dip-LargestEigenvector-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-LargestEigenvector-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />LargestEigenvector</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Finds the largest eigenvector of the symmetric matrix at each pixel in image <code>in</code>.</p>
<p>Computes the eigen decomposition in the same way as <a href="numeric.html#dip-EigenDecomposition-dip-uint--ConstSampleIterator&lt;dip-dfloat&gt;--SampleIterator&lt;dip-dcomplex&gt;--SampleIterator&lt;dip-dcomplex&gt;-"><code>dip::EigenDecomposition</code></a>, but
outputs only the eigenvector that corresponds to the eigenvalue with largest magnitude.</p>
<p><code>in</code> must be symmetric and real-valued.</p>
          </div></section>
          <section class="m-doc-details" id="dip-SmallestEigenvector-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-SmallestEigenvector-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />SmallestEigenvector</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Finds the smallest eigenvector of the symmetric matrix at each pixel in image <code>in</code>.</p>
<p>Computes the eigen decomposition in the same way as <a href="numeric.html#dip-EigenDecomposition-dip-uint--ConstSampleIterator&lt;dip-dfloat&gt;--SampleIterator&lt;dip-dcomplex&gt;--SampleIterator&lt;dip-dcomplex&gt;-"><code>dip::EigenDecomposition</code></a>, but
outputs only the eigenvector that corresponds to the eigenvalue with smallest magnitude.</p>
<p><code>in</code> must be symmetric and real-valued.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Inverse-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Inverse-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Inverse</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Computes the inverse of the square matrix at each pixel in image <code>in</code>.</p>
<p>The result is undetermined if the matrix is not invertible.</p>
          </div></section>
          <section class="m-doc-details" id="dip-PseudoInverse-dip-Image-CL-dip-Image-L-dip-dfloat-"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-PseudoInverse-dip-Image-CL-dip-Image-L-dip-dfloat-" class="m-doc-self">dip::<wbr />PseudoInverse</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out,
              <a href="pixeltypes.html#dip-dfloat" class="m-doc">dip::dfloat</a> tolerance = 1e-7)</span></span>
            </h3>
            <p>Computes the pseudo-inverse of the matrix at each pixel in image <code>in</code>.</p>
<p>Computes the Moore-Penrose pseudo-inverse using <code>tolerance</code>. Singular values smaller than
<code>tolerance * max(rows,cols) * p</code>, with <code>p</code> the largest singular value, will be set to zero in the inverse.</p>
          </div></section>
          <section class="m-doc-details" id="dip-SingularValues-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-SingularValues-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />SingularValues</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Computes the &ldquo;thin&rdquo; singular value decomposition of the matrix at each pixel in image <code>in</code>.</p>
<p>For an input image <code>in</code> with a tensor size of NxP, and with M the smaller of N and P, <code>out</code> is a
vector image with M elements, corresponding to the singular values, sorted in decreasing order.</p>
<p>Use <a href="numeric.html#dip-SingularValueDecomposition-dip-uint--dip-uint--ConstSampleIterator&lt;dip-dfloat&gt;--SampleIterator&lt;dip-dfloat&gt;--SampleIterator&lt;dip-dfloat&gt;--SampleIterator&lt;dip-dfloat&gt;-"><code>dip::SingularValueDecomposition</code></a> if you need the full decomposition.</p>
<p>This function uses the two-sided Jacobi SVD decomposition algorithm.
This is efficient for small matrices only.</p>
          </div></section>
          <section class="m-doc-details" id="dip-SingularValueDecomposition-dip-Image-CL-dip-Image-L-dip-Image-L-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-SingularValueDecomposition-dip-Image-CL-dip-Image-L-dip-Image-L-dip-Image-L" class="m-doc-self">dip::<wbr />SingularValueDecomposition</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; A,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; U,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; S,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; V)</span></span>
            </h3>
            <p>Computes the &ldquo;thin&rdquo; singular value decomposition of the matrix at each pixel in image <code>in</code>.</p>
<p>For an input image <code>A</code> with a tensor size of NxP, and with M the smaller of N and P, <code>S</code> is a
square diagonal MxM matrix, <code>U</code> is a NxM matrix, and V is a PxM matrix. These matrices satisfy
the relation <span class="m-math"><svg style="width: 4.883em; height: 0.848em; vertical-align: -0.021em; " viewBox=".29 -8.27 48.83 8.48">
<title>
\(A = USV^*\)
</title>
<defs>
<path id='eq152-g1-61' d='M6.57-3.93V-4.6H.48V-3.93H6.57ZM6.57-1.51V-2.18H.48V-1.51H6.57Z'/>
<path id='eq152-g4-3' d='M3.57-2.92C3.57-3.07 3.45-3.22 3.29-3.22C3.09-3.22 2.38-2.51 2.12-2.36C2.12-2.85 2.37-3.34 2.37-3.63C2.37-3.82 2.24-3.93 2.06-3.93C1.89-3.93 1.78-3.81 1.78-3.63C1.78-3.29 1.99-2.83 1.99-2.36C1.71-2.52 1.03-3.26 .85-3.26C.69-3.26 .55-3.11 .55-2.95C.55-2.65 1.58-2.44 1.92-2.24C1.55-2.04 .87-1.93 .7-1.82C.61-1.76 .54-1.68 .54-1.56C.54-1.41 .66-1.27 .82-1.27C1.02-1.27 1.73-1.97 1.99-2.12C1.99-1.64 1.75-1.15 1.75-.85C1.75-.67 1.88-.55 2.05-.55S2.33-.68 2.33-.85C2.33-1.21 2.13-1.66 2.13-2.12C2.4-1.97 3.09-1.23 3.27-1.23C3.42-1.23 3.56-1.38 3.56-1.54C3.56-1.65 3.49-1.73 3.4-1.78C3.17-1.93 2.57-2.03 2.19-2.24C2.6-2.49 3.16-2.52 3.42-2.67C3.51-2.73 3.57-2.8 3.57-2.92Z'/>
<path id='eq152-g7-22' d='M6.72 0V-.19C6.04-.25 5.96-.35 5.81-1.21L4.69-7.96H4.38L.93-2C-.01-.42-.13-.29-.61-.19V0H1.62V-.19C1.01-.25 .92-.31 .92-.61C.92-.83 .95-.94 1.16-1.35L1.83-2.69H4.45L4.69-1.13C4.7-1.02 4.72-.92 4.72-.82C4.72-.37 4.55-.26 3.79-.19V0H6.72ZM4.39-3.12H2.08L3.87-6.22L4.39-3.12Z'/>
<path id='eq152-g7-40' d='M5.13-2.17C5.13-2.94 4.87-3.39 3.79-4.49C2.7-5.57 2.61-5.74 2.61-6.32C2.61-7.07 3.11-7.54 3.92-7.54C4.36-7.54 4.72-7.4 4.97-7.11C5.24-6.81 5.34-6.41 5.36-5.61L5.57-5.57L6.05-7.94H5.78C5.61-7.69 5.5-7.63 5.24-7.63C5.09-7.63 4.94-7.67 4.69-7.77C4.44-7.87 4.05-7.93 3.68-7.93C2.44-7.93 1.56-7.11 1.56-5.94C1.56-5.3 1.74-4.95 2.45-4.19C2.61-4.04 2.76-3.87 2.92-3.69L3.38-3.19C3.94-2.61 4.1-2.3 4.1-1.79C4.1-.88 3.44-.2 2.56-.2C1.56-.2 .82-1.05 .82-2.22C.82-2.3 .82-2.35 .85-2.45L.61-2.48L.2 .18H.42C.5-.1 .63-.21 .87-.21C1-.21 1.17-.17 1.49-.06C2.04 .14 2.36 .21 2.73 .21C4.1 .21 5.13-.81 5.13-2.17Z'/>
<path id='eq152-g7-42' d='M9.11-7.59V-7.78H6.74V-7.59C7.37-7.53 7.59-7.4 7.59-7.04C7.59-6.85 7.29-5.67 6.71-3.62L6.55-3.04C6.03-1.08 5.26-.27 3.95-.27C2.97-.27 2.29-.83 2.29-1.68C2.29-2.08 2.64-3.49 3.45-6.28L3.51-6.5C3.76-7.34 3.95-7.5 4.76-7.59V-7.78H1.51V-7.59C2.32-7.52 2.44-7.44 2.44-7.1C2.44-6.96 2.41-6.77 2.36-6.56L1.73-4.28C1.36-2.98 1.21-2.24 1.21-1.74C1.21-.61 2.3 .21 3.81 .21C5.37 .21 6.36-.63 6.88-2.42L7.87-5.81C8.33-7.36 8.37-7.42 9.11-7.59Z'/>
<path id='eq152-g7-43' d='M8.19-7.59V-7.78H5.98V-7.59C6.52-7.53 6.73-7.41 6.73-7.18S6.52-6.46 6.11-5.76L3.66-1.52L2.87-6.8C2.86-6.86 2.86-6.92 2.86-6.98C2.86-7.38 3.03-7.5 3.78-7.59V-7.78H.91V-7.59C1.57-7.5 1.6-7.47 1.85-5.98L2.86 .21H3.08L7.53-7.11C7.73-7.43 7.92-7.58 8.19-7.59Z'/>
</defs>
<g id='eq152-page1'>
<use x='.9' y='0' xlink:href='#eq152-g7-22'/>
<use x='11.68' y='0' xlink:href='#eq152-g1-61'/>
<use x='21.66' y='0' xlink:href='#eq152-g7-42'/>
<use x='31.22' y='0' xlink:href='#eq152-g7-40'/>
<use x='37.13' y='0' xlink:href='#eq152-g7-43'/>
<use x='45.54' y='-4.34' xlink:href='#eq152-g4-3'/>
</g>
</svg></span>.</p>
<p>The (diagonal) elements of <code>S</code> are the singular values, sorted in decreasing order.
You can use <a href="math_tensor.html#dip-SingularValues-dip-Image-CL-dip-Image-L"><code>dip::SingularValues</code></a> if you are not interested in computing <code>U</code> and <code>V</code>.</p>
<p>This function uses the two-sided Jacobi SVD decomposition algorithm.
This is efficient for small matrices only.</p>
          </div></section>
          <section class="m-doc-details" id="dip-Identity-dip-Image-CL-dip-Image-L"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void
                </span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#dip-Identity-dip-Image-CL-dip-Image-L" class="m-doc-self">dip::<wbr />Identity</a>(</span><span class="m-doc-wrap"><a href="dip-Image.html" class="m-doc">dip::Image</a> const&amp; in,
              <a href="dip-Image.html" class="m-doc">dip::Image</a>&amp; out)</span></span>
            </h3>
            <p>Creates an image whose pixels are identity matrices.</p>
<p><code>out</code> will have the same sizes as <code>in</code>, and with a tensor representation of a diagonal matrix
with a size concordant to that of the tensor representation of <code>in</code>. For example, for an N-vector
image, the resulting output matrix image will be NxN. <code>out</code> will be of type <a href="pixeltypes.html#dip-DT_SFLOAT"><code>dip::DT_SFLOAT</code></a>.</p>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form action="https://diplib.org/diplib-docs/#search">
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:diplib.org+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or modules.
              You can omit any prefix from the symbol or file path; adding a <code>:</code> or
              <code>/</code> suffix lists all members of given symbol or directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span> / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
              <span class="m-label m-dim">Enter</span> to go.
              <span class="m-label m-dim">Tab</span> autocompletes common prefix.
              You can copy a link to the result using <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">L</span>,
              or <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">M</span> to copy a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:diplib.org+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>DIPlib, a library for quantitative image analysis. Documentation compiled with <a href="https://crisluengo.github.io/doxpp/">dox++</a> and styled with <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>