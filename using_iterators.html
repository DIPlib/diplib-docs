<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Using iterators to implement filters | DIPlib | a library for quantitative image analysis</title>
  <link rel="stylesheet" href="m-dip+documentation.compiled.css" />
  <link rel="icon" href="DIPlib_logo_32.png" type="image/png" />
  <link rel="search" type="application/opensearchdescription+xml" href="opensearch.xml" title="Search DIPlib documentation" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#ffffff" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://diplib.org"><img src="DIPlib_logo.svg" alt="" />DIPlib</a><span class="m-breadcrumb">┃</span><a href="index.html" class="m-thin">a library for quantitative image analysis</a><span class="m-breadcrumb">┃</span><a href="https://github.com/DIPlib/diplib/releases/tag/3.4.1" class="m-thin">version 3.4.1</a>      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="classes.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Using iterators to implement filters
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#iterate_one_image">Visiting each pixel in a single image</a></li>
            <li><a href="#iterate_two_images">Processing an image using a separate output image</a></li>
            <li><a href="#iterate_lines">Processing an image line by line</a></li>
            <li><a href="#iterate_neighborhood">Applying an arbitrary neighborhood filter</a></li>
            <li><a href="#iterate_slices">Processing an image slice by slice</a></li>
            <li><a href="#iterate_tensor">Processing an image tensor element by tensor element</a></li>
          </ul>
        </div>
<p><em>DIPlib</em> provides a set of iterators that can be used to efficiently visit all
pixels in an image, independently of the dimensionality of the image.
These iterators can be used to implement filters and other monadic operators.
This page shows how to use these iterators to write different types of image
processing functionality. However, most of the filters in <em>DIPlib</em> are not written
using these iterators, but using the functions in the <a href="dip-Framework.html"><code>dip::Framework</code></a> namespace.
Those functions take care of:</p>
<ul>
<li>parallel processing,</li>
<li>overloading for different data types,</li>
<li>boundary conditions, and</li>
<li>allocating the data segment for the output image(s).</li>
</ul>
<p>Note that using iterators is not necessarily less efficient than using
the framework functions. Depending on the application of the image processing
function you are writing, and on the complexity you are willing to deal with,
you can choose to use either an iterator or a framework function.</p>
<h2 id="iterate_one_image">Visiting each pixel in a single image</h2>
<p>To loop over each pixel in an image and modify its value, you can use the
<a href="dip-ImageIterator-T.html"><code>dip::ImageIterator</code></a> :</p>
<div class="m-code"><pre><span></span><span class="n">DIP_THROW_IF</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">DataType</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting 16-bit unsigned integer image&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">ImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>This construct works for an image of any dimensionality and size, but only for an
image of type <code>dip::uint16</code>. Instead of throwing an error if the image doesn&rsquo;t
match expectation, you can convert it:</p>
<div class="m-code"><pre><span></span><span class="n">img</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>To handle images of different data types with the same loop, write the loop in a
templated function, then call the right version of the function with the
<a href="overload.html#macro--DIP_OVL_CALL_REAL"><code>DIP_OVL_CALL_REAL</code></a> macro or any of its relatives defined in <a href="file--diplib--overload-h.html">diplib/overload.h</a>:</p>
<div class="m-code"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">ProcessImage_subfunc</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">ImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">ProcessImage</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">DIP_OVL_CALL_REAL</span><span class="p">(</span><span class="w"> </span><span class="n">processImage_subfunc</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">img</span><span class="p">),</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">dataType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>The <a href="overload.html#macro--DIP_OVL_CALL_REAL"><code>DIP_OVL_CALL_REAL</code></a> macro will throw an exception if the image is of a type
that does not correspond to the <code>REAL</code> group, so there is no need to test for that
separately.</p>
<p>A wholly different way of handling images of different data types is using the
<a href="dip-GenericImageIterator-T.html"><code>dip::GenericImageIterator</code></a>, which is a simpler, non-templated version of the
<a href="dip-ImageIterator-T.html"><code>dip::ImageIterator</code></a> that cannot be dereferenced, but instead provides a <code>void</code>
pointer to the sample. The code inside the loop must be able to handle such a
pointer, so this is only useful in very specific circumstances.</p>
<p>Note that the code above does not handle tensor images, presuming the image is
scalar. A test for that should be included, or alternatively the tensor elements
should be processed. There are two ways of doing so:</p>
<ul>
<li>
<p>The simplest is to create a copy of the input image (which would use the same
  data segment), and modify this copy so that the tensor dimension becomes a
  spatial dimension. The loop above would then iterate over each sample, rather
  than each pixel:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">QuickCopy</span><span class="p">();</span>
<span class="n">tmp</span><span class="p">.</span><span class="n">TensorToSpatial</span><span class="p">();</span>
<span class="n">dip</span><span class="o">::</span><span class="n">ImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="p">);</span>
<span class="p">...</span>
</pre></div>

</li>
<li>
<p>The second way is to explicitly iterate over the tensor elements within the
  main loop. This allows the different tensor elements to be treated differently.
  Simply note that the iterator <code>it</code> points at the first element of the tensor,
  and using the <code>[]</code> indexing operator yields the other tensor elements:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">ImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">te</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">te</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">TensorElements</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">te</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">it</span><span class="p">[</span><span class="w"> </span><span class="n">te</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Alternatively, iterate over the tensor elements using the corresponding
iterator (see <a href="dip-SampleIterator-T.html"><code>dip::SampleIterator</code></a>):</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">ImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">te</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">te</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">te</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="n">te</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

</li>
</ul>
<h2 id="iterate_two_images">Processing an image using a separate output image</h2>
<p>The <a href="dip-JointImageIterator-T.html"><code>dip::JointImageIterator</code></a> loops over multiple images at the same time. The images
must all have the same sizes:</p>
<div class="m-code"><pre><span></span><span class="n">DIP_THROW_IF</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">DataType</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting 16-bit unsigned integer image&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Similar</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SFLOAT</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">JointImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">sfloat</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">it</span><span class="p">.</span><span class="n">Out</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">In</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Note that <code>it.In()</code> returns a reference to the sample in the first image, and <code>it.Out()</code>
to the same sample in the second image. These are aliases for the generic <code>it.Sample&lt;N&gt;()</code>.
The joint image iterator cannot be dereferenced, as it points at multiple samples at the
same time.</p>
<p>To access the various tensor elements, use the <code>it.InSample(index)</code>, <code>it.OutSample(index)</code>,
or the generic <code>it.Sample&lt;N&gt;(index)</code> methods.</p>
<p>There is also a <a href="dip-GenericJointImageIterator-T.html"><code>dip::GenericJointImageIterator</code></a>, which, just like
<a href="dip-GenericImageIterator-T.html"><code>dip::GenericImageIterator</code></a>, is a version of the iterator that
provides a <code>void</code> pointer to each pixel.</p>
<h2 id="iterate_lines">Processing an image line by line</h2>
<p>Some processing requires access to a whole image line at the time. Both the
<a href="dip-ImageIterator-T.html"><code>dip::ImageIterator</code></a> and the <a href="dip-JointImageIterator-T.html"><code>dip::JointImageIterator</code></a> allow to specify one
dimension over which is not looped. In combination with the <a href="dip-LineIterator-T.html"><code>dip::LineIterator</code></a>,
one can create functions that process one line at a time:</p>
<div class="m-code"><pre><span></span><span class="n">DIP_THROW_IF</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">DataType</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting 16-bit unsigned integer image&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">ImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">lit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">GetLineIterator</span><span class="p">();</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">lit</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">lit</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">mean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">lit</span><span class="p">.</span><span class="n">Length</span><span class="p">();</span>
<span class="w">   </span><span class="n">lit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">GetLineIterator</span><span class="p">();</span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mean</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">lit</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">mean</span><span class="p">;</span>
<span class="w">      </span><span class="o">*</span><span class="n">lit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">clamp_cast</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">lit</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>A one-dimensional filter can be implemented using the line iterator as an array:</p>
<div class="m-code"><pre><span></span><span class="n">DIP_THROW_IF</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">DataType</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting 16-bit unsigned integer image&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Similar</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_SFLOAT</span><span class="w"> </span><span class="p">);</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">9.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">9.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">9.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">9.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">9.0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>
<span class="n">dip</span><span class="o">::</span><span class="n">JointImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">sfloat</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">iit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">GetLineIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">oit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">GetLineIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="c1">// At the beginning of the line the filter has only partial support within the image</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">ii</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">oit</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="n">oit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="w"> </span><span class="n">filter</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ii</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">iit</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="c1">// In the middle of the line the filter has full support</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">oit</span><span class="p">.</span><span class="n">Length</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">ii</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">iit</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">oit</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="n">oit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="w"> </span><span class="n">filter</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">filter</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">iit</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="c1">// At the end of the line the filter has only partial support</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">ii</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">iit</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">oit</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="n">oit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="w"> </span><span class="n">filter</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">filter</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="p">,</span><span class="w"> </span><span class="n">iit</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Note that separable filters use such line by line operations along each dimension
to compose full filters.</p>
<h2 id="iterate_neighborhood">Applying an arbitrary neighborhood filter</h2>
<div class="m-code"><pre><span></span><span class="n">DIP_THROW_IF</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">DataType</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting 16-bit unsigned integer image&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">ExtendImage</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;masked&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// a copy of the input image with data ouside of its domain</span>
<span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">Similar</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">DT_UINT16</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">PixelTable</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;elliptic&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">PixelTableOffsets</span><span class="w"> </span><span class="n">offsets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">Prepare</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">JointImageIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="n">dip</span><span class="o">::</span><span class="n">sint</span><span class="w"> </span><span class="n">inStride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">Stride</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">iit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">GetLineIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">oit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">GetLineIterator</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="c1">// Compute the sum across all pixels in the kernels for the first point on the line only</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">offsets</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="n">iit</span><span class="p">.</span><span class="n">Pointer</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="o">*</span><span class="n">oit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">NumberOfPixels</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="o">++</span><span class="n">oit</span><span class="p">;</span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Subtract the pixels that will exit the kernel when it moves</span>
<span class="w">      </span><span class="c1">// Add the pixels that will enter the kernel when it moves</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">offsets</span><span class="p">.</span><span class="n">Runs</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="n">value</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="n">iit</span><span class="p">.</span><span class="n">Pointer</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">run</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="n">iit</span><span class="p">.</span><span class="n">Pointer</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">run</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">sint</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">run</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inStride</span><span class="w"> </span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="o">*</span><span class="n">oit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint16</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">NumberOfPixels</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">iit</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">oit</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// the two images are of the same size, the line iterators reach the end at the same time</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>We first create a copy of the input image with expanded domain. The image <code>in</code> is identical to
<code>img</code>, but we can read outside the bounds where data have been filled in. Not having to check for
reads being within the image domain saves a lot of time, more than making up for creating the
copy of the input image.</p>
<p>The outer loop iterates over all lines in the image (in this case, the lines lie along dimension
0). For the first pixel in the line we compute the sum of values over
the kernel (note that we directly index by adding the offset to the data pointer, there&rsquo;s no
checking). But for the rest of the pixels in the line, we subtract the values for the first
pixel in each run of the kernel, then move the kernel over, and add the values for the last pixel
in each run. This bookkeeping makes the operation much cheaper. Being able to loop over the lines
of the image, instead of only over each pixel in the image, allows for simple implementation of
many efficient algorithms.</p>
<h2 id="iterate_slices">Processing an image slice by slice</h2>
<p>Take for example the case of a time series image, a 3D image where the 3<sup>rd</sup> dimension is
time. One might want to filter each of the 2D slices in the same way, but not mix
information from one slice to another. Some image processing functions allow to specify
which dimensions are to be processed, one can choose to process only the first two dimensions.
With other filters one can set the size of the neighborhood to 1 along the 3<sup>rd</sup>
dimension, so that effectively no filtering is applied in that direction. But a few
filters are written explicitly for 2D images, or do not make it possible to restrict
processing dimensions. <a href="binary.html#dip-EuclideanSkeleton-dip-Image-CL-dip-Image-L-dip-String-CL-dip-String-CL"><code>dip::EuclideanSkeleton</code></a> is an example of the latter. The
skeleton is always computed across the full image. To apply it to each of the slices
in the time series one can use the <a href="dip-ImageSliceIterator.html"><code>dip::ImageSliceIterator</code></a>:</p>
<div class="m-code"><pre><span></span><span class="n">dip</span><span class="o">::</span><span class="n">ImageSliceIterator</span><span class="w"> </span><span class="nf">it</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">EuclideanSkeleton</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;natural&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>
</pre></div>

<p>Here, the slice iterator <code>it</code> points at a 2D subimage of the 3D image <code>img</code>,
in which the 3<sup>rd</sup> dimension (dimension number 2) of <code>img</code> is removed. It is
possible to read and write to the pixels of this slice, but it is not possible
to strip or reforge it.
When constructed, the iterator points at the slice for index 0. Each time it is
incremented, the next slice is indexed. As with the other image iterators,
testing it results in <code>false</code> when the iterator points past the last slice and
should not be dereferenced, making the loop logic quite compact.</p>
<p>This iterator allows adding or subtracting any integer, meaning that it is
possible to navigate to any slice. This is a very cheap operation, and requires
no data copies. Note that the loop above is much more efficient than a similar
loop using indexing:</p>
<div class="m-code"><pre><span></span><span class="c1">// Identical result to the previous code block, but less efficient</span>
<span class="n">dip</span><span class="o">::</span><span class="n">RangeArray</span><span class="w"> </span><span class="nf">ra</span><span class="p">(</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">sint</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">Size</span><span class="p">(</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">ii</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">ra</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Range</span><span class="p">(</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">Image</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="w"> </span><span class="n">ra</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="n">slice</span><span class="p">.</span><span class="n">Squeeze</span><span class="p">();</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">EuclideanSkeleton</span><span class="p">(</span><span class="w"> </span><span class="n">slice</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;natural&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>The difference in efficiency might or might not be important depending on
the cost of the function being applied to each 2D slice.</p>
<h2 id="iterate_tensor">Processing an image tensor element by tensor element</h2>
<p>The <a href="dip-ImageSliceIterator.html"><code>dip::ImageSliceIterator</code></a> can also be used to iterate over the tensor elements
of an image. In this case, dereferencing the iterator yields a scalar image
corresponding to <code>img[ ii ]</code>. The two following pieces of code are equivalent:</p>
<div class="m-code"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">ImageTensorIterator</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">Dilation</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="w"> </span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">dip</span><span class="o">::</span><span class="n">uint</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">img</span><span class="p">.</span><span class="n">TensorElements</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">ii</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">dip</span><span class="o">::</span><span class="n">Dilation</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="p">[</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="n">img</span><span class="p">[</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>As in the previous section, the difference in efficiency (the iterator is more
efficient) might not be important depending on the cost of the function being
called.</p>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form action="https://diplib.org/diplib-docs/#search">
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:diplib.org+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or modules.
              You can omit any prefix from the symbol or file path; adding a <code>:</code> or
              <code>/</code> suffix lists all members of given symbol or directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span> / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
              <span class="m-label m-dim">Enter</span> to go.
              <span class="m-label m-dim">Tab</span> autocompletes common prefix.
              You can copy a link to the result using <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">L</span>,
              or <span class="m-label m-dim">⌘</span> <span class="m-label m-dim">M</span> to copy a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:diplib.org+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>DIPlib, a library for quantitative image analysis. Documentation compiled with <a href="https://crisluengo.github.io/doxpp/">dox++</a> and styled with <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>